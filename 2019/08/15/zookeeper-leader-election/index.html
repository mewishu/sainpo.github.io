<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="Zookeeper选举概述时机Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举:  　　(1) 服务器初始化启动。 　　(2) 服务器运行期间无法和Leader保持连接。 在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leade">
<meta name="keywords" content="zookeeper,Leader选举">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper选举机制及源码解析">
<meta property="og:url" content="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/index.html">
<meta property="og:site_name" content="窦小固的小木屋">
<meta property="og:description" content="Zookeeper选举概述时机Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举:  　　(1) 服务器初始化启动。 　　(2) 服务器运行期间无法和Leader保持连接。 在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leade">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/616953-20161202213100568-693960760.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/616953-20161206114702772-1120304539.png">
<meta property="og:updated_time" content="2019-08-16T03:24:17.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zookeeper选举机制及源码解析">
<meta name="twitter:description" content="Zookeeper选举概述时机Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举:  　　(1) 服务器初始化启动。 　　(2) 服务器运行期间无法和Leader保持连接。 在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leade">
<meta name="twitter:image" content="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/616953-20161202213100568-693960760.png">
  <link rel="canonical" href="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>zookeeper选举机制及源码解析 | 窦小固的小木屋</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">窦小固的小木屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">西河书生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    <div class="reading-progress-bar"></div>

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/15/zookeeper-leader-election/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">zookeeper选举机制及源码解析

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-15 19:54:10" itemprop="dateCreated datePublished" datetime="2019-08-15T19:54:10+08:00">2019-08-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-16 11:24:17" itemprop="dateModified" datetime="2019-08-16T11:24:17+08:00">2019-08-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/" itemprop="url" rel="index"><span itemprop="name">分布式一致性</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon"
              >
                <i class="fa fa-eye"></i>
                 阅读次数： 
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">46k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">42 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Zookeeper选举概述"><a href="#Zookeeper选举概述" class="headerlink" title="Zookeeper选举概述"></a>Zookeeper选举概述</h2><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举: </p>
<p>　　(1) 服务器初始化启动。</p>
<p>　　(2) 服务器运行期间无法和Leader保持连接。</p>
<p>在Zookeeper运行期间，Leader与非Leader服务器各司其职，即便当有非Leader服务器宕机或新加入，此时也不会影响Leader，但是一旦Leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮Leader选举，其过程和启动时期的Leader选举过程基本一致。假设正在运行的有Server1、Server2、Server3三台服务器，当前Leader是Server2，若某一时刻Leader挂了，此时便开始Leader选举。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。Leader 选举过程，本质就是广播<code>优先级消息</code>的过程，选出<strong>数据最新的服务节点</strong>，选出<strong>优先级最高的服务节点</strong>，基本步骤：</p>
<ol>
<li><p><strong>每个Server发出一个投票</strong>。Server1和Server2都会将自己作为Leader服务器来进行投票，广播自己的优先级标识 <code>(sid，zxid)</code>。例如服务器启动时，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</p>
</li>
<li><p><strong>接受来自各个服务器的投票</strong>。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</p>
</li>
<li><p><strong>处理投票</strong>。服务器节点收到其他广播消息后，跟自己的优先级对比，自己优先级低，则变更当前节点投票的优先级<code>(sid，zxid)</code> ，并广播变更后的结果，优先级PK规则: </p>
<ol>
<li>优先比较 <code>zxid</code> （事务 ID），其次比较<code>sid</code>（服务器ID）</li>
<li><code>sid</code> (服务器 ID) 是节点配置文件中设定的</li>
</ol>
<p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p>
</li>
<li><p><strong>统计投票</strong>。当任意一个服务器节点收到的投票数，超过了<code>法定数量</code>(quorum)亦即集群规模大小的半数以上，则升级为 Leader，并广播结果。对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</p>
</li>
<li><p><strong>改变服务器状态</strong>。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p>
</li>
</ol>
<h2 id="Leader选举算法分析"><a href="#Leader选举算法分析" class="headerlink" title="Leader选举算法分析"></a>Leader选举算法分析</h2><p>在3.4.0后的Zookeeper的版本只保留了TCP版本的FastLeaderElection选举算法。当一台机器进入Leader选举时，当前集群可能会处于以下两种状态</p>
<ul>
<li>集群中已经存在Leader。</li>
<li>集群中不存在Leader。</li>
</ul>
<p>对于集群中已经存在Leader而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器而言，仅仅需要和Leader机器建立起连接，并进行状态同步即可。而在集群中不存在Leader情况下则会相对复杂，其步骤如下。</p>
<h3 id="第一次投票"><a href="#第一次投票" class="headerlink" title="第一次投票"></a>第一次投票</h3><p>无论哪种导致进行Leader选举，集群的所有机器都处于试图选举出一个Leader的状态，即LOOKING状态，LOOKING机器会向所有其他机器发送消息，该消息称为投票。投票中包含了(sid，zxid) 形式来标识一次投票信息。假定Zookeeper由5台机器组成，<code>sid</code>分别为1、2、3、4、5，<code>zxid</code>分别为9、9、9、8、8，并且此时<code>sid</code>为2的机器是Leader机器，某一时刻，1、2所在机器出现故障，因此集群开始进行Leader选举。在第一次投票时，每台机器都会将自己作为投票对象，于是<code>sid</code>为3、4、5的机器投票情况分别为(3, 9)，(4, 8)， (5, 8)。</p>
<h3 id="变更投票"><a href="#变更投票" class="headerlink" title="变更投票"></a>变更投票</h3><p>每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个Leader选举算法的核心所在，其中术语描述如下: </p>
<ul>
<li><strong>vote_sid</strong>：接收到的投票中所推举Leader服务器的<code>sid</code>。</li>
<li><strong>vote_zxid</strong>：接收到的投票中所推举Leader服务器的<code>zxid</code>。</li>
<li><strong>self_sid</strong>：当前服务器自己的<code>sid</code>。</li>
<li><strong>self_zxid</strong>：当前服务器自己的<code>zxid</code>。</li>
</ul>
<p>每次对收到的投票的处理，都是对(vote_sid, vote_zxid)和(self_sid, self_zxid)对比的过程。</p>
<ol>
<li>规则一：如果vote_zxid大于self_zxid，就认可当前收到的投票，并再次将该投票发送出去。</li>
<li>规则二：如果vote_zxid小于self_zxid，那么坚持自己的投票，不做任何变更。</li>
<li>规则三：如果vote_zxid等于self_zxid，那么就对比两者的SID，如果vote_sid大于self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。</li>
<li>规则四：如果vote_zxid等于self_zxid，并且vote_sid小于self_sid，那么坚持自己的投票，不做任何变更。</li>
</ol>
<p>　　结合上面规则，给出下面的集群变更过程。</p>
<p><img src="/2019/08/15/zookeeper-leader-election/616953-20161202213100568-693960760.png" alt="Lead选举集群变更过程"></p>
<h3 id="确定Leader"><a href="#确定Leader" class="headerlink" title="确定Leader"></a>确定Leader</h3><p>经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的SID机器即为Leader。此时Server3将成为Leader。</p>
<p>由上面规则可知，通常那台服务器上的数据越新（<code>zxid</code>会越大），其成为Leader的可能性越大，也就越能够保证数据的恢复。如果<code>zxid</code>相同，则<code>sid</code>越大机会越大。</p>
<h2 id="Leader选举实现细节"><a href="#Leader选举实现细节" class="headerlink" title="Leader选举实现细节"></a>Leader选举实现细节</h2><h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<p><strong>LOOKING</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</p>
<p><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是Follower。</p>
<p><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader。</p>
<p><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是Observer。</p>
<h3 id="投票数据结构"><a href="#投票数据结构" class="headerlink" title="投票数据结构"></a>投票数据结构</h3><p>每个投票中包含了两个最基本的信息，所推举服务器的<code>sid</code>和<code>zxid</code>，投票（Vote）在Zookeeper中包含字段如下</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">被推举 Leader 的 <code>sid</code></td>
</tr>
<tr>
<td align="left">zxid</td>
<td align="left">被推举 Leader 的<code>zxid</code></td>
</tr>
<tr>
<td align="left">electionEpoch</td>
<td align="left">投票的轮次，逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作</td>
</tr>
<tr>
<td align="left">peerEpoch</td>
<td align="left">被推举 Leader 的 epoch</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">当前服务器的状态</td>
</tr>
</tbody></table>
<p>一次 Leader 选举过程，属于同一个 <code>electionEpoch</code>，结束时，会选出新的 Leader；服务器节点，在比较 <code>(sid，zxid)</code> 之前，会先比较选举轮次 <code>electionEpoch</code>，只有同一轮次的 Leader 投票信息才是有效的：</p>
<ol>
<li>外部投票轮次 &gt; 内部投票轮次，更新内部投票，并且触发当前节点投票信息的<strong>重新广播</strong></li>
<li>外部投票轮次 &lt; 内部投票轮次，直接忽略当前的外部投票</li>
<li>外部投票轮次 = 内部投票轮次，进一步比较 <code>(sid，zxid)</code></li>
</ol>
<p>疑问：Leader 负责执行所有的事务操作，一次事务操作，</p>
<ol>
<li>Leader 如何将事务操作同步到 Follower 和 Observer ？同步、异步？</li>
<li>如何保证同步过程中，事务一定执行成功？事务失败的影响？</li>
</ol>
<p>Leader 上执行的事务状态，通过 <code>Zab</code> 状态更新的广播协议，更新到 Follower 和 Observer。</p>
<h3 id="QuorumCnxManager：网络I-O"><a href="#QuorumCnxManager：网络I-O" class="headerlink" title="QuorumCnxManager：网络I/O"></a>QuorumCnxManager：网络I/O</h3><p>每台服务器在启动的过程中，会启动一个QuorumPeerManager，负责各台服务器之间的底层Leader选举过程中的网络通信。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>QuorumCnxManager内部维护了一系列的队列，用来保存接收到的、待发送的消息以及消息的发送器，除接收队列以外，其他队列都按照SID分组形成队列集合，如一个集群中除了自身还有3台机器，那么就会为这3台机器分别创建一个发送队列，互不干扰。</p>
<ul>
<li><strong>recvQueue</strong>：消息接收队列，用于存放那些从其他服务器接收到的消息。</li>
<li><strong>queueSendMap</strong>：消息发送队列，用于保存那些待发送的消息，按照<code>sid</code>进行分组。</li>
<li><strong>senderWorkerMap</strong>：发送器集合，每个SenderWorker消息发送器，都对应一台远程Zookeeper服务器，负责消息的发送，也按照SID进行分组。</li>
<li><strong>lastMessageSent</strong>：最近发送过的消息，为每个<code>sid</code>保留最近发送过的一个消息。</li>
</ul>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>为了能够相互投票，Zookeeper集群中的所有机器都需要两两建立起网络连接。QuorumCnxManager在启动时会创建一个ServerSocket来监听Leader选举的通信端口(默认为3888)。开启监听后，Zookeeper能够不断地接收到来自其他服务器的创建连接请求，在接收到其他服务器的TCP连接请求时，会进行处理。为了避免两台机器之间重复地创建TCP连接，Zookeeper只允许<code>sid</code>大的服务器主动和其他机器建立连接，否则断开连接。在接收到创建连接请求后，服务器通过对比自己和远程服务器的<code>sid</code>值来判断是否接收连接请求，如果当前服务器发现自己的<code>sid</code>更大，那么会断开当前连接，然后自己主动和远程服务器建立连接。一旦连接建立，就会根据远程服务器的SID来创建相应的消息发送器SendWorker和消息接收器RecvWorker，并启动。</p>
<h4 id="消息接收与发送"><a href="#消息接收与发送" class="headerlink" title="消息接收与发送"></a>消息接收与发送</h4><p><strong>消息接收</strong>：由消息接收器RecvWorker负责，由于Zookeeper为每个远程服务器都分配一个单独的RecvWorker，因此，每个RecvWorker只需要不断地从这个TCP连接中读取消息，并将其保存到recvQueue队列中。</p>
<p><strong>消息发送</strong>：由于Zookeeper为每个远程服务器都分配一个单独的SendWorker，因此，每个SendWorker只需要不断地从对应的消息发送队列中获取出一个消息发送即可，同时将这个消息放入lastMessageSent中。在SendWorker中，一旦Zookeeper发现针对当前服务器的消息发送队列为空，那么此时需要从lastMessageSent中取出一个最近发送过的消息来进行再次发送，这是为了解决接收方在消息接收前或者接收到消息后服务器挂了，导致消息尚未被正确处理。同时，Zookeeper能够保证接收方在处理消息时，会对重复消息进行正确的处理。</p>
<h3 id="FastLeaderElection：选举算法核心"><a href="#FastLeaderElection：选举算法核心" class="headerlink" title="FastLeaderElection：选举算法核心"></a>FastLeaderElection：选举算法核心</h3><h4 id="选票管理"><a href="#选票管理" class="headerlink" title="选票管理"></a>选票管理</h4><ul>
<li><strong>sendqueue</strong>：选票发送队列，用于保存待发送的选票。</li>
<li><strong>recvqueue</strong>：选票接收队列，用于保存接收到的外部投票。</li>
<li><strong>WorkerReceiver</strong>：选票接收器。其会不断地从QuorumCnxManager中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</li>
<li><strong>WorkerSender</strong>：选票发送器，不断地从sendqueue中获取待发送的选票，并将其传递到底层QuorumCnxManager中。</li>
</ul>
<h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><p><img src="/2019/08/15/zookeeper-leader-election/616953-20161206114702772-1120304539.png" alt="FastLeaderElection模块是如何与底层网络I/O进行交互"></p>
<p>上图展示了FastLeaderElection模块是如何与底层网络I/O进行交互的。Leader选举的基本流程如下: </p>
<ol>
<li><p><strong>自增选举轮次</strong>。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。</p>
</li>
<li><p><strong>初始化选票</strong>。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader。</p>
</li>
<li><p><strong>发送初始化选票</strong>。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。</p>
</li>
<li><p><strong>接收外部投票</strong>。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。</p>
</li>
<li><p><strong>判断选举轮次</strong>。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。</p>
<ul>
<li><strong>外部投票的选举轮次大于内部投票</strong>。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。</li>
<li><strong>外部投票的选举轮次小于内部投票</strong>。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。</li>
<li><strong>外部投票的选举轮次等于内部投票</strong>。此时可以开始进行选票PK。</li>
</ul>
</li>
<li><p><strong>选票PK</strong>。在进行选票PK时，符合任意一个条件就需要变更投票。</p>
<ul>
<li>若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。</li>
<li>若选举轮次一致，那么就对比两者的<code>zxid</code>，若外部投票的<code>zxid</code>大，那么需要变更投票。</li>
<li>若两者的ZXID一致，那么就对比两者的<code>sid</code>，若外部投票的<code>sid</code>大，那么就需要变更投票。</li>
</ul>
</li>
<li><p><strong>变更投票</strong>。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。</p>
</li>
<li><p><strong>选票归档</strong>。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票（按照服务队的SID区别，如{(1, vote1), (2, vote2)…}）。</p>
</li>
<li><p><strong>统计投票</strong>。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤4。</p>
</li>
<li><p><strong>更新服务器状态</strong>。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。</p>
</li>
</ol>
<p>　　以上10个步骤就是FastLeaderElection的核心，其中步骤4-9会经过几轮循环，直到有Leader选举产生。</p>
<h2 id="FastLeaderElection源码分析"><a href="#FastLeaderElection源码分析" class="headerlink" title="FastLeaderElection源码分析"></a>FastLeaderElection源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系　"></a>类的继承关系　</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastLeaderElection</span> <span class="keyword">implements</span> <span class="title">Election</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>　　说明：FastLeaderElection实现了Election接口，其需要实现接口中定义的lookForLeader方法和shutdown方法，其是标准的Fast Paxos算法的实现，各服务器之间基于TCP协议进行选举。</p>
<h3 id="类的内部类"><a href="#类的内部类" class="headerlink" title="类的内部类"></a>类的内部类</h3><p>FastLeaderElection有三个较为重要的内部类，分别为Notification、ToSend、Messenger。</p>
<h4 id="Notification类"><a href="#Notification类" class="headerlink" title="Notification类"></a>Notification类</h4><p>Notification表示收到的选举投票信息（其他服务器发来的选举投票信息），其包含了被选举者的id、zxid、选举周期等信息，其buildMsg方法将选举信息封装至ByteBuffer中再进行发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Notifications are messages that let other peers know that</span></span><br><span class="line"><span class="comment"> * a given peer has changed its vote, either because it has</span></span><br><span class="line"><span class="comment"> * joined leader election or because it learned of another</span></span><br><span class="line"><span class="comment"> * peer with higher zxid or same zxid and higher server id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Format version, introduced in 3.4.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CURRENTVERSION = <span class="number">0x2</span>;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proposed leader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> leader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zxid of the proposed leader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> zxid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Epoch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> electionEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current state of sender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QuorumPeer.ServerState state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Address of sender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> sid;</span><br><span class="line">    </span><br><span class="line">    QuorumVerifier qv;</span><br><span class="line">    <span class="comment">/*Notification</span></span><br><span class="line"><span class="comment">     * epoch of the proposed leader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> peerEpoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ToSend类"><a href="#ToSend类" class="headerlink" title="ToSend类"></a>ToSend类</h4><p>ToSend表示发送给其他服务器的选举投票信息，也包含了被选举者的id、zxid、选举周期等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Messages that a peer wants to send to other peers.</span></span><br><span class="line"><span class="comment"> * These messages can be both Notifications and Acks</span></span><br><span class="line"><span class="comment"> * of reception of notification.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">enum</span> mType &#123;crequest, challenge, notification, ack&#125;</span><br><span class="line"></span><br><span class="line">    ToSend(mType type,</span><br><span class="line">            <span class="keyword">long</span> leader,</span><br><span class="line">            <span class="keyword">long</span> zxid,</span><br><span class="line">            <span class="keyword">long</span> electionEpoch,</span><br><span class="line">            ServerState state,</span><br><span class="line">            <span class="keyword">long</span> sid,</span><br><span class="line">            <span class="keyword">long</span> peerEpoch,</span><br><span class="line">            <span class="keyword">byte</span>[] configData) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.leader = leader;</span><br><span class="line">        <span class="keyword">this</span>.zxid = zxid;</span><br><span class="line">        <span class="keyword">this</span>.electionEpoch = electionEpoch;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">        <span class="keyword">this</span>.peerEpoch = peerEpoch;</span><br><span class="line">        <span class="keyword">this</span>.configData = configData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proposed leader in the case of notification</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> leader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * id contains the tag for acks, and zxid for notifications</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> zxid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Epoch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> electionEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Current state;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QuorumPeer.ServerState state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Address of recipient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> sid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Used to send a QuorumVerifier (configuration info)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] configData = dummyData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Leader epoch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> peerEpoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Messenger类"><a href="#Messenger类" class="headerlink" title="Messenger类"></a>Messenger类</h4><p>Messenger包含了WorkerReceiver和WorkerSender两个内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选票发送器</span></span><br><span class="line">        WorkerSender ws;</span><br><span class="line">        <span class="comment">// 选票接收器</span></span><br><span class="line">        WorkerReceiver wr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Messenger(QuorumCnxManager manager) &#123;</span><br><span class="line">		<span class="comment">// 创建WorkerSender</span></span><br><span class="line">    <span class="keyword">this</span>.ws = <span class="keyword">new</span> WorkerSender(manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.wsThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.ws,</span><br><span class="line">            <span class="string">"WorkerSender[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">this</span>.wsThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 创建WorkerReceiver</span></span><br><span class="line">    <span class="keyword">this</span>.wr = <span class="keyword">new</span> WorkerReceiver(manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.wrThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.wr,</span><br><span class="line">            <span class="string">"WorkerReceiver[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">this</span>.wrThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WorkerReceiver"><a href="#WorkerReceiver" class="headerlink" title="WorkerReceiver"></a>WorkerReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Receives messages from instance of QuorumCnxManager on</span></span><br><span class="line"><span class="comment"> * method run(), and processes such messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerReceiver</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">  	<span class="comment">// 服务器之间的连接</span></span><br><span class="line">    QuorumCnxManager manager;</span><br><span class="line"></span><br><span class="line">    WorkerReceiver(QuorumCnxManager manager) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"WorkerReceiver"</span>);</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Message response;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// Sleeps on receive</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 从recvQueue中取出一个选举投票消息（从其他服务器发送过来）</span></span><br><span class="line">                response = manager.pollRecvQueue(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">              	<span class="comment">// 无投票，跳过</span></span><br><span class="line">                <span class="keyword">if</span>(response == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 大小校验</span></span><br><span class="line">                ... </span><br><span class="line">                </span><br><span class="line">                response.buffer.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate Notification and set its attributes</span></span><br><span class="line">	              <span class="comment">// 创建接收通知</span></span><br><span class="line">                Notification n = <span class="keyword">new</span> Notification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rstate = response.buffer.getInt();</span><br><span class="line">                <span class="keyword">long</span> rleader = response.buffer.getLong();</span><br><span class="line">                <span class="keyword">long</span> rzxid = response.buffer.getLong();</span><br><span class="line">                <span class="keyword">long</span> relectionEpoch = response.buffer.getLong();</span><br><span class="line">                <span class="keyword">long</span> rpeerepoch;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> version = <span class="number">0x0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!backCompatibility28) &#123;</span><br><span class="line">                    rpeerepoch = response.buffer.getLong();</span><br><span class="line">                    <span class="keyword">if</span> (!backCompatibility40) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Version added in 3.4.6</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        </span><br><span class="line">                        version = response.buffer.getInt();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG.info(<span class="string">"Backward compatibility mode (36 bits), server id: &#123;&#125;"</span>, response.sid);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOG.info(<span class="string">"Backward compatibility mode (28 bits), server id: &#123;&#125;"</span>, response.sid);</span><br><span class="line">                    rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                QuorumVerifier rqv = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if we have a version that includes config. If so extract config info from message.</span></span><br><span class="line">                <span class="keyword">if</span> (version &gt; <span class="number">0x1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> configLength = response.buffer.getInt();</span><br><span class="line">                    <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[configLength];</span><br><span class="line"></span><br><span class="line">                    response.buffer.get(b);</span><br><span class="line">                                               </span><br><span class="line">                    <span class="keyword">synchronized</span>(self) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            rqv = self.configFromString(<span class="keyword">new</span> String(b));</span><br><span class="line">                            QuorumVerifier curQV = self.getQuorumVerifier();</span><br><span class="line">                            <span class="keyword">if</span> (rqv.getVersion() &gt; curQV.getVersion()) &#123;</span><br><span class="line">                                LOG.info(<span class="string">"&#123;&#125; Received version: &#123;&#125; my version: &#123;&#125;"</span>, self.getId(),</span><br><span class="line">                                        Long.toHexString(rqv.getVersion()),</span><br><span class="line">                                        Long.toHexString(self.getQuorumVerifier().getVersion()));</span><br><span class="line">                                <span class="keyword">if</span> (self.getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">                                    LOG.debug(<span class="string">"Invoking processReconfig(), state: &#123;&#125;"</span>, self.getServerState());</span><br><span class="line">                                    self.processReconfig(rqv, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                                    <span class="keyword">if</span> (!rqv.equals(curQV)) &#123;</span><br><span class="line">                                        LOG.info(<span class="string">"restarting leader election"</span>);</span><br><span class="line">                                        self.shuttingDownLE = <span class="keyword">true</span>;</span><br><span class="line">                                        self.getElectionAlg().shutdown();</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    LOG.debug(<span class="string">"Skip processReconfig(), state: &#123;&#125;"</span>, self.getServerState());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            LOG.error(<span class="string">"Something went wrong while processing config received from &#123;&#125;"</span>, response.sid);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (ConfigException e) &#123;</span><br><span class="line">                           LOG.error(<span class="string">"Something went wrong while processing config received from &#123;&#125;"</span>, response.sid);</span><br><span class="line">                       &#125;</span><br><span class="line">                    &#125;                          </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOG.info(<span class="string">"Backward compatibility mode (before reconfig), server id: &#123;&#125;"</span>, response.sid);</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If it is from a non-voting server (such as an observer or</span></span><br><span class="line"><span class="comment">                 * a non-voting follower), respond right away.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span>(!validVoter(response.sid)) &#123;</span><br><span class="line">                    Vote current = self.getCurrentVote();</span><br><span class="line">                    QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                    ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                            current.getId(),</span><br><span class="line">                            current.getZxid(),</span><br><span class="line">                            logicalclock.get(),</span><br><span class="line">                            self.getPeerState(),</span><br><span class="line">                            response.sid,</span><br><span class="line">                            current.getPeerEpoch(),</span><br><span class="line">                            qv.toString().getBytes());</span><br><span class="line"></span><br><span class="line">                    sendqueue.offer(notmsg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Receive new message</span></span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                        LOG.debug(<span class="string">"Receive new notification message. My id = "</span></span><br><span class="line">                                + self.getId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// State of peer that sent this message</span></span><br><span class="line">                  	<span class="comment">// 推选者的状态</span></span><br><span class="line">                    QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                    <span class="keyword">switch</span> (rstate) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        ackstate = QuorumPeer.ServerState.FOLLOWING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        ackstate = QuorumPeer.ServerState.LEADING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        ackstate = QuorumPeer.ServerState.OBSERVING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    n.leader = rleader;</span><br><span class="line">                    n.zxid = rzxid;</span><br><span class="line">                    n.electionEpoch = relectionEpoch;</span><br><span class="line">                    n.state = ackstate;</span><br><span class="line">                    n.sid = response.sid;</span><br><span class="line">                    n.peerEpoch = rpeerepoch;</span><br><span class="line">                    n.version = version;</span><br><span class="line">                    n.qv = rqv;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Print notification info</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span>(LOG.isInfoEnabled())&#123;</span><br><span class="line">                        printNotification(n);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * If this server is looking, then send proposed leader</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                        recvqueue.offer(n);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Send a notification back if the peer that sent this</span></span><br><span class="line"><span class="comment">                         * message is also looking and its logical clock is</span></span><br><span class="line"><span class="comment">                         * lagging behind.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span>((ackstate == QuorumPeer.ServerState.LOOKING)</span><br><span class="line">                                &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;</span><br><span class="line">                            <span class="comment">// 获取自己的投票</span></span><br><span class="line">                          	Vote v = getVote();</span><br><span class="line">                            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                            <span class="comment">// 构造ToSend消息</span></span><br><span class="line">                          	ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                                    v.getId(),</span><br><span class="line">                                    v.getZxid(),</span><br><span class="line">                                    logicalclock.get(),</span><br><span class="line">                                    self.getPeerState(),</span><br><span class="line">                                    response.sid,</span><br><span class="line">                                    v.getPeerEpoch(),</span><br><span class="line">                                    qv.toString().getBytes());</span><br><span class="line">                          	<span class="comment">// 放入sendqueue队列，等待发送</span></span><br><span class="line">                            sendqueue.offer(notmsg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * If this server is not looking, but the one that sent the ack</span></span><br><span class="line"><span class="comment">                         * is looking, then send back what it believes to be the leader.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        Vote current = self.getCurrentVote();</span><br><span class="line">                        <span class="keyword">if</span>(ackstate == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                                LOG.debug(<span class="string">"Sending new notification. My id =&#123;&#125; recipient=&#123;&#125; zxid=0x&#123;&#125; leader=&#123;&#125; config version = &#123;&#125;"</span>,</span><br><span class="line">                                        self.getId(),</span><br><span class="line">                                        response.sid,</span><br><span class="line">                                        Long.toHexString(current.getZxid()),</span><br><span class="line">                                        current.getId(),</span><br><span class="line">                                        Long.toHexString(self.getQuorumVerifier().getVersion()));</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                            ToSend notmsg = <span class="keyword">new</span> ToSend(</span><br><span class="line">                                    ToSend.mType.notification,</span><br><span class="line">                                    current.getId(),</span><br><span class="line">                                    current.getZxid(),</span><br><span class="line">                                    current.getElectionEpoch(),</span><br><span class="line">                                    self.getPeerState(),</span><br><span class="line">                                    response.sid,</span><br><span class="line">                                    current.getPeerEpoch(),</span><br><span class="line">                                    qv.toString().getBytes());</span><br><span class="line">                            sendqueue.offer(notmsg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Interrupted Exception while waiting for new message"</span> +</span><br><span class="line">                        e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"WorkerReceiver is down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerReceiver实现了Runnable接口，是选票接收器。其会不断地从QuorumCnxManager中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。其是将QuorumCnxManager的Message转化为FastLeaderElection的Notification。</p>
<p>其中，WorkerReceiver的主要逻辑在run方法中，其首先会从QuorumCnxManager中的recvQueue队列中取出其他服务器发来的选举消息，消息封装在Message数据结构中。然后判断消息中的服务器id是否包含在可以投票的服务器集合中，若不是，则会将本服务器的内部投票发送给该服务器，其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it is from a non-voting server (such as an observer or</span></span><br><span class="line"><span class="comment"> * a non-voting follower), respond right away.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(!validVoter(response.sid)) &#123;</span><br><span class="line">  	<span class="comment">// 获取自己的投票</span></span><br><span class="line">    Vote current = self.getCurrentVote();</span><br><span class="line">    QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">  	<span class="comment">// 构造ToSend消息</span></span><br><span class="line">    ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">            current.getId(),</span><br><span class="line">            current.getZxid(),</span><br><span class="line">            logicalclock.get(),</span><br><span class="line">            self.getPeerState(),</span><br><span class="line">            response.sid,</span><br><span class="line">            current.getPeerEpoch(),</span><br><span class="line">            qv.toString().getBytes());</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 放入sendqueue队列，等待发送</span></span><br><span class="line">    sendqueue.offer(notmsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若包含该服务器，则根据消息（Message）解析出投票服务器的投票信息并将其封装为Notification，然后判断当前服务器是否为LOOKING，若为LOOKING，则直接将Notification放入FastLeaderElection的recvqueue（区别于recvQueue）中。然后判断投票服务器是否为LOOKING状态，并且其选举周期小于当前服务器的逻辑时钟，则将本（当前）服务器的内部投票发送给该服务器，否则，直接忽略掉该投票。其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this server is looking, then send proposed leader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;  <span class="comment">// 本服务器为LOOKING状态</span></span><br><span class="line">    <span class="comment">// 将消息放入recvqueue中</span></span><br><span class="line">  	recvqueue.offer(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Send a notification back if the peer that sent this</span></span><br><span class="line"><span class="comment">     * message is also looking and its logical clock is</span></span><br><span class="line"><span class="comment">     * lagging behind.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>((ackstate == QuorumPeer.ServerState.LOOKING)	<span class="comment">// 推选者服务器为LOOKING状态</span></span><br><span class="line">            &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;	<span class="comment">// 选举周期小于逻辑时钟</span></span><br><span class="line">        <span class="comment">// 创建新的投票</span></span><br><span class="line">      	Vote v = getVote();</span><br><span class="line">        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">        <span class="comment">// 构造新的发送消息（本服务器自己的投票）</span></span><br><span class="line">      	ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                v.getId(),</span><br><span class="line">                v.getZxid(),</span><br><span class="line">                logicalclock.get(),</span><br><span class="line">                self.getPeerState(),</span><br><span class="line">                response.sid,</span><br><span class="line">                v.getPeerEpoch(),</span><br><span class="line">                qv.toString().getBytes());</span><br><span class="line">      	<span class="comment">// 将发送消息放置于队列，等待发送</span></span><br><span class="line">        sendqueue.offer(notmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若本服务器的状态不为LOOKING，则会根据投票服务器中解析的version信息来构造ToSend消息，放入sendqueue，等待发送，起流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 本服务器状态不为LOOKING</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this server is not looking, but the one that sent the ack</span></span><br><span class="line"><span class="comment">         * is looking, then send back what it believes to be the leader.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		  	<span class="comment">// 获取当前投票</span></span><br><span class="line">        Vote current = self.getCurrentVote();</span><br><span class="line">        <span class="keyword">if</span>(ackstate == QuorumPeer.ServerState.LOOKING)&#123;	<span class="comment">// 为LOOKING状态</span></span><br><span class="line">            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                LOG.debug(<span class="string">"Sending new notification. My id =&#123;&#125; recipient=&#123;&#125; zxid=0x&#123;&#125; leader=&#123;&#125; config version = &#123;&#125;"</span>,</span><br><span class="line">                        self.getId(),</span><br><span class="line">                        response.sid,</span><br><span class="line">                        Long.toHexString(current.getZxid()),</span><br><span class="line">                        current.getId(),</span><br><span class="line">                        Long.toHexString(self.getQuorumVerifier().getVersion()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">          	<span class="comment">// 构造ToSend消息</span></span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(</span><br><span class="line">                    ToSend.mType.notification,</span><br><span class="line">                    current.getId(),</span><br><span class="line">                    current.getZxid(),</span><br><span class="line">                    current.getElectionEpoch(),</span><br><span class="line">                    self.getPeerState(),</span><br><span class="line">                    response.sid,</span><br><span class="line">                    current.getPeerEpoch(),</span><br><span class="line">                    qv.toString().getBytes());</span><br><span class="line">          	<span class="comment">// 将发送消息放置于队列，等待发送</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WorkerSender"><a href="#WorkerSender" class="headerlink" title="WorkerSender"></a>WorkerSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This worker simply dequeues a message to send and</span></span><br><span class="line"><span class="comment"> * and queues it on the manager's queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerSender</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">    QuorumCnxManager manager;</span><br><span class="line"></span><br><span class="line">    WorkerSender(QuorumCnxManager manager)&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"WorkerSender"</span>);</span><br><span class="line">        <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ToSend m = sendqueue.poll(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span>(m == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                process(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">"WorkerSender is down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by run() once there is a new message to send.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m     message to send</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ToSend m)</span> </span>&#123;</span><br><span class="line">        ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),</span><br><span class="line">                                            m.leader,</span><br><span class="line">                                            m.zxid,</span><br><span class="line">                                            m.electionEpoch,</span><br><span class="line">                                            m.peerEpoch,</span><br><span class="line">                                            m.configData);</span><br><span class="line"></span><br><span class="line">        manager.toSend(m.sid, requestBuffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerSender也实现了Runnable接口，为选票发送器，其会不断地从sendqueue中获取待发送的选票，并将其传递到底层QuorumCnxManager中，其过程是将FastLeaderElection的ToSend转化为QuorumCnxManager的Message。</p>
<h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数　"></a>类的构造函数　</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastLeaderElection</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    starter(self, manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中初始化了stop字段和manager字段，并且调用了starter函数: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">starter</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.self = self;</span><br><span class="line">    proposedLeader = -<span class="number">1</span>;</span><br><span class="line">    proposedZxid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sendqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">    recvqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">    <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger(manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心函数分析"><a href="#核心函数分析" class="headerlink" title="核心函数分析"></a>核心函数分析</h3><h4 id="sendNotifications函数"><a href="#sendNotifications函数" class="headerlink" title="sendNotifications函数　"></a>sendNotifications函数　</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;   <span class="comment">// 遍历投票参与者集合</span></span><br><span class="line">        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">       </span><br><span class="line">	      <span class="comment">// 构造发送消息</span></span><br><span class="line">      	ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                proposedZxid,</span><br><span class="line">                logicalclock.get(),</span><br><span class="line">                QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                sid,</span><br><span class="line">                proposedEpoch, qv.toString().getBytes());</span><br><span class="line">        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">            LOG.debug(<span class="string">"Sending Notification: "</span> + proposedLeader + <span class="string">" (n.leader), 0x"</span>  +</span><br><span class="line">                  Long.toHexString(proposedZxid) + <span class="string">" (n.zxid), 0x"</span> + Long.toHexString(logicalclock.get())  +</span><br><span class="line">                  <span class="string">" (n.round), "</span> + sid + <span class="string">" (recipient), "</span> + self.getId() +</span><br><span class="line">                  <span class="string">" (myid), 0x"</span> + Long.toHexString(proposedEpoch) + <span class="string">" (n.peerEpoch)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">	      <span class="comment">// 将发送消息放置于队列</span></span><br><span class="line">        sendqueue.offer(notmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其会遍历所有的参与者投票集合，然后将自己的选票信息发送至上述所有的投票者集合，其并非同步发送，而是将ToSend消息放置于sendqueue中，之后由WorkerSender进行发送。</p>
<h4 id="totalOrderPredicate函数"><a href="#totalOrderPredicate函数" class="headerlink" title="totalOrderPredicate函数"></a>totalOrderPredicate函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if a pair (server id, zxid) succeeds our</span></span><br><span class="line"><span class="comment"> * current vote.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id    Server identifier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zxid  Last zxid observed by the issuer of this vote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line">    LOG.debug(<span class="string">"id: "</span> + newId + <span class="string">", proposed id: "</span> + curId + <span class="string">", zxid: 0x"</span> +</span><br><span class="line">            Long.toHexString(newZxid) + <span class="string">", proposed zxid: 0x"</span> + Long.toHexString(curZxid));</span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We return true if one of the following three cases hold:</span></span><br><span class="line"><span class="comment">     * 1- New epoch is higher</span></span><br><span class="line"><span class="comment">     * 2- New epoch is the same as current epoch, but new zxid is higher</span></span><br><span class="line"><span class="comment">     * 3- New epoch is the same as current epoch, new zxid is the same</span></span><br><span class="line"><span class="comment">     *  as current zxid, but server id is higher.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将接收的投票与自身投票进行PK，查看是否消息中包含的服务器id是否更优，其按照epoch、zxid、id的优先级进行PK。</p>
<h4 id="termPredicate函数"><a href="#termPredicate函数" class="headerlink" title="termPredicate函数"></a>termPredicate函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Termination predicate. Given a set of votes, determines if have</span></span><br><span class="line"><span class="comment"> * sufficient to declare the end of the election round.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> votes</span></span><br><span class="line"><span class="comment"> *            Set of votes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vote</span></span><br><span class="line"><span class="comment"> *            Identifier of the vote received last</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">termPredicate</span><span class="params">(Map&lt;Long, Vote&gt; votes, Vote vote)</span> </span>&#123;</span><br><span class="line">    SyncedLearnerTracker voteSet = <span class="keyword">new</span> SyncedLearnerTracker();</span><br><span class="line">    voteSet.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">    <span class="keyword">if</span> (self.getLastSeenQuorumVerifier() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self</span><br><span class="line">                    .getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">        voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * First make the views consistent. Sometimes peers will have different</span></span><br><span class="line"><span class="comment">     * zxids for a server depending on timing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, Vote&gt; entry : votes.entrySet()) &#123; <span class="comment">// 遍历已经接收的投票集合</span></span><br><span class="line">        <span class="keyword">if</span> (vote.equals(entry.getValue())) &#123; <span class="comment">// 将等于当前投票的项放入set</span></span><br><span class="line">            voteSet.addAck(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//统计set，查看投某个id的票数是否超过一半</span></span><br><span class="line">    <span class="keyword">return</span> voteSet.hasAllQuorums();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数用于判断Leader选举是否结束，即是否有一半以上的服务器选出了相同的Leader，其过程是将收到的选票与当前选票进行对比，选票相同的放入同一个集合，之后判断选票相同的集合是否超过了半数。</p>
<h4 id="checkLeader函数"><a href="#checkLeader函数" class="headerlink" title="checkLeader函数　　"></a>checkLeader函数　　</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * In the case there is a leader elected, and a quorum supporting</span></span><br><span class="line"><span class="comment"> * this leader, we have to check if the leader has voted and acked</span></span><br><span class="line"><span class="comment"> * that it is leading. We need this check to avoid that peers keep</span></span><br><span class="line"><span class="comment"> * electing over and over a peer that has crashed and it is no</span></span><br><span class="line"><span class="comment"> * longer leading.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> votes set of votes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   leader  leader id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   electionEpoch   epoch id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLeader</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;Long, Vote&gt; votes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> leader,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> electionEpoch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> predicate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If everyone else thinks I'm the leader, I must be the leader.</span></span><br><span class="line"><span class="comment">     * The other two checks are just for the case in which I'm not the</span></span><br><span class="line"><span class="comment">     * leader. If I'm not the leader and I haven't received a message</span></span><br><span class="line"><span class="comment">     * from leader stating that it is leading, then predicate is false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(leader != self.getId())&#123;  <span class="comment">// 自己不为leader</span></span><br><span class="line">        <span class="keyword">if</span>(votes.get(leader) == <span class="keyword">null</span>) predicate = <span class="keyword">false</span>;  <span class="comment">// 还未选出leader</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(votes.get(leader).getState() != ServerState.LEADING) predicate = <span class="keyword">false</span>; <span class="comment">// 选出的leader还未给出ack信号，其他服务器还不知道leader</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(logicalclock.get() != electionEpoch) &#123;  <span class="comment">// 逻辑时钟不等于选举周期</span></span><br><span class="line">        predicate = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> predicate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数检查是否已经完成了Leader的选举，此时Leader的状态应该是LEADING状态。</p>
<h4 id="lookForLeader函数"><a href="#lookForLeader函数" class="headerlink" title="lookForLeader函数"></a>lookForLeader函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts a new round of leader election. Whenever our QuorumPeer</span></span><br><span class="line"><span class="comment"> * changes its state to LOOKING, this method is invoked, and it</span></span><br><span class="line"><span class="comment"> * sends notifications to all other peers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 注册jmx</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">	          <span class="comment">// 更新逻辑时钟，每进行一轮选举，都需要更新逻辑时钟</span></span><br><span class="line">            logicalclock.incrementAndGet();</span><br><span class="line">	          <span class="comment">// 更新选票</span></span><br><span class="line">            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</span><br><span class="line">                <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</span><br><span class="line">        <span class="comment">// 向其他服务器发送自己的选票</span></span><br><span class="line">      	sendNotifications();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop))&#123;  <span class="comment">// 本服务器状态为LOOKING并且还未选出leader</span></span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 从recvqueue接收队列中取出投票</span></span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                    TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment">             * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(manager.haveDelivered())&#123;</span><br><span class="line">                    sendNotifications();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    manager.connectAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Exponential backoff</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</span><br><span class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</span><br><span class="line">                        tmpTimeOut : maxNotificationInterval);</span><br><span class="line">                LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123; <span class="comment">// 投票者集合中包含接收到消息中的服务器id</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Only proceed if the vote comes from a replica in the current or next</span></span><br><span class="line"><span class="comment">                 * voting view for a replica in the current or next voting view.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">                <span class="keyword">case</span> LOOKING:</span><br><span class="line">                    <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                    <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;  <span class="comment">// 其选举周期大于逻辑时钟</span></span><br><span class="line">                        <span class="comment">// 重新赋值逻辑时钟</span></span><br><span class="line">                        logicalclock.set(n.electionEpoch);</span><br><span class="line">                        recvset.clear();</span><br><span class="line">                        <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123; <span class="comment">// 选出较优的服务器</span></span><br><span class="line">                          	<span class="comment">// 更新选票  </span></span><br><span class="line">                          	updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无法选出较优的服务器</span></span><br><span class="line">                            updateProposal(getInitId(),</span><br><span class="line">                                    getInitLastLoggedZxid(),</span><br><span class="line">                                    getPeerEpoch());</span><br><span class="line">                        &#125;</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123; <span class="comment">// 选举周期小于逻辑时钟，不做处理</span></span><br><span class="line">                        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                            LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></span><br><span class="line">                                    + Long.toHexString(n.electionEpoch)</span><br><span class="line">                                    + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                            proposedLeader, proposedZxid, proposedEpoch)) &#123; <span class="comment">// 等于，并且能选出较优的服务器</span></span><br><span class="line">                        <span class="comment">// 更新选票</span></span><br><span class="line">                      	updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                      	<span class="comment">// 发送消息</span></span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                        LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</span><br><span class="line">                                <span class="string">", proposed leader="</span> + n.leader +</span><br><span class="line">                                <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</span><br><span class="line">                                <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// don't care about the version if it's in LOOKING state</span></span><br><span class="line">                    <span class="comment">// recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票</span></span><br><span class="line">                    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (termPredicate(recvset,</span><br><span class="line">                            <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                    logicalclock.get(), proposedEpoch))) &#123; <span class="comment">// 若能选出leader</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">                        <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                    proposedLeader, proposedZxid, proposedEpoch))&#123;</span><br><span class="line">                                recvqueue.put(n);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * This predicate is true once we don't read any new</span></span><br><span class="line"><span class="comment">                         * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</span><br><span class="line">                                    proposedZxid, logicalclock.get(), </span><br><span class="line">                                    proposedEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                    LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">case</span> LEADING:</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Consider all notifications from the same epoch</span></span><br><span class="line"><span class="comment">                     * together.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123; <span class="comment">// 与逻辑时钟相等</span></span><br><span class="line">                      	<span class="comment">// 将该服务器和选票信息放入recvset中</span></span><br><span class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                        <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.version, n.leader,</span><br><span class="line">                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                                        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123; <span class="comment">// 判断是否完成了leader选举</span></span><br><span class="line">                            <span class="comment">// 设置本服务器的状态</span></span><br><span class="line">                          	self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                            <span class="comment">// 创建投票信息</span></span><br><span class="line">                          	Vote endVote = <span class="keyword">new</span> Vote(n.leader, </span><br><span class="line">                                    n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Before joining an established ensemble, verify that</span></span><br><span class="line"><span class="comment">                     * a majority are following the same leader.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader, </span><br><span class="line">                            n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                    <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.version, n.leader,</span><br><span class="line">                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, </span><br><span class="line">                                n.electionEpoch, n.peerEpoch);</span><br><span class="line">                        leaveInstance(endVote);</span><br><span class="line">                        <span class="keyword">return</span> endVote;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</span><br><span class="line">                          + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 卸载注册的jmx</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数用于开始新一轮的Leader选举，其首先会将逻辑时钟自增，然后更新本服务器的选票信息（初始化选票），之后将选票信息放入sendqueue等待发送给其他服务器，其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    logicalclock.incrementAndGet();</span><br><span class="line">    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</span><br><span class="line">        <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</span><br><span class="line">sendNotifications();</span><br></pre></td></tr></table></figure>

<p>之后每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，就立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票，其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从recvqueue接收队列中取出投票</span></span><br><span class="line">Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">        TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment"> * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123; <span class="comment">// 无法获取选票</span></span><br><span class="line">    <span class="keyword">if</span>(manager.haveDelivered())&#123; <span class="comment">// manager已经发送了所有选票消息（表示有连接）</span></span><br><span class="line">      <span class="comment">// 向所有其他服务器发送消息  </span></span><br><span class="line">      sendNotifications();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还未发送所有消息（表示无连接）</span></span><br><span class="line">      	<span class="comment">// 连接其他每个服务器</span></span><br><span class="line">        manager.connectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Exponential backoff</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</span><br><span class="line">    notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</span><br><span class="line">            tmpTimeOut : maxNotificationInterval);</span><br><span class="line">    LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。　　</p>
<ul>
<li><strong>外部投票的选举轮次大于内部投票</strong>。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。</li>
<li><strong>外部投票的选举轮次小于内部投票</strong>。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理。</li>
<li><strong>外部投票的选举轮次等于内部投票</strong>。此时可以开始进行选票PK，如果消息中的选票更优，则需要更新本服务器内部选票，再发送给其他服务器。</li>
</ul>
<p>之后再对选票进行归档操作，无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档，其中recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票，然后开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，然后再进行最后一次确认，判断是否又有更优的选票产生，若无，则终止投票，然后最终的选票，其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line"><span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;  <span class="comment">// 其选举周期大于逻辑时钟</span></span><br><span class="line">    <span class="comment">// 重新赋值逻辑时钟</span></span><br><span class="line">  	logicalclock.set(n.electionEpoch);</span><br><span class="line">    <span class="comment">// 清空所有接收到的所有选票</span></span><br><span class="line">  	recvset.clear();</span><br><span class="line">    <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">            getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;  <span class="comment">// 进行PK，选出较优的服务</span></span><br><span class="line">        <span class="comment">// 更新选票</span></span><br><span class="line">      	updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 无法选出较优的服务器</span></span><br><span class="line">        <span class="comment">// 更新选票</span></span><br><span class="line">      	updateProposal(getInitId(),</span><br><span class="line">                getInitLastLoggedZxid(),</span><br><span class="line">                getPeerEpoch());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 发送本服务器的内部选票消息</span></span><br><span class="line">    sendNotifications();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;	<span class="comment">// 选举周期小于逻辑时钟，不做处理，直接忽略</span></span><br><span class="line">    <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">        LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></span><br><span class="line">                + Long.toHexString(n.electionEpoch)</span><br><span class="line">                + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">        proposedLeader, proposedZxid, proposedEpoch)) &#123; <span class="comment">// PK，选出较优的服务器</span></span><br><span class="line">    <span class="comment">// 更新选票</span></span><br><span class="line">  	updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">  	sendNotifications();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">    LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</span><br><span class="line">            <span class="string">", proposed leader="</span> + n.leader +</span><br><span class="line">            <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</span><br><span class="line">            <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't care about the version if it's in LOOKING state</span></span><br><span class="line"><span class="comment">// recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票</span></span><br><span class="line">recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (termPredicate(recvset,</span><br><span class="line">        <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</span><br><span class="line">                logicalclock.get(), proposedEpoch))) &#123; <span class="comment">// 若能选出leader</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">    <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</span><br><span class="line">            TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123; <span class="comment">// 遍历已经接收的投票集合</span></span><br><span class="line">        <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                proposedLeader, proposedZxid, proposedEpoch))&#123; <span class="comment">// 选票有变更，比之前提议的Leader有更好的选票加入</span></span><br><span class="line">          	<span class="comment">// 将更优的选票放在recvset中</span></span><br><span class="line">            recvqueue.put(n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This predicate is true once we don't read any new</span></span><br><span class="line"><span class="comment">     * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123; <span class="comment">// 表示之前提议的Leader已经是最优的</span></span><br><span class="line">      	<span class="comment">// 设置服务器状态</span></span><br><span class="line">        self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                ServerState.LEADING: learningState());</span><br><span class="line">      	<span class="comment">// 最终的选票</span></span><br><span class="line">        Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</span><br><span class="line">                proposedZxid, logicalclock.get(), </span><br><span class="line">                proposedEpoch);</span><br><span class="line">      	<span class="comment">// 清空recvqueue队列的选票</span></span><br><span class="line">        leaveInstance(endVote);</span><br><span class="line">      	<span class="comment">// 返回选票</span></span><br><span class="line">        <span class="keyword">return</span> endVote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若选票中的服务器状态为FOLLOWING或者LEADING时，其大致步骤会判断选举周期是否等于逻辑时钟，归档选票，是否已经完成了Leader选举，设置服务器状态，修改逻辑时钟等于选举周期，返回最终选票，其流程如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;  <span class="comment">// 与逻辑时钟相等</span></span><br><span class="line">	  <span class="comment">// 将该服务器和选票信息放入recvset中</span></span><br><span class="line">    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">    <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.version, n.leader,</span><br><span class="line">                    n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                    &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;  <span class="comment">// 已经完成了leader选举</span></span><br><span class="line">      	<span class="comment">// 设置本服务器的状态</span></span><br><span class="line">        self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                ServerState.LEADING: learningState());</span><br><span class="line">	      <span class="comment">// 最终的选票</span></span><br><span class="line">        Vote endVote = <span class="keyword">new</span> Vote(n.leader, </span><br><span class="line">                n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">      	<span class="comment">// 清空recvqueue队列的选票</span></span><br><span class="line">        leaveInstance(endVote);</span><br><span class="line">        <span class="keyword">return</span> endVote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Before joining an established ensemble, verify that</span></span><br><span class="line"><span class="comment"> * a majority are following the same leader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader, </span><br><span class="line">        n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line"><span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.version, n.leader,</span><br><span class="line">        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;	<span class="comment">// 已经完成了leader选举</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">      	<span class="comment">// 设置逻辑时钟</span></span><br><span class="line">        logicalclock.set(n.electionEpoch);</span><br><span class="line">      	<span class="comment">// 设置状态</span></span><br><span class="line">        self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                ServerState.LEADING: learningState());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 最终选票</span></span><br><span class="line">    Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, </span><br><span class="line">            n.electionEpoch, n.peerEpoch);</span><br><span class="line">  	<span class="comment">// 清空recvqueue队列的选票</span></span><br><span class="line">    leaveInstance(endVote);</span><br><span class="line">  	<span class="comment">// 返回选票</span></span><br><span class="line">    <span class="keyword">return</span> endVote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Zookeeper目录: <a href="https://www.cnblogs.com/leesf456/p/6239578.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/6239578.html</a></li>
<li>Zookeeper源码分析目录: <a href="https://www.cnblogs.com/leesf456/p/6518040.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/6518040.html</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/zookeeper/" rel="tag"># zookeeper</a>
          
            <a href="/tags/Leader选举/" rel="tag"># Leader选举</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/08/10/gejianxiong-xingwanlilu/" rel="next" title="行万里路:葛剑雄旅行">
                <i class="fa fa-chevron-left"></i> 行万里路:葛剑雄旅行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/08/16/zookeeper-system-model/" rel="prev" title="zookeeper系统模型">
                zookeeper系统模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sainpo.yxb</p>
  <div class="site-description motion-element" itemprop="description">码农|理工男|文青</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/mewishu" title="GitHub &rarr; https://github.com/mewishu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xbyan88@163.com" title="E-Mail &rarr; mailto:xbyan88@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper选举概述"><span class="nav-text">Zookeeper选举概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时机"><span class="nav-text">时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-text">过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader选举算法分析"><span class="nav-text">Leader选举算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一次投票"><span class="nav-text">第一次投票</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变更投票"><span class="nav-text">变更投票</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定Leader"><span class="nav-text">确定Leader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader选举实现细节"><span class="nav-text">Leader选举实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器状态"><span class="nav-text">服务器状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#投票数据结构"><span class="nav-text">投票数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QuorumCnxManager：网络I-O"><span class="nav-text">QuorumCnxManager：网络I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列"><span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立连接"><span class="nav-text">建立连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息接收与发送"><span class="nav-text">消息接收与发送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FastLeaderElection：选举算法核心"><span class="nav-text">FastLeaderElection：选举算法核心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#选票管理"><span class="nav-text">选票管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法核心"><span class="nav-text">算法核心</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FastLeaderElection源码分析"><span class="nav-text">FastLeaderElection源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承关系"><span class="nav-text">类的继承关系　</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的内部类"><span class="nav-text">类的内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Notification类"><span class="nav-text">Notification类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ToSend类"><span class="nav-text">ToSend类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Messenger类"><span class="nav-text">Messenger类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WorkerReceiver"><span class="nav-text">WorkerReceiver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WorkerSender"><span class="nav-text">WorkerSender</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的构造函数"><span class="nav-text">类的构造函数　</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心函数分析"><span class="nav-text">核心函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sendNotifications函数"><span class="nav-text">sendNotifications函数　</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#totalOrderPredicate函数"><span class="nav-text">totalOrderPredicate函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#termPredicate函数"><span class="nav-text">termPredicate函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#checkLeader函数"><span class="nav-text">checkLeader函数　　</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lookForLeader函数"><span class="nav-text">lookForLeader函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sainpo.yxb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">146k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/reading_progress/reading_progress.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>



  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.3.0"></script>








<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>





    
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">
<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '96bfad82ea05d6d64ea7',
    clientSecret: '74d6d9a9834e4e6c3db88d702866ae41f675f888',
    repo: 'usercomment',
    owner: 'mewishu',
    admin: ['mewishu'],
    id: md5(location.pathname),
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>


</body>
</html>
