<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="数据模型Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树。  在Zookeeper中，事务是指能够改变Zookeeper服务器状态的操作，一般包括节点创建与删除，数据节点内容更新和客户端会话创建与失效，对于每个事务请求，Zookeeper都会为其分配一个全局唯一的事">
<meta name="keywords" content="zookeeper">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper系统模型">
<meta property="og:url" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/index.html">
<meta property="og:site_name" content="窦小固的小木屋">
<meta property="og:description" content="数据模型Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树。  在Zookeeper中，事务是指能够改变Zookeeper服务器状态的操作，一般包括节点创建与删除，数据节点内容更新和客户端会话创建与失效，对于每个事务请求，Zookeeper都会为其分配一个全局唯一的事">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/616953-20161117093506826-316952237.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/616953-20161122094930487-367521759.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/616953-20170115160511635-533910072.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/img003.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/img002.png">
<meta property="og:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/zk-acl-schema-with-id.png">
<meta property="og:updated_time" content="2019-08-16T10:55:28.175Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zookeeper系统模型">
<meta name="twitter:description" content="数据模型Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树。  在Zookeeper中，事务是指能够改变Zookeeper服务器状态的操作，一般包括节点创建与删除，数据节点内容更新和客户端会话创建与失效，对于每个事务请求，Zookeeper都会为其分配一个全局唯一的事">
<meta name="twitter:image" content="http://www.sainpo.top/2019/08/16/zookeeper-system-model/616953-20161117093506826-316952237.png">
  <link rel="canonical" href="http://www.sainpo.top/2019/08/16/zookeeper-system-model/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>zookeeper系统模型 | 窦小固的小木屋</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">窦小固的小木屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">西河书生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    <div class="reading-progress-bar"></div>

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/16/zookeeper-system-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">zookeeper系统模型

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-16 11:45:54 / 修改时间：18:55:28" itemprop="dateCreated datePublished" datetime="2019-08-16T11:45:54+08:00">2019-08-16</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/" itemprop="url" rel="index"><span itemprop="name">分布式一致性</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon"
              >
                <i class="fa fa-eye"></i>
                 阅读次数： 
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">26k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">23 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Zookeeper的数据节点称为ZNode，ZNode是Zookeeper中数据的最小单元，每个ZNode都可以保存数据，同时还可以挂载子节点，因此构成了一个层次化的命名空间，称为树。</p>
<p><img src="/2019/08/16/zookeeper-system-model/616953-20161117093506826-316952237.png" alt="zookeeper数据模型"></p>
<p>在Zookeeper中，事务是指能够改变Zookeeper服务器状态的操作，一般包括节点创建与删除，数据节点内容更新和客户端会话创建与失效，对于每个事务请求，Zookeeper都会为其分配一个全局唯一的事务ID，用 <code>zxid</code>表示，通常是64位的数字，每个 <code>zxid</code>对应一次更新操作，从这些ZXID中可以间接地识别出Zookeeper处理这些更新操作请求的全局顺序。</p>
<h2 id="节点特性"><a href="#节点特性" class="headerlink" title="节点特性"></a>节点特性</h2><p>在Zookeeper中，每个数据节点都是由生命周期的，类型不同则会不同的生命周期，节点类型可以分为<strong>持久节点（PERSISTENT）、临时节点（EPHEMERAL）、顺序节点（SEQUENTIAL）</strong>三大类，可以通过组合生成如下四种类型节点</p>
<ol>
<li><strong>持久节点</strong>（PERSISTENT）: 节点创建后便一直存在于Zookeeper服务器上，直到有删除操作来主动清除该节点。</li>
<li><strong>持久顺序节点</strong>（PERSISTENT_SEQUENTIAL）: 相比持久节点，其新增了顺序特性，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。在创建节点时，会自动添加一个数字后缀，作为新的节点名，该数字后缀的上限是整形的最大值。</li>
<li><strong>临时节点</strong>（EPEMERAL）: 临时节点的生命周期与客户端会话绑定，客户端失效，节点会被自动清理。同时，Zookeeper规定不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。</li>
<li><strong>临时顺序节点</strong>（EPEMERAL_SEQUENTIAL）: 在临时节点的基础添加了顺序特性。</li>
</ol>
<p>每个节点除了存储数据外，还存储了节点本身的一些状态信息，可通过get命令获取。</p>
<h2 id="版本–保证分布式数据原子性操作"><a href="#版本–保证分布式数据原子性操作" class="headerlink" title="版本–保证分布式数据原子性操作"></a>版本–保证分布式数据原子性操作</h2><p>每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p>
<p>每个 ZNode 都有 3 类版本信息：</p>
<ul>
<li>version：当前数据节点数据内容的版本号</li>
<li>cversion：子节点列表，当前数据子节点的版本号，只会感知<code>子节点列表</code>变更信息，新增子节点、删除子节点，而不会感知子节点数据内容的变更</li>
<li>aversion：当前数据节点ACL变更版本号</li>
</ul>
<p>上述各版本号都是表示修改次数，如version为1表示对数据节点的内容变更了一次。即使前后两次变更并没有改变数据内容，version的值仍然会改变。version可以用于写入验证，类似于CAS。</p>
<h3 id="版本号，什么作用？"><a href="#版本号，什么作用？" class="headerlink" title="版本号，什么作用？"></a>版本号，什么作用？</h3><p>目标：解决 ZNode 的<code>并发更新</code>问题，实现 CAS（Compare And Switch）乐观锁。</p>
<p>补充：乐观锁事务，分为 3 个典型阶段：</p>
<ol>
<li>数据读取</li>
<li>写入校验</li>
<li>数据写入</li>
</ol>
<h2 id="Watcher–数据变更通知"><a href="#Watcher–数据变更通知" class="headerlink" title="Watcher–数据变更通知"></a>Watcher–数据变更通知</h2><p>Zookeeper使用Watcher机制实现分布式数据的发布/订阅功能。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ZooKeeper 允许客户端向服务端注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p>
<p>ZooKeeper 的 Watcher 机制主要包括客户端线程、客户端 WatchManager 和 ZooKeeper 服务器三部分。在具体工作流程上，简单地讲，客户端在向 ZooKeeper 服务器注册 Watcher 的同时，会将 Watcher 对象存储在客户端的 WatchManager 中。当 ZooKeeper 服务器端触发 Watcher 事件后，会向客户端发送通知，客户端线程从 WatchManager 中取出对应的 Watcher 对象来执行回调逻辑。如下面WatchManager所示，WatchManager 创建了一个 HashMap，这个 HashMap 被用来存放 Watcher 对象。</p>
<p>WatchManager 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWatch</span><span class="params">(String path, Watcher watcher)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Watcher&gt; list = watchTable.get(path);</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// don't waste memory if there are few watches on a node</span></span><br><span class="line">        <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></span><br><span class="line">        <span class="comment">// seems like a good compromise</span></span><br><span class="line">        list = <span class="keyword">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>);</span><br><span class="line">        watchTable.put(path, list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(watcher);</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; paths = watch2Paths.get(watcher);</span><br><span class="line">    <span class="keyword">if</span> (paths == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cnxns typically have many watches, so use default cap here</span></span><br><span class="line">        paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        watch2Paths.put(watcher, paths);</span><br><span class="line">    &#125;</span><br><span class="line">    paths.add(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 Watcher 注册和通知流程如下图所示: </p>
<p><img src="/2019/08/16/zookeeper-system-model/616953-20161122094930487-367521759.png" alt="Watcher机制概述"></p>
<h3 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a>总体框图</h3><p><img src="/2019/08/16/zookeeper-system-model/616953-20170115160511635-533910072.png" alt="Zookeeper watcher机制总体框图"></p>
<p>说明：</p>
<p>Watcher，接口类型，其定义了process方法，需子类实现。</p>
<p>Event，接口类型，Watcher的内部类，无任何方法。</p>
<p>KeeperState，枚举类型，Event的内部类，表示Zookeeper所处的状态。</p>
<p>EventType，枚举类型，Event的内部类，表示Zookeeper中发生的事件类型。</p>
<p>WatchedEvent，表示对ZooKeeper上发生变化后的反馈，包含了KeeperState和EventType。</p>
<p>ClientWatchManager，接口类型，表示客户端的Watcher管理者，其定义了materialized方法，需子类实现。</p>
<p>ZKWatchManager，Zookeeper的内部类，继承ClientWatchManager。</p>
<p>MyWatcher，ZooKeeperMain的内部类，继承Watcher。</p>
<p>ServerCnxn，接口类型，继承Watcher，表示客户端与服务端的一个连接。</p>
<p>WatchManager，管理Watcher。</p>
<h3 id="Watcher-接口"><a href="#Watcher-接口" class="headerlink" title="Watcher 接口"></a>Watcher 接口</h3><p>Watcher 的理念是启动一个客户端去接收从 ZooKeeper 服务端发过来的消息并且同步地处理这些信息。ZooKeeper 的 Java API 提供了公共接口 Watcher，具体操作类通过实现这个接口相关的方法来实现从所连接的 ZooKeeper 服务端接收数据。如果要处理这个消息，需要为客户端注册一个 CallBack（回调）对象。Watcher 接口定义在 org.apache.zookeeper 包里面，如下所示: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Event、WatchType定义</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Enumeration of states the ZooKeeper may be at the event</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> KeeperState &#123;</span><br><span class="line">            <span class="comment">/** Unused, this state is never generated by the server */</span></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            Unknown (-<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** The client is in the disconnected state - it is not connected</span></span><br><span class="line"><span class="comment">             * to any server in the ensemble. */</span></span><br><span class="line">            Disconnected (<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** Unused, this state is never generated by the server */</span></span><br><span class="line">            <span class="meta">@Deprecated</span></span><br><span class="line">            NoSyncConnected (<span class="number">1</span>),</span><br><span class="line">						</span><br><span class="line">          	... </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Enumeration of types of events that may occur on the ZooKeeper</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">            None (-<span class="number">1</span>),</span><br><span class="line">            NodeCreated (<span class="number">1</span>),</span><br><span class="line">            NodeDeleted (<span class="number">2</span>),</span><br><span class="line">            NodeDataChanged (<span class="number">3</span>),</span><br><span class="line">            NodeChildrenChanged (<span class="number">4</span>),</span><br><span class="line">            DataWatchRemoved (<span class="number">5</span>),</span><br><span class="line">            ChildWatchRemoved (<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intValue;     <span class="comment">// Integer representation of value</span></span><br><span class="line">                                            <span class="comment">// for sending over wire</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Watcher 接口里面，除了回调函数 process 以外，还包含 KeeperState 和 EventType 两个枚举类，分别代表了通知状态和事件类型，如下图所示。</p>
<p><img src="/2019/08/16/zookeeper-system-model/img003.png" alt="Watcher通知状态和事件类型表"></p>
<p>process 方法是 Watcher 接口中的一个回调方法，当 ZooKeeper 向客户端发送一个 Watcher 事件通知时，客户端就会对相应的 process 方法进行回调，从而实现对事件的处理。</p>
<p>process 方法包含 WatcherEvent 类型的参数，WatchedEvent 包含了每一个事件的三个基本属性：通知状态（KeeperState）、事件类型（EventType）和节点路径（Path），ZooKeeper 使用 WatchedEvent 对象来封装服务端事件并传递给 Watcher，从而方便回调方法 process 对服务端事件进行处理。</p>
<p>WatchedEvent 和 WatcherEvent 都表示的是同一个事物，都是对一个服务端事件的封装。不同的是，WatchedEvent 是一个逻辑事件，用于服务端和客户端程序执行过程中所需的逻辑对象，而 WatcherEvent 因为实现了序列化接口，因此可以用于网络传输。</p>
<p>服务端在线程 WatchedEvent 事件之后，会调用 getWrapper 方法将自己包装成一个可序列化的 WatcherEvent 事件，如清单 7 所示，以便通过网络传输到客户端。客户端在接收到服务端的这个事件对象后，首先会将 WatcherEvent 事件还原成一个 WatchedEvent 事件，并传递给 process 方法处理，回调方法 process 根据入参就能够解析出完整的服务端事件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchedEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> KeeperState keeperState;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> EventType eventType;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a WatchedEvent with specified type, state and path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchedEvent</span><span class="params">(EventType eventType, KeeperState keeperState, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keeperState = keeperState;</span><br><span class="line">        <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 可序列化的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WatcherEvent <span class="title">getWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WatcherEvent(eventType.getIntValue(), </span><br><span class="line">                                keeperState.getIntValue(), </span><br><span class="line">                                path);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端注册-Watcher-流程"><a href="#客户端注册-Watcher-流程" class="headerlink" title="客户端注册 Watcher 流程"></a>客户端注册 Watcher 流程</h3><p>创建一个Zookeeper客户端对象实例时，可以向构造方法中传入一个默认的Watcher(如: zk = new ZooKeeper(HostPort,2000,connectionWatcher)): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(connectString, sessionTimeout, watcher, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个参数是连接到 ZooKeeper 服务端的 connectionWatcher 事件监听，这个 Watcher 将作为整个 ZooKeeper 会话期间的默认 Watcher，会一直被保存在客户端 ZKWatchManager 的 defaultWatcher 里面。</p>
<p>这里我们以getData这个接口为例来说明。getData接口用于获取指定节点的数据内容: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br><span class="line">        <span class="keyword">throws</span> KeeperException, InterruptedException</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">final</span> String clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> DataWatchRegistration(watcher, clientPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.getData);</span><br><span class="line">        GetDataRequest request = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        <span class="comment">// 对当前客户端请求进行标记，将其设置为使用 Watcher 监听</span></span><br><span class="line">        request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">        GetDataResponse response = <span class="keyword">new</span> GetDataResponse();</span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataTree.copyStat(response.getStat(), stat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.getData();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端的请求基本都是在 ClientCnxn 里面进行操作，当收到请求后，客户端会对当前客户端请求进行标记，将其设置为使用 Watcher 监听，同时会封装一个 Watcher 的注册信息 WatchRegistration 对象，用于暂时保存数据节点的路径和 Watcher 的对应关系。</p>
<p>在 ZooKeeper 中，Packet 是一个最小的通信协议单元，即数据包。Pakcet 用于进行客户端与服务端之间的网络传输，任何需要传输的对象都需要包装成一个 Packet 对象。在 ClientCnxn 中 WatchRegistration 也会被封装到 Pakcet 中，然后由 SendThread 线程调用 queuePacke 方法把 Packet 放入发送队列中等待客户端发送，这又是一个异步过程，分布式系统采用异步通信是一个普遍认同的观念。随后，SendThread 线程会通过 readResponse 方法接收来自服务端的响应，异步地调用 finishPacket 方法从 Packet 中取出对应的 Watcher 并注册到 ZKWatchManager 中去: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> err = p.replyHeader.getErr();</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(err);</span><br><span class="line">        &#125;</span><br><span class="line">        ... </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                p.finished = <span class="keyword">true</span>;</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>除了上面介绍的方式以外，ZooKeeper 客户端也可以通过 getData、getChildren 和 exist 三个接口来向 ZooKeeper 服务器注册 Watcher，无论使用哪种方式，注册 Watcher 的工作原理是一致的。如下所示，getChildren 方法调用了 WatchManager 类的 addWatch 方法添加了 watcher 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            Stat stat)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String clientPath = path;</span><br><span class="line">        PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wcb = <span class="keyword">new</span> ChildWatchRegistration(watcher, clientPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.getChildren2);</span><br><span class="line">        GetChildren2Request request = <span class="keyword">new</span> GetChildren2Request();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">        GetChildren2Response response = <span class="keyword">new</span> GetChildren2Response();</span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                    clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DataTree.copyStat(response.getStat(), stat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.getChildren();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如下代码所示，现在需要从这个封装对象中再次提取出 Watcher 对象来，在 register 方法里面，客户端将 Watcher 对象转交给 ZKWatchManager，并最终保存在一个 Map 类型的数据结构 dataWatches 里面，用于将数据节点的路径和 Watcher 对象进行一一映射后管理起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</span><br><span class="line">                Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">                <span class="keyword">synchronized</span>(watches) &#123;</span><br><span class="line">                    Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">                    <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                        watches.put(clientPath, watchers);</span><br><span class="line">                    &#125;</span><br><span class="line">                    watchers.add(watcher);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>注意，WatcherRegistation 除了 Header 和 request 两个属性被传递到了服务端，其他都没有到服务端，否则服务端就容易出现内存紧张甚至溢出的危险，因为数据量太大了。这就是 ZooKeeper 为什么适用于分布式环境的原因，它在网络中传输的是消息，而不是数据包实体。</p>
<h3 id="服务端处理-Watcher-流程"><a href="#服务端处理-Watcher-流程" class="headerlink" title="服务端处理 Watcher 流程"></a>服务端处理 Watcher 流程</h3><p><img src="/2019/08/16/zookeeper-system-model/img002.png" alt="服务端处理 Watcher 序列图"></p>
<p>注意，以下所有代码均为精简版，去除了日志、判断分支，只在源码上保留了主线代码。</p>
<p>FinalRequestProcessor 类接收到客户端请求后，会调用 processRequest 方法进行处理，会进一步转向 ZooKeeperServer 的 processRequest 进行进一步处理，处理结由 ZKDatabase 类返回: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalRequestProcessor</span> <span class="keyword">implements</span> <span class="title">RequestProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FinalRequestProcessor.class);</span><br><span class="line"></span><br><span class="line">    ZooKeeperServer zks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">				...</span><br><span class="line">        ProcessTxnResult rc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (zks.outstandingChanges) &#123;</span><br><span class="line">            <span class="comment">// Need to process local session requests</span></span><br><span class="line">            rc = zks.processTxn(request);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperServer</span> <span class="keyword">implements</span> <span class="title">SessionExpirer</span>, <span class="title">ServerStats</span>.<span class="title">Provider</span> </span>&#123;</span><br><span class="line">  	... </span><br><span class="line">		<span class="function"><span class="keyword">private</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(Request request, TxnHeader hdr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Record txn)</span> </span>&#123;</span><br><span class="line">        ProcessTxnResult rc;</span><br><span class="line">        <span class="keyword">int</span> opCode = request != <span class="keyword">null</span> ? request.type : hdr.getType();</span><br><span class="line">        <span class="keyword">long</span> sessionId = request != <span class="keyword">null</span> ? request.sessionId : hdr.getClientId();</span><br><span class="line">        <span class="keyword">if</span> (hdr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rc = getZKDatabase().processTxn(hdr, txn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rc = <span class="keyword">new</span> ProcessTxnResult();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opCode == OpCode.createSession) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hdr != <span class="keyword">null</span> &amp;&amp; txn <span class="keyword">instanceof</span> CreateSessionTxn) &#123;</span><br><span class="line">                CreateSessionTxn cst = (CreateSessionTxn) txn;</span><br><span class="line">                sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request != <span class="keyword">null</span> &amp;&amp; request.isLocalSession()) &#123;</span><br><span class="line">                request.request.rewind();</span><br><span class="line">                <span class="keyword">int</span> timeout = request.request.getInt();</span><br><span class="line">                request.request.rewind();</span><br><span class="line">                sessionTracker.addSession(request.sessionId, timeout);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">"*****&gt;&gt;&gt;&gt;&gt; Got "</span></span><br><span class="line">                        + txn.getClass() + <span class="string">" "</span></span><br><span class="line">                        + txn.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opCode == OpCode.closeSession) &#123;</span><br><span class="line">            sessionTracker.removeSession(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ZKDatabase.class);</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * the process txn on the data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hdr the txnheader for the txn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txn the transaction that needs to be processed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of processing the transaction on this</span></span><br><span class="line"><span class="comment">     * datatree/zkdatabase</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(TxnHeader hdr, Record txn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataTree.processTxn(hdr, txn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServerCnxn存储"><a href="#ServerCnxn存储" class="headerlink" title="ServerCnxn存储"></a>ServerCnxn存储</h4><p>对于注册 Watcher 请求，FinalRequestProcessor 的 ProcessRequest 方法会判断当前请求是否需要注册 Watcher，如果为 true，就会将当前的 ServerCnxn 对象和数据节点路径传入 getData 方法中去: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OpCode.getData: &#123;</span><br><span class="line">    lastOp = <span class="string">"GETD"</span>;</span><br><span class="line">    GetDataRequest getDataRequest = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">    ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                                            getDataRequest);</span><br><span class="line">    DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().aclForNode(n),</span><br><span class="line">                                  ZooDefs.Perms.READ,</span><br><span class="line">                                  request.authInfo);</span><br><span class="line">    Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span> b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,</span><br><span class="line">                                           getDataRequest.getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">    rsp = <span class="keyword">new</span> GetDataResponse(b, stat);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ServerCnxn 是一个 ZooKeeper 客户端和服务器之间的连接接口，代表了一个客户端和服务器的连接，我们后面讲到的 process 回调方法，实际上也是从这里回调的，所以可以把 ServerCnxn 看作是一个 Watcher 对象。数据节点的节点路径和 ServerCnxn 最终会被存储在 WatchManager 的 watchTable 和 watch2Paths 中。</p>
<p>如前所述，WatchManager 负责 Watcher 事件的触发，它是一个统称，在服务端 DataTree 会托管两个 WatchManager，分别是 dataWatches 和 childWatches，分别对应数据变更 Watcher 和子节点变更 Watcher。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(WatchManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Watcher触发"><a href="#Watcher触发" class="headerlink" title="Watcher触发"></a>Watcher触发</h4><p>当发生 Create、Delete、NodeChange（数据变更）这样的事件后，DataTree 会调用相应方法去触发 WatchManager 的 triggerWatch 方法，该方法返回 ZNODE 的信息，自此进入到回调本地 process 的序列： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(DataTree.class);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(TxnHeader header, Record txn, <span class="keyword">boolean</span> isSubTxn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ProcessTxnResult rc = <span class="keyword">new</span> ProcessTxnResult();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rc.clientId = header.getClientId();</span><br><span class="line">            rc.cxid = header.getCxid();</span><br><span class="line">            rc.zxid = header.getZxid();</span><br><span class="line">            rc.type = header.getType();</span><br><span class="line">            rc.err = <span class="number">0</span>;</span><br><span class="line">            rc.multiResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (header.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> OpCode.setData:</span><br><span class="line">                    SetDataTxn setDataTxn = (SetDataTxn) txn;</span><br><span class="line">                    rc.path = setDataTxn.getPath();</span><br><span class="line">                    rc.stat = setData(setDataTxn.getPath(), setDataTxn</span><br><span class="line">                            .getData(), setDataTxn.getVersion(), header</span><br><span class="line">                            .getZxid(), header.getTime());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">    Stat s = <span class="keyword">new</span> Stat();</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span> lastdata[] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">        lastdata = n.data;</span><br><span class="line">        n.data = data;</span><br><span class="line">        n.stat.setMtime(time);</span><br><span class="line">        n.stat.setMzxid(zxid);</span><br><span class="line">        n.stat.setVersion(version);</span><br><span class="line">        n.copyStat(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now update if the path is in a quota subtree.</span></span><br><span class="line">    String lastPrefix = getMaxPrefixWithQuota(path);</span><br><span class="line">    <span class="keyword">if</span>(lastPrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</span><br><span class="line">          - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</span><br><span class="line">    &#125;</span><br><span class="line">    dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">        WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</span><br><span class="line">                KeeperState.SyncConnected, path);</span><br><span class="line">        HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            watchers = watchTable.remove(path);</span><br><span class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                            ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                            <span class="string">"No watchers for "</span> + path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">                HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">                <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    paths.remove(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w.process(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> watchers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以总结出，如果想要处理一个 Watcher，需要执行的步骤如下所示：</p>
<ol>
<li>将事件类型（EventType）、通知状态（WatchedEvent）、节点路径封装成一个 WatchedEvent 对象。</li>
<li>根据数据节点的节点路径从 watchTable 里面取出对应的 Watcher。如果没有找到 Watcher 对象，说明没有任何客户端在该数据节点上注册过 Watcher，直接退出。如果找到了 Watcher 就将其提取出来，同时会直接从 watchTable 和 watch2Paths 里删除 Watcher，即 Watcher 是一次性的，触发一次就失效了。</li>
<li>对于需要注册 Watcher 的请求，ZooKeeper 会把请求对应的 ServerCnxn 作为一个 Watcher 存储，所以这里调用的 process 方法实质上是 ServerCnxn 的对应方法，如下所示: </li>
</ol>
<p>NIOServerCnxn 类代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void process(WatchedEvent event) &#123;</span><br><span class="line">        ReplyHeader h = new ReplyHeader(-1, -1L, 0);</span><br><span class="line">        if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                     &quot;Deliver event &quot; + event + &quot; to 0x&quot;</span><br><span class="line">                                     + Long.toHexString(this.sessionId)</span><br><span class="line">                                     + &quot; through &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Convert WatchedEvent to a type that can be sent over the wire</span><br><span class="line">        WatcherEvent e = event.getWrapper();</span><br><span class="line"></span><br><span class="line">        sendResponse(h, e, &quot;notification&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码片段中，我们可以看出在请求头标记“-1”表示当前是一个通知，将 WatchedEvent 包装成 WatcherEvent 用于网络传输序列化，向客户端发送通知，真正的回调方法在客户端。</p>
<h4 id="客户端回调Watcher"><a href="#客户端回调Watcher" class="headerlink" title="客户端回调Watcher"></a>客户端回调Watcher</h4><p>客户端收到消息后，会调用 ClientCnxn 的 SendThread.readResponse 方法来进行统一处理，如清单所示。如果响应头 replyHdr 中标识的 Xid 为 02，表示是 ping，如果为-4，表示是验证包，如果是-1，表示这是一个通知类型的响应，然后进行反序列化、处理 chrootPath、还原 WatchedEvent、回调 Watcher 等步骤，其中回调 Watcher 步骤将 WacthedEvent 对象交给 EventThread 线程，在下一个轮询周期中进行 Watcher 回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastPingSentNs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClientCnxnSocket clientCnxnSocket;</span><br><span class="line">        <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstConnect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">                    incomingBuffer);</span><br><span class="line">            BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">            ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">            replyHdr.deserialize(bbia, <span class="string">"header"</span>);</span><br><span class="line">            <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// -2 is the xid for pings</span></span><br><span class="line">                <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                    LOG.debug(<span class="string">"Got ping response for sessionid: 0x"</span></span><br><span class="line">                            + Long.toHexString(sessionId)</span><br><span class="line">                            + <span class="string">" after "</span></span><br><span class="line">                            + ((System.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>)</span><br><span class="line">                            + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>SendThread 接收到服务端的通知事件后，会通过调用 EventThread 类的 queueEvent 方法将事件传给 EventThread 线程，queueEvent 方法根据该通知事件，从 ZKWatchManager 中取出所有相关的 Watcher: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventThread</span> <span class="keyword">extends</span> <span class="title">ZooKeeperThread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">                Set&lt;Watcher&gt; materializedWatchers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getType() == EventType.None</span><br><span class="line">                    &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sessionState = event.getState();</span><br><span class="line">            <span class="keyword">final</span> Set&lt;Watcher&gt; watchers;</span><br><span class="line">            <span class="keyword">if</span> (materializedWatchers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">                watchers = watcher.materialize(event.getState(),</span><br><span class="line">                        event.getType(), event.getPath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                watchers.addAll(materializedWatchers);</span><br><span class="line">            &#125;</span><br><span class="line">            WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair(watchers, event);</span><br><span class="line">            <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">            waitingEvents.add(pair);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>客户端在识别出事件类型 EventType 之后，会从相应的 Watcher 存储中删除对应的 Watcher，获取到相关的 Watcher 之后，会将其放入 waitingEvents 队列，该队列从字面上就能理解是一个待处理队列，线程的 run 方法会不断对该该队列进行处理，这就是一种异步处理思维的实现。</p>
<p>ZKWatchManager 取出 Watcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">materialize</span><span class="params">(Watcher.Event.KeeperState state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Watcher.Event.EventType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        String clientPath)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Set&lt;Watcher&gt; result = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">             <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">             <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                <span class="keyword">synchronized</span> (dataWatches) &#123;</span><br><span class="line">                    addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (existWatches) &#123;</span><br><span class="line">                    addTo(existWatches.remove(clientPath), result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventThread 线程的 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">              isRunning = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 Object event = waitingEvents.take();</span><br><span class="line">                 <span class="keyword">if</span> (event == eventOfDeath) &#123;</span><br><span class="line">                    wasKilled = <span class="keyword">true</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    processEvent(event);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (wasKilled)</span><br><span class="line">                    <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</span><br><span class="line">                          isRunning = <span class="keyword">false</span>;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              LOG.error(<span class="string">"Event thread exiting due to interruption"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZooKeeper-Watcher-特性总结"><a href="#ZooKeeper-Watcher-特性总结" class="headerlink" title="ZooKeeper Watcher 特性总结"></a>ZooKeeper Watcher 特性总结</h3><p><strong>1. 注册只能确保一次消费</strong></p>
<p>无论是服务端还是客户端，一旦一个 Watcher 被触发，ZooKeeper 都会将其从相应的存储中移除。因此，开发人员在 Watcher 的使用上要记住的一点是需要反复注册。这样的设计有效地减轻了服务端的压力。如果注册一个 Watcher 之后一直有效，那么针对那些更新非常频繁的节点，服务端会不断地向客户端发送事件通知，这无论对于网络还是服务端性能的影响都非常大。</p>
<p><strong>2. 客户端串行执行</strong></p>
<p>客户端 Watcher 回调的过程是一个串行同步的过程，这为我们保证了顺序，同时，需要开发人员注意的一点是，千万不要因为一个 Watcher 的处理逻辑影响了整个客户端的 Watcher 回调。</p>
<p><strong>3. 轻量级设计</strong></p>
<p>WatchedEvent 是 ZooKeeper 整个 Watcher 通知机制的最小通知单元，这个数据结构中只包含三部分的内容：通知状态、事件类型和节点路径。也就是说，Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。例如针对 NodeDataChanged 事件，ZooKeeper 的 Watcher 只会通知客户指定数据节点的数据内容发生了变更，而对于原始数据以及变更后的新数据都无法从这个事件中直接获取到，而是需要客户端主动重新去获取数据，这也是 ZooKeeper 的 Watcher 机制的一个非常重要的特性。另外，客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象传递到服务端，仅仅只是在客户端请求中使用 boolean 类型属性进行了标记，同时服务端也仅仅只是保存了当前连接的 ServerCnxn 对象。这样轻量级的 Watcher 机制设计，在网络开销和服务端内存开销上都是非常廉价的。</p>
<h2 id="ACL–保障数据的安全"><a href="#ACL–保障数据的安全" class="headerlink" title="ACL–保障数据的安全"></a>ACL–保障数据的安全</h2><p>Zookeeper内部存储了分布式系统运行时状态的元数据，这些元数据会直接影响基于Zookeeper进行构造的分布式系统的运行状态，如何保障系统中数据的安全，从而避免因误操作而带来的数据随意变更而导致的数据库异常十分重要，Zookeeper提供了一套完善的ACL权限控制机制来保障数据的安全。</p>
<p>我们可以从三个方面来理解ACL机制：<strong>权限模式（Scheme）、授权对象（ID）、权限（Permission）</strong>，通常使用：<code>schema:id:permission</code> 来标识一个有效的ACL信息。</p>
<h3 id="权限模式-Schema"><a href="#权限模式-Schema" class="headerlink" title="权限模式 Schema"></a>权限模式 Schema</h3><p>常用的权限模式如下：</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP： 使用 IP 识别用户，可以精确匹配 IP，也可以匹配到 IP 段</p>
<ul>
<li>ip:168.192.1.23 ：精确匹配到 IP</li>
<li>ip:168.192.0.1/24：模糊匹配 IP 段，168.192.0.*</li>
</ul>
<p>Note： IP 地址是 32 位，十进制表示 4 个十进制；IP 段，表示前面多少位相同。</p>
<h4 id="Digest"><a href="#Digest" class="headerlink" title="Digest"></a>Digest</h4><p>Digest，类似 <code>username:password</code>，用户名和密码。便于区分不同应用来进行权限控制。Zookeeper会对其进行SHA-1加密和BASE64编码。</p>
<h4 id="World"><a href="#World" class="headerlink" title="World"></a>World</h4><p>没有密码，对所有用户都开放权限。可以看作特殊的 Digest 模式。</p>
<h4 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h4><p>只有超级用户，才有权限，也可看作特殊的 Digest 模式。</p>
<h3 id="授权对象-ID"><a href="#授权对象-ID" class="headerlink" title="授权对象 ID"></a>授权对象 ID</h3><p>授权对象是指，权限赋予的用户或者一个实体，例如：IP 地址或者机器。</p>
<p>授权模式 schema 与 授权对象 ID 之间关系：</p>
<p><img src="/2019/08/16/zookeeper-system-model/zk-acl-schema-with-id.png" alt="img"></p>
<h3 id="权限-Permission"><a href="#权限-Permission" class="headerlink" title="权限 Permission"></a>权限 Permission</h3><p>ZooKeeper 中数据节点的权限分为 5 类：</p>
<ul>
<li>Create（C）：创建子节点</li>
<li>Delete（D）：删除子节点</li>
<li>Read（R）：读取当前节点，以及子节点列表</li>
<li>Write（W）：更新当前节点</li>
<li>Admin（A）：当前节点的 ACL 管理</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="UGO-权限控制"><a href="#UGO-权限控制" class="headerlink" title="UGO 权限控制"></a>UGO 权限控制</h3><p>UGO，（<code>User</code>，<code>Group</code>，<code>Others</code>），是（<code>用户</code>，<code>组</code>，<code>权限</code>）的简称。</p>
<p>Linux\Unix <strong>文件系统</strong>，采用 UGO 的权限控制，针对<code>文件/文件夹</code>的<code>创建者</code>，创建者所在<code>组</code>以及<code>其他用户</code>，分别分配不同的权限。</p>
<p>UGO 的权限控制，是基于用户的，跟系统的用户体系严格绑定。</p>
<h3 id="ACL-权限控制"><a href="#ACL-权限控制" class="headerlink" title="ACL 权限控制"></a>ACL 权限控制</h3><p>ACL，Access Control List，访问权限列表。</p>
<p>从 data 角度出发，赋予权限。</p>
<p>Note：</p>
<blockquote>
<p>目前绝大部分 Unix 系统都支持了 ACL，Linux 内核从 2.6+ 也开始支持 ACL。</p>
</blockquote>
<h3 id="RBAC-权限控制"><a href="#RBAC-权限控制" class="headerlink" title="RBAC 权限控制"></a>RBAC 权限控制</h3><p>RBAC，(Role-Based Access Control )基于角色的访问控制。</p>
<ul>
<li>一个用户拥有若干角色，每一个角色拥有若干权限。</li>
<li>构成 <strong>用户-角色-权限</strong> 的授权模型。</li>
</ul>
<p>在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">从Paxos到Zookeeper分布式一致性原理与实践</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-zookeeper-watcher/index.html" target="_blank" rel="noopener">Apache ZooKeeper Watcher 机制源码解释</a></li>
<li><a href="http://ningg.top/zookeeper-lesson-5-zookeeper-acl/" target="_blank" rel="noopener">ZooKeeper 技术内幕：ACL 权限访问控制</a></li>
<li><a href="https://www.cnblogs.com/leesf456/p/6291004.html" target="_blank" rel="noopener">源码分析之Watcher机制（三）之ZooKeeper</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/zookeeper/" rel="tag"># zookeeper</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/08/15/zookeeper-leader-election/" rel="next" title="zookeeper选举机制及源码解析">
                <i class="fa fa-chevron-left"></i> zookeeper选举机制及源码解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/08/16/zookeeper-data-and-storage/" rel="prev" title="zookeeper数据与存储">
                zookeeper数据与存储 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sainpo.yxb</p>
  <div class="site-description motion-element" itemprop="description">码农|理工男|文青</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/mewishu" title="GitHub &rarr; https://github.com/mewishu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xbyan88@163.com" title="E-Mail &rarr; mailto:xbyan88@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型"><span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点特性"><span class="nav-text">节点特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版本–保证分布式数据原子性操作"><span class="nav-text">版本–保证分布式数据原子性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#版本号，什么作用？"><span class="nav-text">版本号，什么作用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Watcher–数据变更通知"><span class="nav-text">Watcher–数据变更通知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总体框图"><span class="nav-text">总体框图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Watcher-接口"><span class="nav-text">Watcher 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端注册-Watcher-流程"><span class="nav-text">客户端注册 Watcher 流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端处理-Watcher-流程"><span class="nav-text">服务端处理 Watcher 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerCnxn存储"><span class="nav-text">ServerCnxn存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watcher触发"><span class="nav-text">Watcher触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端回调Watcher"><span class="nav-text">客户端回调Watcher</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-Watcher-特性总结"><span class="nav-text">ZooKeeper Watcher 特性总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACL–保障数据的安全"><span class="nav-text">ACL–保障数据的安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#权限模式-Schema"><span class="nav-text">权限模式 Schema</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP"><span class="nav-text">IP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Digest"><span class="nav-text">Digest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#World"><span class="nav-text">World</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Super"><span class="nav-text">Super</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#授权对象-ID"><span class="nav-text">授权对象 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限-Permission"><span class="nav-text">权限 Permission</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UGO-权限控制"><span class="nav-text">UGO 权限控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACL-权限控制"><span class="nav-text">ACL 权限控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RBAC-权限控制"><span class="nav-text">RBAC 权限控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sainpo.yxb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">161k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/reading_progress/reading_progress.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>



  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.3.0"></script>








<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>





    
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">
<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '96bfad82ea05d6d64ea7',
    clientSecret: '74d6d9a9834e4e6c3db88d702866ae41f675f888',
    repo: 'usercomment',
    owner: 'mewishu',
    admin: ['mewishu'],
    id: md5(location.pathname),
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>


</body>
</html>
