<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[regexp-syntax]]></title>
    <url>%2F2019%2F08%2F05%2Fregexp-syntax%2F</url>
    <content type="text"><![CDATA[元字符 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 grep示例grep “test[53]” jfedu.txt 以字符test开头，接5或者3的行 常用正则表达式收集 最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等 常用正则表达式 - 收集一些在平时项目开发中经常用到的正则表达式]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[paxos精髓及示例]]></title>
    <url>%2F2019%2F07%2F31%2Fpaxos-essence-and-demo%2F</url>
    <content type="text"><![CDATA[Paxos精髓paxos协议用来解决的问题可以用一句话来简化: proposer将发起提案（value）给所有accpetor，超过半数accpetor获得批准后，proposer将提案写入accpetor内，最终所有accpetor获得一致性的确定性取值，且后续不允许再修改。 协议分为两大阶段，每个阶段又分为a/b两小步骤： 准备阶段（占坑阶段）Phase 1a: PrepareProposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。 Phase 1b: PromiseAcceptor接收到Prepare（n）请求，若提议编号n比之前接收的Prepare请求都要大，则承诺将不会接收提议编号比n小的提议，并且带上之前Accept的提议中编号小于n的最大的提议，否则不予理会。 接受阶段（提交阶段）Phase 2a: Accept​ 1. 如果未超过半数accpetor响应，直接转为提议失败； ​ 2. 如果超过多数Acceptor的承诺，又分为不同情况： ​ 2.1 如果所有Acceptor都未接收过值（都为null），那么向所有的Acceptor发起自己的值和提议编号n，记住，一定是所有Acceptor都没接受过值； ​ 2.2 如果有部分Acceptor接收过值，那么从所有接受过的值中选择对应的提议编号最大的作为提议的值，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则； Phase 2b: AcceptedAcceptor接收到提议后，如果该提议版本号不等于自身保存记录的版本号（第一阶段记录的），不接受该请求，相等则写入本地。 整个paxos协议过程看似复杂难懂，但只要把握和理解这两点就基本理解了paxos的精髓： 理解第一阶段accpetor的处理流程：如果本地已经写入了，不再接受和同意后面的所有请求，并返回本地写入的值；如果本地未写入，则本地记录该请求的版本号，并不再接受其他版本号的请求，简单来说只信任最后一次提交的版本号的请求，使其他版本号写入失效； 理解第二阶段proposer的处理流程：未超过半数accpetor响应，提议失败；超过半数的accpetor值都为空才提交自身要写入的值，否则选择非空值里版本号最大的值提交，最大的区别在于是提交的值是自身的还是使用以前提交的。 Basic Paxos信息流协议过程举例看这个最简单的例子：1个processor，3个Acceptor，无learner。 目标：proposer向3个aceptort 将name变量写为v1。 第一阶段A：proposer发起prepare（name，n1）,n1是递增提议版本号，发送给3个Acceptor，说，我现在要写name这个变量，我的版本号是n1第一阶段B：Acceptor收到proposer的消息，比对自己内部保存的内容，发现之前name变量（null，null）没有被写入且未收到过提议，都返回给proposer，并在内部记录name这个变量，已经有proposer申请提议了，提议版本号是n1;第二阶段A：proposer收到3个Acceptor的响应，响应内容都是：name变量现在还没有写入，你可以来写。proposer确认获得超过半数以上Acceptor同意，发起第二阶段写入操作：accept（v1,n1），告诉Acceptor我现在要把name变量协议v1,我的版本号是刚刚获得通过的n1;第二阶段B：accpetor收到accept（v1,n1），比对自身的版本号是一致的，保存成功，并响应accepted（v1,n1）；结果阶段：proposer收到3个accepted响应都成功，超过半数响应成功，到此name变量被确定为v1。 以上是正常的paxos协议提议确定流程，是不是很简单，很容易理解呢？ 确定你理解了上面的例子再往后看。 这是最简单也最容易理解的例子，但真实情况远比这个复杂，还有以下问题： 如果其中的某个Acceptor没响应怎么处理？如果只写成功了一个accpetor又怎么处理，写成功两个呢？如果多个proposer并发写会导致accpetor写成不同值吗？learner角色是做什么用？为什么是超过半数同意？ paxos特殊情况下的处理第一种情况：Proposer提议正常，未超过accpetor失败情况 问题：还是上面的例子，如果第二阶段B，只有2个accpetor响应接收提议成功，另外1个没有响应怎么处理呢？ 处理：proposer发现只有2个成功，已经超过半数，那么还是认为提议成功，并把消息传递给learner，由learner角色将确定的提议通知给所有accpetor，最终使最后未响应的accpetor也同步更新，通过learner角色使所有Acceptor达到最终一致性。 第二种情况：Proposer提议正常，但超过accpetor失败情况 问题：假设有2个accpetor失败，又该如何处理呢？ 处理：由于未达到超过半数同意条件，proposer要么直接提示失败，要么递增版本号重新发起提议，如果重新发起提议对于第一次写入成功的accpetor不会修改，另外两个accpetor会重新接受提议，达到最终成功。 情况再复杂一点：还是一样有3个accpetor，但有两个proposer。 情况一：proposer1和proposer2串行执行 proposer1和最开始情况一样，把name设置为v1，并接受提议。 proposer1提议结束后，proposer2发起提议流程： 第一阶段A：proposer1发起prepare（name，n2） 第一阶段B：Acceptor收到proposer的消息，发现内部name已经写入确定了，返回（name,v1,n1） 第二阶段A：proposer收到3个Acceptor的响应，发现超过半数都是v1，说明name已经确定为v1，接受这个值，不再发起提议操作。 情况二：proposer1和proposer2交错执行 proposer1提议accpetor1成功，但写入accpetor2和accpetor3时，发现版本号已经小于accpetor内部记录的版本号（保存了proposer2的版本号），直接返回失败。 proposer2写入accpetor2和accpetor3成功，写入accpetor1失败，但最终还是超过半数写入v2成功，name变量最终确定为v2； proposer1递增版本号再重试发现超过半数为v2，接受name变量为v2，也不再写入v1。name最终确定还是为v2 情况三：proposer1和proposer2第一次都只写成功1个Acceptor怎么办 都只写成功一个，未超过半数，那么Proposer会递增版本号重新发起提议，这里需要分多种情况： 3个Acceptor都响应提议，发现Acceptor1{v1,n1} ,Acceptor2{v2,n2},Acceptor{null,null}，Processor选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 2个Acceptor都响应提议， 如果是Acceptor1{v1,n1} ,Acceptor2{v2,n2}，那么选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 如果是Acceptor1{v1,n1} ,Acceptor3{null,null}，那么选择最大的{v1,n1}发起第二阶段，成功后name值为v1; 如果是Acceptor2{v2,n2} ,Acceptor3{null,null}，那么选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 只有1个Acceptor响应提议，未达到半数，放弃或者递增版本号重新发起提议可以看到，都未达到半数时，最终值是不确定的！ 参考资料 paxos算法wiki: https://en.wikipedia.org/wiki/Paxos_(computer_science)#Basic_Paxos 首先，推荐的是知行学社的《分布式系统与Paxos算法视频课程》： 视频讲的非常好，很适合入门，循序渐进慢慢推导，我自己看了不下5遍，视频讲解理解更深，推荐大家都看看。 推荐刘杰的《分布式系统原理介绍》 ，里面有关于paxos的详细介绍，例子非常多，也有包括paxos协议的证明过程，大而全，质量相当高的一份学习资料！ 推荐的一份高质量ppt《可靠分布式系统基础 Paxos 的直观解释》: https://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html； 技术类的东西怎么能只停留在看上面，肯定要看代码啊，推荐微信开源的phxpaxos：https://github.com/tencent-wechat/phxpaxos，结合代码对协议理解更深。 《Paxos Made live》。这篇论文是 Google 发表的，讨论了 paxos 的工程实践，也就是 chubby 这个众所周知的分布式服务的实现，可以结合《The Chubby lock service for loosely-coupled distributed systems》 一起看。实际应用中的难点，比如 master 租约实现、group membership 变化、Snapshot 加快复制和恢复以及实际应用中遇到的故障、测试等问题，特别是最后的测试部分。非常值得一读。《The Chubby lock service for loosely-coupled distributed systems》 更多介绍了 Chubby 服务本身的设计决策，为什么是分布式锁服务，为什么是粗粒度的锁，为什么是目录文件模式，事件通知、多机房部署以及应用碰到的使用问题等等。 Paxos 我还着重推荐阅读微信后端团队写的系列博客，包括他们开源的 phxpaxos 实现，基本上将所有问题都讨论到了，并且通俗易懂。 一致性方面另一块就是 Raft 算法，按照 Google Chubby 论文里的说法， 1`Indeed, all working protocols for asynchronous consensus we have so far encountered have Paxos at their core.` 但是 Raft 真的好理解多了，我读的是《In Search of an Understandable Consensus Algorithm》，论文写到这么详细的步骤，你不想理解都难。毕竟 Raft 号称就是一个 Understandable Consensus Algorithm。无论从任何角度，都推荐阅读这一篇论文。 首先能理解 paxos 的一些难点，其次是了解 Raft 的实现，加深对 Etcd 等系统的理解。这篇论文还有一个 250 多页的加强版《CONSENSUS: BRIDGING THEORY AND PRACTICE》，教你一行一行写出一个 Raft 实现，我还没有学习，有兴趣可以自行了解。Raft 通过明确引入 leader（其实 multi paxos 引申出来也有，但是没有这么明确的表述）来负责 client 交互和日志复制，将整个算法过程非常清晰地表达出来。Raft 的算法正确性的核心在于保证 Leader Completeness ，选举算法选出来的 leader 一定是包含了所有 committed entries 的，这是因为所有 committed entries 一定会在多数派至少一个成员里存在，所以设计的选举算法一定能选出来这么一个成员作为 leader。多数派 accept 应该说是一致性算法正确性的最重要的保证。 最后，我还读了《Building Consistent Transactions with Inconsistent Replication》，包括作者的演讲，作者也开放了源码。Google Spanner 基本是将 paxos 算法应用到了极致，但是毕竟不是所有公司都是这么财大气粗搞得起 TrueTime API，架得起全球机房，控制或者承受得了事务延时。这篇论文提出了另一个思路，论文介绍的算法分为两个层次： IR 和基于其他上的 TAPIR。前者就是 Inconsistent Replication，它将操作分为两类： inconsistent： 可以任意顺序执行，成功执行的操作将持久化，支持 failover。 consensus：同样可以任意顺序执行并持久化 failover，但是会返回一个唯一的一致(consensus)结果。 Java简单实现Basic Paxos算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249/** * Alipay.com Inc. * Copyright (c) 2004-2019 All Rights Reserved. */package paxos;import com.google.common.base.Charsets;import org.apache.commons.lang3.StringUtils;import com.google.common.hash.HashFunction;import com.google.common.hash.Hashing;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.Random;/** * @author xbyan * @version $Id: PaxosStudy.java, v 0.1 2019-07-01 5:47 PM xbyan Exp $$ */public class PaxosStudy &#123; private static final HashFunction HASH_FUNCTION = Hashing.murmur3_32(); private static final Random RAMDOM = new Random(); private static final String[] PROPOSALS = &#123; "ProjectA", "ProjectB", "ProjectC" &#125;; public static void main(String[] args) throws InterruptedException &#123; //新建server组 List&lt;Acceptor&gt; acceptors = new ArrayList&lt;&gt;(); Arrays.asList("A", "B", "C", "D", "E").forEach(name -&gt; acceptors.add(new Acceptor(name))); //开始投票 Proposer.vote(new Proposal(1L, null), acceptors); &#125; private static void printInfo(String subject, String operation, String result) throws InterruptedException &#123; System.out.println(subject + ":" + operation + "&lt;" + result + "&gt;"); Thread.sleep(1000); &#125; /** * 对于提案的约束，第三方约束要求 * 如果maxVote不存在，那么没有限制，下一次表决可以使用任意提案 * 否则，下一次表决要沿用maxVote提案 * * @param currentVoteNumber * @param proposals * @return */ private static Proposal nextProposal(long currentVoteNumber, List&lt;Proposal&gt; proposals) &#123; long voteNumber = currentVoteNumber + 1; //刚开始投票 if (proposals.isEmpty()) &#123; Proposal proposal = new Proposal(voteNumber, PROPOSALS[RAMDOM.nextInt(PROPOSALS.length)]); System.out.println("NEXT PROPOSER(刚开始投票), currentVoteNumber" + currentVoteNumber + ",proposal=" + proposal); return proposal; &#125; //为之前的票排序 Collections.sort(proposals); Proposal maxVote = proposals.get(proposals.size() - 1); //列表里最大值 long maxVoteNumber = maxVote.getVoteNumber(); String content = maxVote.getContent(); if (maxVoteNumber &gt;= currentVoteNumber) &#123; throw new IllegalStateException("illegal state maxVoteNumber"); &#125; if (content != null) &#123; Proposal proposal = new Proposal(voteNumber, content); System.out.println("NEXT PROPOSER(content不为空), voteNumber=" + voteNumber + ",proposal=" + proposal + ",maxVote=" + maxVote); return proposal; &#125; else &#123; Proposal proposal = new Proposal(voteNumber, PROPOSALS[RAMDOM.nextInt(PROPOSALS.length)]); System.out.println("NEXT PROPOSER(content为空), voteNumber=" + voteNumber + ",proposal=" + proposal + ",maxVote=" + maxVote); return proposal; &#125; &#125; private static class Proposer &#123; /** * @param proposal * @param acceptors */ public static void vote(Proposal proposal, Collection&lt;Acceptor&gt; acceptors) throws InterruptedException &#123; //法定人数 n/2+1 int quorum = Math.floorDiv(acceptors.size(), 2) + 1; System.out.println("quorum " + quorum); int count = 0; while (true) &#123; //开始投票 printInfo("VOTE_ROUND", "START", ++count + "：开始向acceptor发送信息"); List&lt;Proposal&gt; proposals = new ArrayList&lt;&gt;(); for (Acceptor acceptor : acceptors) &#123; Promise promise = acceptor.onPrepare(proposal); if (promise != null &amp;&amp; promise.isAck()) &#123; //Acceptor批准后就可以将发起者加入发起者列表里 System.out .println("--------------------------------------------------ACCEPTOR批准,将发起者加入队列里,proposal=" + promise.getProposal()); proposals.add(promise.getProposal()); &#125; &#125; if (proposals.size() &lt; quorum) &#123; //小于法定人数 printInfo("PROPOSER[" + proposal + "]", "VOTE", "NOT PREPARED：接收到消息的acceptor小于半数"); System.out.println("onPrepare阶段编号增加 重新发起投票"); proposal = nextProposal(proposal.getVoteNumber(), proposals); continue; &#125; System.out.println("接收到消息的acceptor大于半数，开始提案内容"); int acceptCount = 0; for (Acceptor acceptor1 : acceptors) &#123; if (acceptor1.onAccept(proposal)) acceptCount++; &#125; if (acceptCount &lt; quorum) &#123; printInfo("PROPOSER[" + proposal + "]", "VOTE", "NOT ACCEPTED,接受提案的少于半数"); System.out.println("onAccept阶段编号增加 重新发起投票"); proposal = nextProposal(proposal.getVoteNumber(), proposals); continue; &#125; break; &#125; printInfo("PROPOSER[" + proposal + "]", "VOTE", "SUCCESS，接受提案成功"); &#125; &#125; private static class Acceptor &#123; //上次表决结果 private Proposal last = new Proposal(); private String name; public Acceptor(String name) &#123; this.name = name; &#125; public Promise onPrepare(Proposal proposal) throws InterruptedException &#123; //假设这个过程有50%的几率失败 if (Math.random() - 0.5 &gt; 0) &#123; printInfo("ACCEPTER_" + name, "PREPARE", "NO RESPONSE 向" + name + " 发送失败"); return null; &#125; if (proposal == null) throw new IllegalArgumentException("null proposal"); //大于 if (proposal.getVoteNumber() &gt; last.getVoteNumber()) &#123; Promise response = new Promise(true, last); last = proposal; printInfo("ACCEPTER_" + name, "PREPARE", "OK " + name + " 记下编号，返回信息,last=" + last); return response; &#125; else &#123; printInfo("ACCEPTER_" + name, "PREPARE", "REJECTED " + name + " 已保存有选定的编号，拒绝"); return new Promise(false, null); &#125; &#125; public boolean onAccept(Proposal proposal) throws InterruptedException &#123; //假设这个过程有50%的几率失败 if (Math.random() - 0.5 &gt; 0) &#123; printInfo("ACCEPTER_" + name, "ACCEPT", "NO RESPONSE " + name + " 发送提案失败"); return false; &#125; boolean accepted = last.equals(proposal); printInfo("ACCEPTER_" + name, "ACCEPT", name + (accepted ? "OK：通过" : "NO: 不通过") + "last=" + last + ",proposal=" + proposal); return accepted; &#125; &#125; private static class Promise &#123; private final boolean ack; private final Proposal proposal; private Promise(boolean ack, Proposal proposal) &#123; this.ack = ack; this.proposal = proposal; &#125; public boolean isAck() &#123; return ack; &#125; public Proposal getProposal() &#123; return proposal; &#125; &#125; private static class Proposal implements Comparable&lt;Proposal&gt; &#123; private final long voteNumber; private final String content; public Proposal(long voteNumber, String content) &#123; this.voteNumber = voteNumber; this.content = content; &#125; public Proposal() &#123; this(0, null); &#125; public long getVoteNumber() &#123; return voteNumber; &#125; public String getContent() &#123; return content; &#125; public int compareTo(Proposal o) &#123; return Long.compare(voteNumber, o.voteNumber); &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (!(obj instanceof Proposal)) return false; Proposal proposal = (Proposal) obj; return voteNumber == proposal.voteNumber &amp;&amp; StringUtils.equals(content, proposal.content); &#125; @Override public int hashCode() &#123; return HASH_FUNCTION.newHasher().putLong(voteNumber).putString(content, Charsets.UTF_8) .hash().asInt(); &#125; @Override public String toString() &#123; return new StringBuilder().append(voteNumber).append(':').append(content).toString(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>分布式一致性</category>
        <category>paxos算法</category>
      </categories>
      <tags>
        <tag>paxos</tag>
        <tag>分布式一致性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[paxos-by-example]]></title>
    <url>%2F2019%2F07%2F29%2Fpaxos-by-example%2F</url>
    <content type="text"><![CDATA[Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。 网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文Paxos Made Simple，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。 Paxos是什么 Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。 Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。 虽然Mike Burrows说得有点夸张，但是至少说明了Paxos算法的地位。然而，Paxos算法也因为晦涩难懂而臭名昭著。本文的目的就是带领大家深入浅出理解Paxos算法，不仅理解它的执行流程，还要理解算法的推导过程，作者是怎么一步步想到最终的方案的。只有理解了推导过程，才能深刻掌握该算法的精髓。而且理解推导过程对于我们的思维也是非常有帮助的，可能会给我们带来一些解决问题的思路，对我们有所启发。 最近在看paxos算法, 看了不少博客, 都感觉总结得不够到位,甚至有理解偏差的地方,倒是在博客的引用文章里面找到了一篇英文文献,看完后豁然开朗茅塞顿开. 于是把那篇英文原文翻译了一下, 加深一下理解 英文文献虽是2012年的了, 但是短小精悍,值得一看,原文地址是: angus.nyc/2012/paxos-by-example/ 文章中不全是直译, 有些地方改成了我自己的理解, 所以有可能有理解错的地方, 还望指出. 关于作者: Lamport提到Paxos算法，我们不得不首先来介绍下Paxos算法的作者Leslie Lamport(莱斯利·兰伯特, http://www.lamport.org )及其对计算机科学尤其是分布式计算领域的杰出贡献。作为2013年的新科图灵奖得主，Lamport是计算机科学领域一位拥有杰出成就的传奇人物，其先后多次荣获ACM和IEEE以及其他各类计算机重大奖项。Lamport对时间时钟、面包店算法、拜占庭将军问题以及Paxos算法的创造性研究，极大地推动了计算机科学尤其是分布式计算的发展，全世界无数工程师得益于他的理论，其中Paxos算法的提出，正是Lamport多年的研究成果。 说起Paxos理论的发表，还有一段非常有趣的历史故事。Lamport早在1990年就已经将其对Paxos算法的研究论文《The PartTime Parliament》提交给ACM TOCS Jnl.的评审委员会了，但是由于Lamport“创造性”地使用了故事的方式来进行算法的描述，导致当时委员会的工作人员没有一个能够正确地理解他对算法的描述，时任主编要求Lamport使用严谨的数据证明方式来描述该算法，否则他们将不考虑接受这篇论文。遗憾的是，Lamport并没有接收他们的建议，当然也就拒绝了对论文的修改，并撤销了对这篇论文的提交。在后来的一个会议上，Lamport还对此事耿耿于怀：“为什么这些搞理论的人一点幽默感也没有呢？” 幸运的是，还是有人能够理解Lamport那公认的令人晦涩的算法描述的。1996年，来自微软的Butler Lampson在WDAG96上提出了重新审视这篇分布式论文的建议，在次年的WDAG97上，麻省理工学院的Nancy Lynch也公布了其根据Lamport的原文重新修改后的《Revisiting the Paxos Algorithm》，“帮助”Lamport用数学的形式化术语定义并证明了Paxos算法。于是在1998年的ACM TOCS上，这篇延迟了9年的论文终于被接受了，也标志着Paxos算法正式被计算机科学接受并开始影响更多的工程师解决分布式一致性问题。 后来在2001年，Lamport本人也做出了让步，这次他放弃了故事的描述方式，而是使用了通俗易懂的语言重新讲述了原文，并发表了《Paxos Made Simple》——当然，Lamport甚为固执地认为他自己的表述语言没有歧义，并且也足够让人明白Paxos算法，因此不需要数学来协助描述，于是整篇文章还是没有任何数学符号。好在这篇文章已经能够被更多的人理解，相信绝大多数的Paxos爱好者也都是从这篇文章开始慢慢进入了Paxos的神秘世界。 由于Lamport个人自负固执的性格，使得Paxos理论的诞生可谓一波三折。关于Paxos理论的诞生过程，后来也成为了计算机科学领域被广泛流传的学术趣事。 图0: Lamport本尊 译文开始本文通过一个实例描述了一个叫Paxos的分布式一致性算法 分布式一致性算法通常是用于让多个计算机节点就某个单值的修改达成一致, 例如事务的提交commit或回滚rollback, 典型的思想就是二阶段提交或三阶段提交. 算法并不关心这个单值是什么,只关心最后只有唯一一个值被所有的节点选中, 对该值的修改达成一致 在一个分布式系统中这非常的难, 因为不同机器之前的消息可能会丢失, 或是被无限延迟, 甚至机器本身也会挂掉 Paxos算法可以保证最终只会有一个值会被选中, 但是不能保证如果集群中的大多数节点挂掉后,还能选中一个值 概述Paxos的节点可以是proposer, acceptor,learner中的任何一种角色.proposer会提议一个它想被采纳的值, 一般是通过发送一个包含该提议值的提案给集群中的每个acceptor. 然后acceptor会独立的决定是否接受这个提案–它可能会接收到多个proposer的不同提案, 决定好后会把它的决定发给learner. learner的作用是判断一个值是否已经被接受.在Paxos算法中, 只有一个值被大多数的acceptor选中, 才算被Paxos算法选中.在实际项目中, 一个节点可能担任多种角色, 但是在这个例子里面, 每一种角色都是一个独立的节点. 图1 Paxos的基本架构. 几个proposer向acceptor提交提案. 当一个acceptor接受了一个值后, 它把它的决定发给learner Paxos算法例子在标准的Paxos算法中, 一个proposer会发送两种类型的消息给acceptors: prepare request 和accept request. 在算法的第一阶段, proposer会发送一个prepare request给每一个acceptor, 这个prepare request包含一个提议值value和一个提案号number.每一个proposer的提案号number必须是正数, 单调递增的,独一无二的自然数[1]. 在下面图2的例子中, 有两个proposer, 都在发送prepare request. proposer A的请求([n=2,v=8])比proposer B的请求([n=4,v=5])先到达acceptor X和acceptor Y, 而proposer B的请求先到达acceptor Z 图2: Paxos. proposer A和B各发送了一个prepare request 给每一个accetor. 在这个例子中, proposer A的请求先到达acceptor X和Y, 而proposer B的请求先到达了acceptor Z. 如果一个acceptor接收到了一个prepare request而又没接收过其他的提案, 这个acceptor会回应一个prepare response, 并保证不会接受其他比当前提案号number更小的提案. 下面图3展示了每个acceptor是如何响应它们接收到的prepare request的 图3: 每个acceptor都对它接收到的第一个prepare request 进行prepare response. 最终, acceptor Z接收到了proposer A的请求[2], acceptor X和Y收到了proposer B的请求. 如果一个acceptor之前已经接收了一个提案号更高的prepare request的话, 那么后面收到的prepare request就会被忽略, 这个例子中就是acceptor Z会忽略掉proposer A的请求(Z已经接收了B的提案n=4). 如果acceptor之前没有接收过更高提案号的提案, 它会保证忽略其他提案号比这个更低的请求(注意是包括prepare request和accept request),然后在prepare response中把它已经选中的提案号最高的提议(包括这个提议的值)发送给proposer.在这个例子就是acceptor X和Y给proposer B的响应(X和Y已经接受了一个B的[n=2,v=8]的提案,当再收到[n=4, v=5]的提案时, 它保证会忽略任何n&lt;4的prepare request和accept request, 然后把[n=2, v=8]的prepare response回去给B) 图4: acceptor Z 忽略了proposer A的请求, 因为它已经接收到了更高的提议号(4 &gt; 2). acceptor X和Y给proposer B响应了它见过最高的提议号的提案, 并承诺会忽略提案号更小的提案 一旦proposer 收到了大多数acceptor的prepare response, 它就可以开始给所有的acceptor发送accept request了. 因为proposer A接收到prepare response中表明在它之前没有更早的提案. 所以它的accept request中的提案号和提议值都是跟prepare request中的一样.然而,这个accept request被所有的acceptor都拒绝了,因为它们都承诺了不会接收提议号比4更新的提案(因为都见过proposer B的提案了) Proposer B的accept request情况就跟proposer A的有所不同了. 首先它的提案号还是它之前的提案号(n=4), 但是提议值却不是它之前的提议值了(它之前提议的是v=5), 而是它在prepare response中接收到的提议值(v=8)[3] 图5: proposer B也发送了一个accept request给每一个acceptor.acceptor request中的提案号是它之前的提案号(4), 而提议值是它在prepare response中收到的值(8, 来自proposer A的提案[n=2, v=8]) 如果acceptor收到了一个提案号不小于它见过的accept request, 它会接受这个accept request并且发送一个通知给到learner节点. 当learner节点发现大多数acceptor都已经接受了一个值的时候,Paxos算法就认为这个值已经被选中. 当一个值被paxos选中后,后续的流程中将不能改变这个值.例如,当另一个proposer C发送一个提案号更高的prepare request(例如, [n=6, v=7])过来时,所有的acceptor都会响应它之前已经选中的提议(n=4,v=8).这会要求proposer C在后续的acceptor request中也只能发送[n=6, v=8]的提议, 即只能确认一遍已经选中的这个值. 再后面, 如果有少量的acceptor还没选中一个值的话, 这个流程会保证最终所有的节点都会一致地选中同一个值. 译文结束 提案号的唯一性的保证不是Paxos算法的内容 ↩︎ 这个也可能不会发送, 但是这个算法中也是有可能的 ↩︎ 注意这个是它从prepare response中收到的最高的提案号. 在这个例子中, proposer B的提案号(n=4)是比proposer A的提案号(n=2)大. 但是在它的prepare request的响应中, 它只收到了proposer A的提议([n=2, v=8]). 如果它在prepare response中没有收到其他的提案的话, 它就会发送自己的提案([n=4,v=5]) ↩︎ 参考资料 NEAT ALGORITHMS - PAXOS(小动画可以辅助读懂): http://harry.me/blog/2014/12/27/neat-algorithms-paxos/ paxos-by-example(通过一个例子理解paxos算法): https://juejin.im/post/5d159590f265da1b86089a89 Paxos Made Live: an amazing paper from Google describing the challenges of their Paxos implementation in Chubby: http://static.googleusercontent.com/media/research.google.com/en//archive/paxos_made_live.pdf A Quora thread explaining Paxos in a few different ways: https://www.quora.com/Distributed-Systems/What-is-a-simple-explanation-of-the-Paxos-algorithm Raft - An Understandable Consensus Algorithm. Raft is another conensus algorithm designed for humans to understand, which if you can tell from the above wall of text might be a problem with Paxos. https://ramcloud.stanford.edu/raft.pdf 左耳听风 - 推荐阅读：分布式数据调度相关论文: http://10-02.com/180118-32%20_%20%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87.html]]></content>
      <categories>
        <category>分布式一致性</category>
        <category>paxos算法</category>
      </categories>
      <tags>
        <tag>paxos</tag>
        <tag>分布式一致性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
