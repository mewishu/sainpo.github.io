<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[行万里路:葛剑雄旅行]]></title>
    <url>%2F2019%2F08%2F10%2Fgejianxiong-xingwanlilu%2F</url>
    <content type="text"><![CDATA[缘起之前在微博上了解过有一个很著名的文化学者: 葛剑雄，那时其title为复旦大学图书馆馆长。后来在杭州图书馆偶尔看到他的一本书叫《行万里路: 葛剑雄旅行》，带回来读了下，没想到他的授业恩师居然是赫赫有名的谭其骧教授(最早通过《中国国家地图集历史地图集》知道他，这部作品是迄今最权威的中国历史政区地图集，谭先生也是中国历史地理学科主要奠基人和开拓者)，所以拜读的兴趣就更浓厚。书中有不少精彩的文章，下面是一些书摘。 开放的城市离不开移民移民迁移关乎城市兴衰 都市离不开移民，无论是在其形成之初，还是在其发展过程中。一旦移民断绝，甚至出现人口大量外迁，富有该都市特色的文化亦随之而停滞，而衰落，以至最终消亡，古今都市概莫能外。 如西汉长安，是在秦朝咸阳城外的废墟上新建的，故址也只是一个乡，几乎已没有原住民。但在建成之日即迁入大批功臣、贵族、关东六国后裔及豪强，以后又通过迁入陵县(依托皇帝陵墓而设的县)的办法，在长安附近形成了一个城市群，总人口超过一百万。西汉后期，长安一带已是“名都对郭，邑居相承，英俊之域，绂冕所兴，冠盖如云”的繁华都市，形成“五方杂错，风俗不纯”的文化特色。但在公元初新莽政权覆灭引发的战乱中，长安人口损失惨重。东汉建都洛阳后，不仅吸引了大批移民，连长安和关中的精英也纷纷迁往。尽管关中父老仍在梦想有朝一日首都迁回长安，但实际上再未恢复昔日的繁盛。 在北魏孝文帝拓跋宏决定将首都从平城(今山西大同一带)迁往洛阳之时，东汉以来的洛阳早已不复存在。所以在迁都之初只能以金墉城为临时驻地，与西汉迁都长安时的形势相似。但孝文帝实行了最彻底的迁都和汉化政策，所以平城的人口特别是其中的上中层，几乎全部被迁往洛阳。由于此前北魏已在其辖境范围内进行过多次强制性的移民，平城集中了中国北方的上层人士，因而这次新的移民就意味着他们都集中到了洛阳。如在中原战乱中迁往河西走廊的移民后裔，和当地长期形成的文化精英，由西域(泛指今新疆、中亚、印度等地)内迁的僧人、商人、学者等，都先被迁至平城，又被迁于洛阳。此后，洛阳作为北方政权的首都成为中外移民的集中点，也成为多元文化的交汇点。《洛阳伽蓝记》描述了当时的繁盛：“自葱岭已西，至于大秦，百国千城，莫不欢附，商胡贩客，日奔塞下，所谓尽天地之区，已乐中国风土，因而宅者，不可胜数。是以附化之民，万有余家。门巷修整，阊阖填列，青槐荫陌，绿树垂庭，天下难得之货，咸悉在焉。”如此丰富的物质文明也滋养了极其多彩的精神文明，云冈石窟、大批寺庙和辉煌的佛教艺术应运而生。永安二年(529年)，南朝梁国的陈庆之在洛阳短期停留。尽管洛阳的极盛时期已经过去，还是让陈庆之瞠目结舌：“自晋、宋以来，号洛阳为荒土，此中(南方)谓长江以北，尽是夷狄。昨至洛阳，始知衣冠士族并在中原，礼仪富盛，人物殷阜，目所不识，口不能传。所谓‘帝京翼翼，四方之则’，始知登泰山卑培嵝，涉江海者小湘、沅。北人安可不重?” 近代上海是一个典型的移民城市。1843年上海开埠时，整个上海县只有50余万人口，英租界和法租界所在地是上海县城外的乡村，大部分还是农田和坟墓，人口稀少。但到1900年，上海的人口已经突破100万，到1949年更高达500多万。上海开埠时总共才有26位外国人，但以后迅速增加，经常保持着数万人的规模，1943年外国侨民高达15万，1949年上海解放时还有28000多人。上海从一个中等水平的江南县城一跃成为中国和亚洲最大、最发达的都市，移民无疑具有决定性的作用。但自1949年至20世纪70年代末，上海的高素质人口大量迁出，如迁往成为首都的北京，参军参干，支援外地建设，求学，随国民党迁往台湾，迁往港澳和国外，60年代后大规模的大小三线建设和知识青年上山下乡，迁出人口数以百万计。迁入的人口不但数量有限，而且以干部、退伍军人、体力劳动者为主，少数大专毕业生往往学非所用，作用无法充分发挥。再无新的外国侨民迁入，原有侨民大多迁出，未迁者也陆续消失，最后一位外国侨民至80年代初死亡。由移民带入的内资、外资全部断绝。上海都市文化的长期萧条正是这些因素的必然结果。而同期的香港却因大批高素质内地移民的迁入而获益，更因其特殊地位而成为东西方、海内外文化接触和交流的场所，在相当程度上已与上海主客易位。 地图上的中国和历史上的中国疆域：谭其骧编纂历史地图集的历程 但在重大原则问题上，谭先生对中国疆域的处理是经过深思熟虑，始终坚持的。长期以来，出于政治目的，史学界对今天中国境内的疆域一直强调“自古以来”，似乎中国从夏、商、周三代以来一直是这么大，似乎不找到一点“自古以来”的证据，一个地方归属于中国就失去了合法性。其中最敏感的地方就是台湾，由于谭先生坚持实事求是原则，以史料史实为根据，因此，“文革”期间这成为一条重要的“反革命”罪状，他受到了严厉的批判斗争。在修订过程中，他对台湾的处理方案多次被主管部门否决，《图集》的正式出版因此推迟了好几年，直到中央领导亲自过问并签阅批准，才涉险过关。但是，谭先生坚持认为： 台湾在明朝以前，既没有设过羁縻府州，也没有设过羁縻卫所，岛上的部落首领没有向大陆王朝进过贡，称过臣，中原王朝更没有在台湾岛上设官置守。过去我们历史学界也受了“左”的影响，把“台湾自古以来是中国的一部分”这句话曲解了。台湾自古以来是中国的一部分，这是一点没有错的，但是你不能把这句话解释为台湾自古以来是中原王朝的一部分，这是完全违反历史事实，明以前历代中原王朝都管不到台湾。有人要把台湾纳入中国从三国时算起，理由是三国时候孙权曾经派军队到过台湾，但历史事实是“军士万人征夷州（即台湾），军行经岁，士众疾疫死者十有八九”，只俘虏了几千人回来，“得不偿失”。我们根据这条史料，就说台湾从三国时候起就是大陆王朝的领土，不是笑话吗？派了一支军队去，俘虏了几千人回来，这块土地就是孙吴的了？这跟清代沙俄殖民者派一支探险队在黑龙江某个地方劫掠一番，就宣称这个地方已归沙俄所有，有什么区别？ 有人也感到这样实在说不过去，于是又提出了所谓台澎一体论，这也是绝对讲不通的。我们知道，南宋时澎湖在福建泉州同安县辖境之内，元朝在岛上设立了巡检司，这是大陆王朝在澎湖岛上设立政权之始，这是靠得住的。有些同志主张“台澎一体”论，说是既然在澎湖设立了巡检司，可见元朝已管到了台湾，这怎么说得通？在那么小的澎湖列岛上设了巡检司，就会管到那么大的台湾？宋元明清时，一个县可以设立几个巡检司，这等于现在的公安分局或者是派出所。设在澎湖岛上的巡检司，它就能管辖整个台湾了？有什么证据呢？相反，我们有好多证据证明是管不到的。（台湾）为什么自古以来是中国的？因为历史演变的结果，到了清朝台湾是清帝国疆域的一部分。所以台湾岛上的土著民族——高山族是我们中华民族的一个组成部分，是我们中国的一个少数民族。对台湾我们应该这样理解，在明朝以前，台湾岛是由我们中华民族的成员之一高山族居住着的，他们自己管理自己，中原王朝管不到。到了明朝后期。才有大陆上的汉人跑到台湾岛的西海岸建立了汉人的政权。……一直到1683年（康熙二十二年），清朝平定台湾，台湾才开始同大陆属于一个政权。 但这种机械的、教条的观念根深蒂固，无处不在，以至在解释任何一个地方“自古以来”就属于中国时，总是采取“实用”甚至“歪曲”的态度，只讲一部分被认为是有利的事实，却完全不提相反的事实，使绝大多数人误以为自古以来都是如此。 例如新疆，只说公元前60年汉宣帝设立西域都护府，却不提及王莽时已经撤销，东汉时“三通三绝”，以后多数年代名存实亡，或者仅是部分恢复；只说唐朝打败突厥，控制整个西域地区，却不提及安史之乱后唐朝再未重返西域；只说蒙古征服西辽，却不提及元朝从未完全统治西域地区。事实上，中原王朝对西域的统治直到乾隆二十四年（1759年）才重新实现。对于清朝来说，西域的确是新纳的疆域，因此，才有“新疆”的命名。谭先生还以云南为例，虽然汉、晋时代是由中原王朝统治，但是，在南朝后期就脱离了中原王朝。隋唐时期，云南是中原王朝的羁縻地区，不是直辖地区。8世纪中叶以后，南诏依附吐蕃反唐，根本就脱离了唐朝。南诏以后成为大理。总之，从6世纪脱离中原王朝，经过了差不多700年，到13世纪才由元朝征服大理，云南地区又被中原王朝统治。 不过，谭先生特别强调：“我们认为18世纪中叶以后，1840年以前的中国范围是我们几千年来历史发展所自然形成的中国，这就是我们历史上的中国。至于现在的中国疆域，已经不是历史上自然形成的那个范围了，而是这一百多年来资本主义列强、帝国主义侵略宰割了我们的部分领土的结果，所以不能代表我们历史上的中国的疆域了”，“为什么说清朝的版图是历史发展自然形成的呢？而不是说清帝国扩张侵略的结果？因为历史事实的确是这样。……清朝以前，我们中原地区跟各个边疆地区关系长期以来就很密切了，不但经济、文化方面很密切，并且在政治上曾经几度和中原地区在一个政权统治之下。” 虽然作为谭先生的学生与助手，深切理解他无法突破政治底线的苦衷。他的上述说法在理论上存在着局限性，在实际上也存在着无法调和的矛盾：一方面，从秦朝最多300多万平方公里的疆域发展到清朝极盛时期1300多万平方公里的疆域，并不能一概称之为“自然形成”。我们不能因为中国最终形成了一个疆域辽阔的国家，就将历史上那些侵略扩张行为视为促进王朝统一、社会进步的必要手段。秦始皇征服岭南，汉武帝用兵闽粤，唐朝灭高句丽、高昌、薛延陀，蒙古人建立元朝，清朝灭明、平定准噶尔，客观上促成国家统一，为中国疆域最终形成奠定了有利条件。但是，这种侵略扩张行为本身，未必就有“自然”的正义性可言；另一方面，在尚未形成现代国际法和国际关系、不同国家民族平等观念之前，世界上能够生存和发展下来的国家，特别是葡、西、荷、英、法、德、日、美、加、澳等近代大国强国，无一不是侵略扩张的产物，中国岂能例外？1840年以前，中国疆域之所以保持稳定，一个重要的有利因素是地理环境的封闭性，以致在工业化以前的外部世界尚缺乏这种突破地理障碍的能力。尽管如此，唐朝军队在中亚受挫于阿拉伯军队，伊斯兰教在突厥语游牧民族的武力支持下侵入新疆地区取代佛教，葡萄牙人长期占据澳门，葡萄牙人、西班牙人、荷兰人相继占据台湾和澎湖，沙俄哥萨克闯进黑龙江流域烧杀抢掠，这也不能不说是国家竞争“自然”的结果。在中俄雅克萨之战并导致《尼布楚条约》签订后，清朝应该了解俄国人的真实意图，而且有足够的时间和能力移民实边，却继续实施对东北的封禁，以致俄国人进入黑龙江以北和乌苏里江以东如入无人之境，至今一些俄国学家还声称俄国人是这片”新土地的开发者”，而非中国领土的掠夺者。但在清朝对东北开禁，鼓励移民，设置府州县，建东三省后，俄国与日本尽管仍然积心积虑要占据东北，却未能得逞。这岂不也是自然的结果吗？ 顺化散记]]></content>
      <categories>
        <category>历史&amp;地理</category>
        <category>历史地理</category>
      </categories>
      <tags>
        <tag>历史地理</tag>
        <tag>葛剑雄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash Shell常用快捷键]]></title>
    <url>%2F2019%2F08%2F06%2Fbash-shortcuts%2F</url>
    <content type="text"><![CDATA[移动光标 ctrl+b: 前移一个字符(backward) ctrl+f: 后移一个字符(forward) alt+b: 前移一个单词 alt+f: 后移一个单词 ctrl+a: 移到行首（a是首字母） ctrl+e: 移到行尾（end） ctrl+xx: 行首到当前光标替换 编辑命令 alt+.: 粘帖最后一次命令最后的参数（通常用于mkdir long-long-dir后, cd配合着alt+.） alt+d: 删除当前光标到临近右边单词开始(delete) ctrl+w: 删除当前光标到临近左边单词结束(word) ctrl+h: 删除光标前一个字符（相当于backspace） ctrl+d: 删除光标后一个字符（相当于delete） ctrl+u: 删除光标左边所有 ctrl+k: 删除光标右边所有 ctrl+l: 清屏 ctrl+shift+c: 复制（相当于鼠标左键拖拽） ctrl+shift+v: 粘贴（相当于鼠标中键） 其它 ctrl+n: 下一条命令 ctrl+p: 上一条命令 alt+n: 下一条命令（例如输入ls, 然后按’alt+n’, 就会找到历史记录下的ls命令） alt+p: 上一条命令（跟alt+n相似） shift+PageUp: 向上翻页 shift+PageDown: 向下翻页 ctrl+r: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项 zsh d: 列出以前的打开的命令 j: jump到以前某个目录，模糊匹配]]></content>
      <categories>
        <category>linux命令</category>
        <category>Bash Shell快捷键</category>
      </categories>
      <tags>
        <tag>Bash Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim命令]]></title>
    <url>%2F2019%2F08%2F05%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[一般模式光标移动 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 20j 向下移动20行(以上四个命令可以配合数字使用)，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x w 前移一个单词，光标停在下一个单词开头 2w 重复执行w操作2次 W 移动下一个单词开头，但忽略一些标点 e 前移一个单词，光标停在下一个单词末尾 E 移动到下一个单词末尾，如果词尾有标点，则移动到标点 b 后移一个单词，光标停在上一个单词开头 B 移动到上一个单词开头，忽略一些标点 ( 前移1句 ) 后移1句 3) 光标移动到向下3句 { 前移1段 } 后移1段 f (find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符 F 同f，反向查找 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n&lt;space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n&lt;Enter&gt; n 为数字。光标向下移动 n 行(常用) 复制粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 一般模式切换到编辑模式 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ [Esc] 退出编辑模式，回到一般模式中(常用) 一般模式切换到指令行模式 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;在visual 模式下，这些命令很强大，其命令格式为 1&lt;action&gt;a&lt;object&gt;` 和 `&lt;action&gt;i&lt;object&gt; action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：&quot;、 &#39;、 )、 }、 ]。 假设你有一个字符串 (map (+) (&quot;foo&quot;)).而光标键在第一个 o的位置。 vi&quot; → 会选择 foo. va&quot; → 会选择 &quot;foo&quot;. vi) → 会选择 &quot;foo&quot;. va) → 会选择(&quot;foo&quot;). v2i) → 会选择 map (+) (&quot;foo&quot;) v2a) → 会选择 (map (+) (&quot;foo&quot;)) 块操作: &lt;C-v&gt;块操作，典型的操作： 0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC] ^ → 到行头 &lt;C-v&gt; → 开始块操作 &lt;C-d&gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I-- [ESC] → I是插入，插入“--”，按ESC键来为每一行生效。 自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了…… 参考资料 简明 VIM 练级攻略: https://coolshell.cn/articles/5426.html Vim使用笔记: https://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html Vim命令合集: https://www.jianshu.com/p/117253829581 ###]]></content>
      <categories>
        <category>linux命令</category>
        <category>vim命令</category>
      </categories>
      <tags>
        <tag>vim命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep命令]]></title>
    <url>%2F2019%2F08%2F05%2Fgrep-command%2F</url>
    <content type="text"><![CDATA[基本用法grep命令123456-c 统计包含匹配字符串的行数。-i 忽略字符大小写的差别。-v 反转查找。-o 只输出文件中匹配到的部分。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-r 递归查找。 GNU Grep用法 示例1grep "test[53]" jfedu.txt 以字符test开头，接5或者3的行]]></content>
      <categories>
        <category>linux命令</category>
        <category>grep命令</category>
      </categories>
      <tags>
        <tag>grep命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本命令]]></title>
    <url>%2F2019%2F08%2F05%2Flinux-command%2F</url>
    <content type="text"><![CDATA[sort: 排序sort 命令的用法很简单。最基本的用法有两种： 12cat data.txt | sortsort data.txt 选项： 12-r 倒序-f 忽略字母大小写 -k 指定用于排序的栏目范围，-t 指定栏目的分隔符。 以下实例，用:分割行，排序值从第3栏开始： 1234567$ sort -k 3 -t : sort.txtaaa:30:1.6bbb:10:2.5ccc:50:3.3ddd:20:4.2eee:60:5.1eee:40:5.4 uniq: 重复uniq 的作用可以描述为：针对相邻的重复行，进行相应的动作。 这句话中，有两个地方需要注意。首先，针对的是相邻的重复行。因此，uniq 对于不相邻的重复行是不起作用的。其次，进行相应的动作。这意味着，uniq 可以做的事情很多，不止一样。 不带任何参数的时候 uniq 的动作是：对相邻的重复行进行去除。例如： 1cat &lt;filename&gt; | sort | uniq 我们已经见过了 sort 的作用，那么上面命令的作用就很显然了：将 &lt;filename&gt; 按照 ASCII 升序排序；然后去除重复出现的行；最后将这个没有重复行的内容输出到标准输出。 给 uniq 加上参数，就能解锁更多姿势。 12345cat &lt;filename&gt; | sort | uniq -d # 只显示重复的行，每行只显示一次cat &lt;filename&gt; | sort | uniq -D # 只显示重复的行cat &lt;filename&gt; | sort | uniq -i # 忽略大小写cat &lt;filename&gt; | sort | uniq -u # 只显示只出现一次的行cat &lt;filename&gt; | sort | uniq -c # 统计每行重复的次数 xargs: 将标准输入转为命令行参数Unix有些命令可以接受”标准输入”（stdin）作为参数。 12&gt; $ cat /etc/passwd | grep root&gt; 上面的代码使用了管道命令（|）。管道命令的作用，是将左侧命令（cat /etc/passwd）的标准输出转换为标准输入，提供给右侧命令（grep root）作为参数。 但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，echo命令就不接受管道传参。 12&gt; $ echo "hello world" | echo&gt; 上面的代码不会有输出。因为管道右侧的echo不接受管道传来的标准输入作为参数。 xargs命令的作用，是将标准输入转为命令行参数。 123&gt; $ echo "hello world" | xargs echo&gt; hello world&gt; 上面的代码将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。 示例 查找所有后辍为txt的文件列表，然后进行grep: 1$ find . -name "*.txt" | xargs grep "abc" 由于xargs默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。 find命令有一个特别的参数-print0，指定输出的文件列表以null分隔。然后，xargs命令的-0参数表示用null当作分隔符。 1find . -type f -name "*.log" -print0 | xargs -0 rm -f 统计一个源代码目录中所有 php 文件的行数： 1find . -type f -name "*.php" -print0 | xargs -0 wc -l 查找所有的 jpg 文件，并且压缩它们： 1find . -type f -name "*.jpg" -print | xargs tar -czvf images.tar.gz]]></content>
      <categories>
        <category>linux命令</category>
        <category>linux基本命令</category>
      </categories>
      <tags>
        <tag>linux基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk用法]]></title>
    <url>%2F2019%2F08%2F05%2Fawk-syntax%2F</url>
    <content type="text"><![CDATA[基本用法1awk [options] 'pattern &#123;action&#125;' file... awk的工作过程是这样的：按行读取输入(标准输入或文件)，对于符合模式pattern的行，执行action。当pattern省略时表示匹配任何字符串；当action省略时表示执行&#39;{print}&#39;；它们不可以同时省略。 模式可以是以下任意一个： /正则表达式/：使用通配符的扩展集。 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符~(匹配) 和 ~!(不匹配)。 BEGIN语句块、pattern语句块、END语句块 每一行输入，对awk来说都是一条记录(record)，awk使用$0来引用当前记录： 12[root@centos7 ~]# head -1 /etc/passwd | awk '&#123;print $0&#125;'root:x:0:0:root:/root:/bin/bash 例子中将命令head -1 /etc/passwd作为awk的输入，awk省略了pattern，action为print $0，意为打印当前记录。对于每条记录，awk使用分隔符将其分割成列，第一列用$1表示，第二列用$2表示…最后一列用$NF表示 选项-F表示指定分隔符如输出文件/etc/passwd第一行第一列(用户名)和最后一列(登录shell)： 12[root@centos7 ~]# head -1 /etc/passwd | awk -F: '&#123;print $1,$NF&#125;'root /bin/bash 当没有指定分隔符时，使用一到多个blank(空白字符，由空格键或TAB键产生)作为分隔符。输出的分隔符默认为空格。如输出命令ls -l *的结果中，文件大小和文件名： 1234567[root@centos7 temp]# ls -l * | awk '&#123;print $5,$NF&#125;'13 b.txt58 c.txt12 d.txt0 e.txt0 f.txt24 test.sh 还可以对任意列进行过滤： 12[root@centos7 temp]# ls -l *|awk '$5&gt;20 &amp;&amp; $NF ~ /txt$/'-rw-r--r-- 1 nobody nobody 58 11月 16 16:34 c.txt 其中$5&gt;20表示第五列的值大于20；&amp;&amp;表示逻辑与；$NF ~ /txt$/中，~表示匹配，符号//内部是正则表达式。这里省略了action，整条awk语句表示打印文件大小大于20字节并且文件名以txt结尾的行。 awk用NR表示行号 123[root@centos7 temp]# awk '/^root/ || NR==2' /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin 例子中||表示逻辑或，语句表示：输出文件/etc/passwd中以root开头的行或者第二行。 在一些情况下，使用awk过滤甚至比使用grep更灵活如获得ifconfig的输出中网卡名及其对应的mtu值 12345[root@idc-v-71253 ~]# ifconfig|awk '/^\S/&#123;print $1"\t"$NF&#125;'ens32: 1500ens33: 1500lo: 65536#这里的正则表示不以空白字符开头的行，输出内容中使用\t进行了格式化。 以上所说的NR、NF等都是awk的内建变量，下面列出部分常用内置变量 12345678910$0 当前记录（这个变量中存放着整个行的内容）$1~$n 当前记录的第n个字段，字段间由FS分隔FS 输入字段分隔符 默认是空格或TabNF 当前记录中的字段个数，就是有多少列NR 行号，从1开始，如果有多个文件话，这个值也不断累加。FNR 输入文件行号RS 输入的记录分隔符， 默认为换行符OFS 输出字段分隔符， 默认也是空格ORS 输出的记录分隔符，默认为换行符FILENAME 当前输入文件的名字 awk中还可以使用自定义变量，如将网卡名赋值给变量a，然后输出网卡名及其对应的RX bytes的值(注意不同模式匹配及其action的写法)： 1234[root@idc-v-71253 ~]# ifconfig|awk '/^\S/&#123;a=$1&#125;/RX p/&#123;print a,$5&#125;'ens32: 999477100ens33: 1663197120lo: 0 awk中有两个特殊的pattern：BEGIN和END；它们不会对输入文本进行匹配，BEGIN对应的action部分组合成一个代码块，在任何输入开始之前执行；END对应的action部分组合成一个代码块，在所有输入处理完成之后执行。 12345678#注意类似于C语言的赋值及print函数用法[root@centos7 temp]# ls -l *|awk 'BEGIN&#123;print "size name\n---------"&#125;$5&gt;20&#123;x+=$5;print $5,$NF&#125;END&#123;print "---------\ntotal",x&#125;'size name---------58 c.txt24 test.sh---------total 82 再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列） 123456$ ps aux | awk &apos;NR!=1&#123;a[$1]+=$6;&#125; END &#123; for(i in a) print i &quot;, &quot; a[i]&quot;KB&quot;;&#125;&apos;dbus, 540KBmysql, 99928KBwww, 3264924KBroot, 63644KBhchen, 6020KB awk还支持数组，数组的索引都被视为字符串(即关联数组)，可以使用for循环遍历数组元素如输出文件/etc/passwd中各种登录shell及其总数量 1234567#注意数组赋值及for循环遍历数组的写法[root@centos7 temp]# awk -F ':' '&#123;a[$NF]++&#125;END&#123;for(i in a) print i,a[i]&#125;' /etc/passwd/bin/sync 1/bin/bash 2/sbin/nologin 19/sbin/halt 1/sbin/shutdown 1 当然也有if分支语句 123#注意大括号是如何界定action块的[root@centos7 temp]# netstat -antp|awk '&#123;if($6=="LISTEN")&#123;x++&#125;else&#123;y++&#125;&#125;END&#123;print x,y&#125;'6 3 pattern之间可以用逗号分隔，表示从匹配第一个模式开始直到匹配第二个模式 12345[root@centos7 ~]# awk '/^root/,/^adm/' /etc/passwd root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin 还支持三目操作符pattern1 ? pattern2 : pattern3，表示判断pattern1是否匹配，true则匹配pattern2，false则匹配pattern3，pattern也可以是类似C语言的表达式。如判断文件/etc/passwd中UID大于500的登录shell是否为/bin/bash，是则输出整行，否则输出UID为0的行： 12345#注意为避免混淆对目录分隔符进行了转义[root@centos7 ~]# awk -F: '$3&gt;500?/\/bin\/bash$/:$3==0 &#123;print $0&#125;' /etc/passwd root:x:0:0:root:/root:/bin/bashlearner:x:1000:1000::/home/learner:/bin/bash#三目运算符也可以嵌套，例子略 选项-f file表示从file中读取awk指令 1234567891011121314#打印斐波那契数列前十项[root@centos7 temp]# cat test.awk BEGIN&#123; $1=1 $2=1 OFS="," for(i=3;i&lt;=10;i++) &#123; $i=$(i-2)+$(i-1) &#125; print&#125;[root@centos7 temp]# awk -f test.awk 1,1,2,3,5,8,13,21,34,55 选项-F指定列分隔符 1234#多个字符作为分隔符时[root@centos7 temp]# echo 1.2,3:4 5|awk -F '[., :]' '&#123;print $2,$NF&#125;'2 5#这里-F后单引号中的内容也是正则表达式 选项-v var=val设定变量 1234567#这里printf函数用法类似C语言同名函数[root@centos7 ~]# awk -v n=5 'BEGIN&#123;for(i=0;i&lt;n;i++) printf "%02d\n",i&#125;' 0001020304 print等函数还支持使用重定向符&gt;和&gt;&gt;将输出保存至文件 1234567#如按第一列(IP)分类拆分文件access.log，并保存至ip.txt文件中[root@centos7 temp]# awk '&#123;print &gt; $1".txt"&#125;' access.log [root@centos7 temp]# ls -l 172.20.71.*-rw-r--r-- 1 root root 5297 11月 22 21:33 172.20.71.38.txt-rw-r--r-- 1 root root 1236 11月 22 21:33 172.20.71.39.txt-rw-r--r-- 1 root root 4533 11月 22 21:33 172.20.71.84.txt-rw-r--r-- 1 root root 2328 11月 22 21:33 172.20.71.85.txt 内建函数length()获得字符串长度 12[root@centos7 temp]# awk -F: '&#123;if(length($1)&gt;=16)print&#125;' /etc/passwd systemd-bus-proxy:x:999:997:systemd Bus Proxy:/:/sbin/nologin split()将字符串按分隔符分隔，并保存至数组 12345678[root@centos7 temp]# head -1 /etc/passwd|awk '&#123;split($0,arr,/:/);for(i=1;i&lt;=length(arr);i++) print arr[i]&#125;'rootx00root/root/bin/bash getline从输入(可以是管道、另一个文件或当前文件的下一行)中获得记录，赋值给变量或重置某些环境变量 1234567891011121314151617181920212223#从shell命令date中通过管道获得当前的小时数[root@centos7 temp]# awk 'BEGIN&#123;"date"|getline;split($5,arr,/:/);print arr[1]&#125;'09#从文件中获取，此时会覆盖当前的$0。(注意逐行处理b.txt的同时也在逐行从c.txt中获得记录并覆盖$0，当getline先遇到eof时&lt;即c.txt文件行数较少&gt;将输出空行)[root@centos7 temp]# awk '&#123;getline &lt;"c.txt";print $4&#125;' b.txt "https://segmentfault.com/blog/learnning"[root@centos7 temp]# #赋值给变量[root@centos7 temp]# awk '&#123;getline blog &lt;"c.txt";print $0"\n"blog&#125;' b.txt aasdasdadsadBLOG ADDRESS IS "https://segmentfault.com/blog/learnning"[root@centos7 temp]# #读取下一行(也会覆盖当前$0)[root@centos7 temp]# cat fileanny100bob150cindy120[root@centos7 temp]# awk '&#123;getline;total+=$0&#125;END&#123;print total&#125;' file370#此时表示只对偶数行进行处理 next作用和getline类似，也是读取下一行并覆盖$0，区别是next执行后，其后的命令不再执行，而是读取下一行从头再执行。 123456789101112131415161718192021#跳过以a-s开头的行，统计行数，打印最终结果[root@centos7 temp]# awk '/^[a-s]/&#123;next&#125;&#123;count++&#125;END&#123;print count&#125;' /etc/passwd2[root@centos7 temp]# #又如合并相同列的两个文件[root@centos7 temp]# cat f.txt 学号 分值00001 8000002 7500003 90[root@centos7 temp]# cat e.txt 姓名 学号张三 00001李四 00002王五 00003[root@centos7 temp]# awk 'NR==FNR&#123;a[$1]=$2;next&#125;&#123;print $0,a[$2]&#125;' f.txt e.txt 姓名 学号 分值张三 00001 80李四 00002 75王五 00003 90#这里当读第一个文件时NR==FNR成立，执行a[$1]=$2，然后next忽略后面的。读取第二个文件时，NR==FNR不成立，执行后面的打印命令 sub(regex,substr,string)替换字符串string(省略时为$0)中首个出现匹配正则regex的子串substr 12[root@centos7 temp]# echo 178278 world|awk 'sub(/[0-9]+/,"hello")'hello world gsub(regex,substr,string)与sub()类似，但不止替换第一个，而是全局替换 123456[root@centos7 temp]# head -n5 /etc/passwd|awk '&#123;gsub(/[0-9]+/,"----");print $0&#125;' root:x:----:----:root:/root:/bin/bashbin:x:----:----:bin:/bin:/sbin/nologindaemon:x:----:----:daemon:/sbin:/sbin/nologinadm:x:----:----:adm:/var/adm:/sbin/nologinlp:x:----:----:lp:/var/spool/lpd:/sbin/nologin substr(str,n,m)切割字符串str，从第n个字符开始，切割m个。如果m省略，则到结尾 12[root@centos7 temp]# echo "hello,世界！"|awk '&#123;print substr($0,8,1)&#125;'界 tolower(str)和toupper(str)表示大小写转换 12[root@centos7 temp]# echo "hello,世界！"|awk '&#123;A=toupper($0);print A&#125;'HELLO,世界！ system(cmd)执行shell命令cmd，返回执行结果，执行成功为0，失败为非0 123#此处if语句判断和C语言一致，0为false，非0为true[root@centos7 temp]# awk 'BEGIN&#123;if(!system("date&gt;/dev/null"))print "success"&#125;'success match(str,regex)返回字符串str中匹配正则regex的位置 12[root@centos7 temp]# awk 'BEGIN&#123;A=match("abc.f.11.12.1.98",/[0-9]&#123;1,3&#125;\./);print A&#125;'7 示例 条件统计 1awk '$2&gt;=6 &amp;&amp; $2&lt;20 &#123; tot++ &#125; END &#123; print +tot&#125;' 花式用法 12345#按连接数查看客户端IPnetstat -ntu | awk '&#123;print $5&#125;' | cut -d: -f1 | sort | uniq -c | sort -nr #打印99乘法表seq 9 | sed 'H;g' | awk -v RS='' '&#123;for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")&#125;']]></content>
      <categories>
        <category>linux命令</category>
        <category>awk命令</category>
      </categories>
      <tags>
        <tag>awk命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F08%2F05%2Fregexp-syntax%2F</url>
    <content type="text"><![CDATA[元字符 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 常用正则表达式收集 最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等 常用正则表达式 - 收集一些在平时项目开发中经常用到的正则表达式]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[paxos精髓及示例]]></title>
    <url>%2F2019%2F07%2F31%2Fpaxos-essence-and-demo%2F</url>
    <content type="text"><![CDATA[Paxos精髓paxos协议用来解决的问题可以用一句话来简化: proposer将发起提案（value）给所有accpetor，超过半数accpetor获得批准后，proposer将提案写入accpetor内，最终所有accpetor获得一致性的确定性取值，且后续不允许再修改。 协议分为两大阶段，每个阶段又分为a/b两小步骤： 准备阶段（占坑阶段）Phase 1a: PrepareProposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。 Phase 1b: PromiseAcceptor接收到Prepare（n）请求，若提议编号n比之前接收的Prepare请求都要大，则承诺将不会接收提议编号比n小的提议，并且带上之前Accept的提议中编号小于n的最大的提议，否则不予理会。 接受阶段（提交阶段）Phase 2a: Accept​ 1. 如果未超过半数accpetor响应，直接转为提议失败； ​ 2. 如果超过多数Acceptor的承诺，又分为不同情况： ​ 2.1 如果所有Acceptor都未接收过值（都为null），那么向所有的Acceptor发起自己的值和提议编号n，记住，一定是所有Acceptor都没接受过值； ​ 2.2 如果有部分Acceptor接收过值，那么从所有接受过的值中选择对应的提议编号最大的作为提议的值，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则； Phase 2b: AcceptedAcceptor接收到提议后，如果该提议版本号不等于自身保存记录的版本号（第一阶段记录的），不接受该请求，相等则写入本地。 整个paxos协议过程看似复杂难懂，但只要把握和理解这两点就基本理解了paxos的精髓： 理解第一阶段accpetor的处理流程：如果本地已经写入了，不再接受和同意后面的所有请求，并返回本地写入的值；如果本地未写入，则本地记录该请求的版本号，并不再接受其他版本号的请求，简单来说只信任最后一次提交的版本号的请求，使其他版本号写入失效； 理解第二阶段proposer的处理流程：未超过半数accpetor响应，提议失败；超过半数的accpetor值都为空才提交自身要写入的值，否则选择非空值里版本号最大的值提交，最大的区别在于是提交的值是自身的还是使用以前提交的。 Basic Paxos信息流协议过程举例看这个最简单的例子：1个processor，3个Acceptor，无learner。 目标：proposer向3个aceptort 将name变量写为v1。 第一阶段A：proposer发起prepare（name，n1）,n1是递增提议版本号，发送给3个Acceptor，说，我现在要写name这个变量，我的版本号是n1第一阶段B：Acceptor收到proposer的消息，比对自己内部保存的内容，发现之前name变量（null，null）没有被写入且未收到过提议，都返回给proposer，并在内部记录name这个变量，已经有proposer申请提议了，提议版本号是n1;第二阶段A：proposer收到3个Acceptor的响应，响应内容都是：name变量现在还没有写入，你可以来写。proposer确认获得超过半数以上Acceptor同意，发起第二阶段写入操作：accept（v1,n1），告诉Acceptor我现在要把name变量协议v1,我的版本号是刚刚获得通过的n1;第二阶段B：accpetor收到accept（v1,n1），比对自身的版本号是一致的，保存成功，并响应accepted（v1,n1）；结果阶段：proposer收到3个accepted响应都成功，超过半数响应成功，到此name变量被确定为v1。 以上是正常的paxos协议提议确定流程，是不是很简单，很容易理解呢？ 确定你理解了上面的例子再往后看。 这是最简单也最容易理解的例子，但真实情况远比这个复杂，还有以下问题： 如果其中的某个Acceptor没响应怎么处理？如果只写成功了一个accpetor又怎么处理，写成功两个呢？如果多个proposer并发写会导致accpetor写成不同值吗？learner角色是做什么用？为什么是超过半数同意？ paxos特殊情况下的处理第一种情况：Proposer提议正常，未超过accpetor失败情况 问题：还是上面的例子，如果第二阶段B，只有2个accpetor响应接收提议成功，另外1个没有响应怎么处理呢？ 处理：proposer发现只有2个成功，已经超过半数，那么还是认为提议成功，并把消息传递给learner，由learner角色将确定的提议通知给所有accpetor，最终使最后未响应的accpetor也同步更新，通过learner角色使所有Acceptor达到最终一致性。 第二种情况：Proposer提议正常，但超过accpetor失败情况 问题：假设有2个accpetor失败，又该如何处理呢？ 处理：由于未达到超过半数同意条件，proposer要么直接提示失败，要么递增版本号重新发起提议，如果重新发起提议对于第一次写入成功的accpetor不会修改，另外两个accpetor会重新接受提议，达到最终成功。 情况再复杂一点：还是一样有3个accpetor，但有两个proposer。 情况一：proposer1和proposer2串行执行 proposer1和最开始情况一样，把name设置为v1，并接受提议。 proposer1提议结束后，proposer2发起提议流程： 第一阶段A：proposer1发起prepare（name，n2） 第一阶段B：Acceptor收到proposer的消息，发现内部name已经写入确定了，返回（name,v1,n1） 第二阶段A：proposer收到3个Acceptor的响应，发现超过半数都是v1，说明name已经确定为v1，接受这个值，不再发起提议操作。 情况二：proposer1和proposer2交错执行 proposer1提议accpetor1成功，但写入accpetor2和accpetor3时，发现版本号已经小于accpetor内部记录的版本号（保存了proposer2的版本号），直接返回失败。 proposer2写入accpetor2和accpetor3成功，写入accpetor1失败，但最终还是超过半数写入v2成功，name变量最终确定为v2； proposer1递增版本号再重试发现超过半数为v2，接受name变量为v2，也不再写入v1。name最终确定还是为v2 情况三：proposer1和proposer2第一次都只写成功1个Acceptor怎么办 都只写成功一个，未超过半数，那么Proposer会递增版本号重新发起提议，这里需要分多种情况： 3个Acceptor都响应提议，发现Acceptor1{v1,n1} ,Acceptor2{v2,n2},Acceptor{null,null}，Processor选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 2个Acceptor都响应提议， 如果是Acceptor1{v1,n1} ,Acceptor2{v2,n2}，那么选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 如果是Acceptor1{v1,n1} ,Acceptor3{null,null}，那么选择最大的{v1,n1}发起第二阶段，成功后name值为v1; 如果是Acceptor2{v2,n2} ,Acceptor3{null,null}，那么选择最大的{v2,n2}发起第二阶段，成功后name值为v2; 只有1个Acceptor响应提议，未达到半数，放弃或者递增版本号重新发起提议可以看到，都未达到半数时，最终值是不确定的！ 参考资料 paxos算法wiki: https://en.wikipedia.org/wiki/Paxos_(computer_science)#Basic_Paxos 首先，推荐的是知行学社的《分布式系统与Paxos算法视频课程》： 视频讲的非常好，很适合入门，循序渐进慢慢推导，我自己看了不下5遍，视频讲解理解更深，推荐大家都看看。 推荐刘杰的《分布式系统原理介绍》 ，里面有关于paxos的详细介绍，例子非常多，也有包括paxos协议的证明过程，大而全，质量相当高的一份学习资料！ 推荐的一份高质量ppt《可靠分布式系统基础 Paxos 的直观解释》: https://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html； 技术类的东西怎么能只停留在看上面，肯定要看代码啊，推荐微信开源的phxpaxos：https://github.com/tencent-wechat/phxpaxos，结合代码对协议理解更深。 《Paxos Made live》。这篇论文是 Google 发表的，讨论了 paxos 的工程实践，也就是 chubby 这个众所周知的分布式服务的实现，可以结合《The Chubby lock service for loosely-coupled distributed systems》 一起看。实际应用中的难点，比如 master 租约实现、group membership 变化、Snapshot 加快复制和恢复以及实际应用中遇到的故障、测试等问题，特别是最后的测试部分。非常值得一读。《The Chubby lock service for loosely-coupled distributed systems》 更多介绍了 Chubby 服务本身的设计决策，为什么是分布式锁服务，为什么是粗粒度的锁，为什么是目录文件模式，事件通知、多机房部署以及应用碰到的使用问题等等。 Paxos 我还着重推荐阅读微信后端团队写的系列博客，包括他们开源的 phxpaxos 实现，基本上将所有问题都讨论到了，并且通俗易懂。 一致性方面另一块就是 Raft 算法，按照 Google Chubby 论文里的说法， 1`Indeed, all working protocols for asynchronous consensus we have so far encountered have Paxos at their core.` 但是 Raft 真的好理解多了，我读的是《In Search of an Understandable Consensus Algorithm》，论文写到这么详细的步骤，你不想理解都难。毕竟 Raft 号称就是一个 Understandable Consensus Algorithm。无论从任何角度，都推荐阅读这一篇论文。 首先能理解 paxos 的一些难点，其次是了解 Raft 的实现，加深对 Etcd 等系统的理解。这篇论文还有一个 250 多页的加强版《CONSENSUS: BRIDGING THEORY AND PRACTICE》，教你一行一行写出一个 Raft 实现，我还没有学习，有兴趣可以自行了解。Raft 通过明确引入 leader（其实 multi paxos 引申出来也有，但是没有这么明确的表述）来负责 client 交互和日志复制，将整个算法过程非常清晰地表达出来。Raft 的算法正确性的核心在于保证 Leader Completeness ，选举算法选出来的 leader 一定是包含了所有 committed entries 的，这是因为所有 committed entries 一定会在多数派至少一个成员里存在，所以设计的选举算法一定能选出来这么一个成员作为 leader。多数派 accept 应该说是一致性算法正确性的最重要的保证。 最后，我还读了《Building Consistent Transactions with Inconsistent Replication》，包括作者的演讲，作者也开放了源码。Google Spanner 基本是将 paxos 算法应用到了极致，但是毕竟不是所有公司都是这么财大气粗搞得起 TrueTime API，架得起全球机房，控制或者承受得了事务延时。这篇论文提出了另一个思路，论文介绍的算法分为两个层次： IR 和基于其他上的 TAPIR。前者就是 Inconsistent Replication，它将操作分为两类： inconsistent： 可以任意顺序执行，成功执行的操作将持久化，支持 failover。 consensus：同样可以任意顺序执行并持久化 failover，但是会返回一个唯一的一致(consensus)结果。 Java简单实现Basic Paxos算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249/** * Alipay.com Inc. * Copyright (c) 2004-2019 All Rights Reserved. */package paxos;import com.google.common.base.Charsets;import org.apache.commons.lang3.StringUtils;import com.google.common.hash.HashFunction;import com.google.common.hash.Hashing;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.Random;/** * @author xbyan * @version $Id: PaxosStudy.java, v 0.1 2019-07-01 5:47 PM xbyan Exp $$ */public class PaxosStudy &#123; private static final HashFunction HASH_FUNCTION = Hashing.murmur3_32(); private static final Random RAMDOM = new Random(); private static final String[] PROPOSALS = &#123; "ProjectA", "ProjectB", "ProjectC" &#125;; public static void main(String[] args) throws InterruptedException &#123; //新建server组 List&lt;Acceptor&gt; acceptors = new ArrayList&lt;&gt;(); Arrays.asList("A", "B", "C", "D", "E").forEach(name -&gt; acceptors.add(new Acceptor(name))); //开始投票 Proposer.vote(new Proposal(1L, null), acceptors); &#125; private static void printInfo(String subject, String operation, String result) throws InterruptedException &#123; System.out.println(subject + ":" + operation + "&lt;" + result + "&gt;"); Thread.sleep(1000); &#125; /** * 对于提案的约束，第三方约束要求 * 如果maxVote不存在，那么没有限制，下一次表决可以使用任意提案 * 否则，下一次表决要沿用maxVote提案 * * @param currentVoteNumber * @param proposals * @return */ private static Proposal nextProposal(long currentVoteNumber, List&lt;Proposal&gt; proposals) &#123; long voteNumber = currentVoteNumber + 1; //刚开始投票 if (proposals.isEmpty()) &#123; Proposal proposal = new Proposal(voteNumber, PROPOSALS[RAMDOM.nextInt(PROPOSALS.length)]); System.out.println("NEXT PROPOSER(刚开始投票), currentVoteNumber" + currentVoteNumber + ",proposal=" + proposal); return proposal; &#125; //为之前的票排序 Collections.sort(proposals); Proposal maxVote = proposals.get(proposals.size() - 1); //列表里最大值 long maxVoteNumber = maxVote.getVoteNumber(); String content = maxVote.getContent(); if (maxVoteNumber &gt;= currentVoteNumber) &#123; throw new IllegalStateException("illegal state maxVoteNumber"); &#125; if (content != null) &#123; Proposal proposal = new Proposal(voteNumber, content); System.out.println("NEXT PROPOSER(content不为空), voteNumber=" + voteNumber + ",proposal=" + proposal + ",maxVote=" + maxVote); return proposal; &#125; else &#123; Proposal proposal = new Proposal(voteNumber, PROPOSALS[RAMDOM.nextInt(PROPOSALS.length)]); System.out.println("NEXT PROPOSER(content为空), voteNumber=" + voteNumber + ",proposal=" + proposal + ",maxVote=" + maxVote); return proposal; &#125; &#125; private static class Proposer &#123; /** * @param proposal * @param acceptors */ public static void vote(Proposal proposal, Collection&lt;Acceptor&gt; acceptors) throws InterruptedException &#123; //法定人数 n/2+1 int quorum = Math.floorDiv(acceptors.size(), 2) + 1; System.out.println("quorum " + quorum); int count = 0; while (true) &#123; //开始投票 printInfo("VOTE_ROUND", "START", ++count + "：开始向acceptor发送信息"); List&lt;Proposal&gt; proposals = new ArrayList&lt;&gt;(); for (Acceptor acceptor : acceptors) &#123; Promise promise = acceptor.onPrepare(proposal); if (promise != null &amp;&amp; promise.isAck()) &#123; //Acceptor批准后就可以将发起者加入发起者列表里 System.out .println("--------------------------------------------------ACCEPTOR批准,将发起者加入队列里,proposal=" + promise.getProposal()); proposals.add(promise.getProposal()); &#125; &#125; if (proposals.size() &lt; quorum) &#123; //小于法定人数 printInfo("PROPOSER[" + proposal + "]", "VOTE", "NOT PREPARED：接收到消息的acceptor小于半数"); System.out.println("onPrepare阶段编号增加 重新发起投票"); proposal = nextProposal(proposal.getVoteNumber(), proposals); continue; &#125; System.out.println("接收到消息的acceptor大于半数，开始提案内容"); int acceptCount = 0; for (Acceptor acceptor1 : acceptors) &#123; if (acceptor1.onAccept(proposal)) acceptCount++; &#125; if (acceptCount &lt; quorum) &#123; printInfo("PROPOSER[" + proposal + "]", "VOTE", "NOT ACCEPTED,接受提案的少于半数"); System.out.println("onAccept阶段编号增加 重新发起投票"); proposal = nextProposal(proposal.getVoteNumber(), proposals); continue; &#125; break; &#125; printInfo("PROPOSER[" + proposal + "]", "VOTE", "SUCCESS，接受提案成功"); &#125; &#125; private static class Acceptor &#123; //上次表决结果 private Proposal last = new Proposal(); private String name; public Acceptor(String name) &#123; this.name = name; &#125; public Promise onPrepare(Proposal proposal) throws InterruptedException &#123; //假设这个过程有50%的几率失败 if (Math.random() - 0.5 &gt; 0) &#123; printInfo("ACCEPTER_" + name, "PREPARE", "NO RESPONSE 向" + name + " 发送失败"); return null; &#125; if (proposal == null) throw new IllegalArgumentException("null proposal"); //大于 if (proposal.getVoteNumber() &gt; last.getVoteNumber()) &#123; Promise response = new Promise(true, last); last = proposal; printInfo("ACCEPTER_" + name, "PREPARE", "OK " + name + " 记下编号，返回信息,last=" + last); return response; &#125; else &#123; printInfo("ACCEPTER_" + name, "PREPARE", "REJECTED " + name + " 已保存有选定的编号，拒绝"); return new Promise(false, null); &#125; &#125; public boolean onAccept(Proposal proposal) throws InterruptedException &#123; //假设这个过程有50%的几率失败 if (Math.random() - 0.5 &gt; 0) &#123; printInfo("ACCEPTER_" + name, "ACCEPT", "NO RESPONSE " + name + " 发送提案失败"); return false; &#125; boolean accepted = last.equals(proposal); printInfo("ACCEPTER_" + name, "ACCEPT", name + (accepted ? "OK：通过" : "NO: 不通过") + "last=" + last + ",proposal=" + proposal); return accepted; &#125; &#125; private static class Promise &#123; private final boolean ack; private final Proposal proposal; private Promise(boolean ack, Proposal proposal) &#123; this.ack = ack; this.proposal = proposal; &#125; public boolean isAck() &#123; return ack; &#125; public Proposal getProposal() &#123; return proposal; &#125; &#125; private static class Proposal implements Comparable&lt;Proposal&gt; &#123; private final long voteNumber; private final String content; public Proposal(long voteNumber, String content) &#123; this.voteNumber = voteNumber; this.content = content; &#125; public Proposal() &#123; this(0, null); &#125; public long getVoteNumber() &#123; return voteNumber; &#125; public String getContent() &#123; return content; &#125; public int compareTo(Proposal o) &#123; return Long.compare(voteNumber, o.voteNumber); &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; if (!(obj instanceof Proposal)) return false; Proposal proposal = (Proposal) obj; return voteNumber == proposal.voteNumber &amp;&amp; StringUtils.equals(content, proposal.content); &#125; @Override public int hashCode() &#123; return HASH_FUNCTION.newHasher().putLong(voteNumber).putString(content, Charsets.UTF_8) .hash().asInt(); &#125; @Override public String toString() &#123; return new StringBuilder().append(voteNumber).append(':').append(content).toString(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>分布式一致性</category>
        <category>paxos算法</category>
      </categories>
      <tags>
        <tag>paxos</tag>
        <tag>分布式一致性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[paxos-by-example]]></title>
    <url>%2F2019%2F07%2F29%2Fpaxos-by-example%2F</url>
    <content type="text"><![CDATA[Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。 网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文Paxos Made Simple，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。 Paxos是什么 Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。 Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。 虽然Mike Burrows说得有点夸张，但是至少说明了Paxos算法的地位。然而，Paxos算法也因为晦涩难懂而臭名昭著。本文的目的就是带领大家深入浅出理解Paxos算法，不仅理解它的执行流程，还要理解算法的推导过程，作者是怎么一步步想到最终的方案的。只有理解了推导过程，才能深刻掌握该算法的精髓。而且理解推导过程对于我们的思维也是非常有帮助的，可能会给我们带来一些解决问题的思路，对我们有所启发。 最近在看paxos算法, 看了不少博客, 都感觉总结得不够到位,甚至有理解偏差的地方,倒是在博客的引用文章里面找到了一篇英文文献,看完后豁然开朗茅塞顿开. 于是把那篇英文原文翻译了一下, 加深一下理解 英文文献虽是2012年的了, 但是短小精悍,值得一看,原文地址是: angus.nyc/2012/paxos-by-example/ 文章中不全是直译, 有些地方改成了我自己的理解, 所以有可能有理解错的地方, 还望指出. 关于作者: Lamport提到Paxos算法，我们不得不首先来介绍下Paxos算法的作者Leslie Lamport(莱斯利·兰伯特, http://www.lamport.org )及其对计算机科学尤其是分布式计算领域的杰出贡献。作为2013年的新科图灵奖得主，Lamport是计算机科学领域一位拥有杰出成就的传奇人物，其先后多次荣获ACM和IEEE以及其他各类计算机重大奖项。Lamport对时间时钟、面包店算法、拜占庭将军问题以及Paxos算法的创造性研究，极大地推动了计算机科学尤其是分布式计算的发展，全世界无数工程师得益于他的理论，其中Paxos算法的提出，正是Lamport多年的研究成果。 说起Paxos理论的发表，还有一段非常有趣的历史故事。Lamport早在1990年就已经将其对Paxos算法的研究论文《The PartTime Parliament》提交给ACM TOCS Jnl.的评审委员会了，但是由于Lamport“创造性”地使用了故事的方式来进行算法的描述，导致当时委员会的工作人员没有一个能够正确地理解他对算法的描述，时任主编要求Lamport使用严谨的数据证明方式来描述该算法，否则他们将不考虑接受这篇论文。遗憾的是，Lamport并没有接收他们的建议，当然也就拒绝了对论文的修改，并撤销了对这篇论文的提交。在后来的一个会议上，Lamport还对此事耿耿于怀：“为什么这些搞理论的人一点幽默感也没有呢？” 幸运的是，还是有人能够理解Lamport那公认的令人晦涩的算法描述的。1996年，来自微软的Butler Lampson在WDAG96上提出了重新审视这篇分布式论文的建议，在次年的WDAG97上，麻省理工学院的Nancy Lynch也公布了其根据Lamport的原文重新修改后的《Revisiting the Paxos Algorithm》，“帮助”Lamport用数学的形式化术语定义并证明了Paxos算法。于是在1998年的ACM TOCS上，这篇延迟了9年的论文终于被接受了，也标志着Paxos算法正式被计算机科学接受并开始影响更多的工程师解决分布式一致性问题。 后来在2001年，Lamport本人也做出了让步，这次他放弃了故事的描述方式，而是使用了通俗易懂的语言重新讲述了原文，并发表了《Paxos Made Simple》——当然，Lamport甚为固执地认为他自己的表述语言没有歧义，并且也足够让人明白Paxos算法，因此不需要数学来协助描述，于是整篇文章还是没有任何数学符号。好在这篇文章已经能够被更多的人理解，相信绝大多数的Paxos爱好者也都是从这篇文章开始慢慢进入了Paxos的神秘世界。 由于Lamport个人自负固执的性格，使得Paxos理论的诞生可谓一波三折。关于Paxos理论的诞生过程，后来也成为了计算机科学领域被广泛流传的学术趣事。 图0: Lamport本尊 译文开始本文通过一个实例描述了一个叫Paxos的分布式一致性算法 分布式一致性算法通常是用于让多个计算机节点就某个单值的修改达成一致, 例如事务的提交commit或回滚rollback, 典型的思想就是二阶段提交或三阶段提交. 算法并不关心这个单值是什么,只关心最后只有唯一一个值被所有的节点选中, 对该值的修改达成一致 在一个分布式系统中这非常的难, 因为不同机器之前的消息可能会丢失, 或是被无限延迟, 甚至机器本身也会挂掉 Paxos算法可以保证最终只会有一个值会被选中, 但是不能保证如果集群中的大多数节点挂掉后,还能选中一个值 概述Paxos的节点可以是proposer, acceptor,learner中的任何一种角色.proposer会提议一个它想被采纳的值, 一般是通过发送一个包含该提议值的提案给集群中的每个acceptor. 然后acceptor会独立的决定是否接受这个提案–它可能会接收到多个proposer的不同提案, 决定好后会把它的决定发给learner. learner的作用是判断一个值是否已经被接受.在Paxos算法中, 只有一个值被大多数的acceptor选中, 才算被Paxos算法选中.在实际项目中, 一个节点可能担任多种角色, 但是在这个例子里面, 每一种角色都是一个独立的节点. 图1 Paxos的基本架构. 几个proposer向acceptor提交提案. 当一个acceptor接受了一个值后, 它把它的决定发给learner Paxos算法例子在标准的Paxos算法中, 一个proposer会发送两种类型的消息给acceptors: prepare request 和accept request. 在算法的第一阶段, proposer会发送一个prepare request给每一个acceptor, 这个prepare request包含一个提议值value和一个提案号number.每一个proposer的提案号number必须是正数, 单调递增的,独一无二的自然数[1]. 在下面图2的例子中, 有两个proposer, 都在发送prepare request. proposer A的请求([n=2,v=8])比proposer B的请求([n=4,v=5])先到达acceptor X和acceptor Y, 而proposer B的请求先到达acceptor Z 图2: Paxos. proposer A和B各发送了一个prepare request 给每一个accetor. 在这个例子中, proposer A的请求先到达acceptor X和Y, 而proposer B的请求先到达了acceptor Z. 如果一个acceptor接收到了一个prepare request而又没接收过其他的提案, 这个acceptor会回应一个prepare response, 并保证不会接受其他比当前提案号number更小的提案. 下面图3展示了每个acceptor是如何响应它们接收到的prepare request的 图3: 每个acceptor都对它接收到的第一个prepare request 进行prepare response. 最终, acceptor Z接收到了proposer A的请求[2], acceptor X和Y收到了proposer B的请求. 如果一个acceptor之前已经接收了一个提案号更高的prepare request的话, 那么后面收到的prepare request就会被忽略, 这个例子中就是acceptor Z会忽略掉proposer A的请求(Z已经接收了B的提案n=4). 如果acceptor之前没有接收过更高提案号的提案, 它会保证忽略其他提案号比这个更低的请求(注意是包括prepare request和accept request),然后在prepare response中把它已经选中的提案号最高的提议(包括这个提议的值)发送给proposer.在这个例子就是acceptor X和Y给proposer B的响应(X和Y已经接受了一个B的[n=2,v=8]的提案,当再收到[n=4, v=5]的提案时, 它保证会忽略任何n&lt;4的prepare request和accept request, 然后把[n=2, v=8]的prepare response回去给B) 图4: acceptor Z 忽略了proposer A的请求, 因为它已经接收到了更高的提议号(4 &gt; 2). acceptor X和Y给proposer B响应了它见过最高的提议号的提案, 并承诺会忽略提案号更小的提案 一旦proposer 收到了大多数acceptor的prepare response, 它就可以开始给所有的acceptor发送accept request了. 因为proposer A接收到prepare response中表明在它之前没有更早的提案. 所以它的accept request中的提案号和提议值都是跟prepare request中的一样.然而,这个accept request被所有的acceptor都拒绝了,因为它们都承诺了不会接收提议号比4更新的提案(因为都见过proposer B的提案了) Proposer B的accept request情况就跟proposer A的有所不同了. 首先它的提案号还是它之前的提案号(n=4), 但是提议值却不是它之前的提议值了(它之前提议的是v=5), 而是它在prepare response中接收到的提议值(v=8)[3] 图5: proposer B也发送了一个accept request给每一个acceptor.acceptor request中的提案号是它之前的提案号(4), 而提议值是它在prepare response中收到的值(8, 来自proposer A的提案[n=2, v=8]) 如果acceptor收到了一个提案号不小于它见过的accept request, 它会接受这个accept request并且发送一个通知给到learner节点. 当learner节点发现大多数acceptor都已经接受了一个值的时候,Paxos算法就认为这个值已经被选中. 当一个值被paxos选中后,后续的流程中将不能改变这个值.例如,当另一个proposer C发送一个提案号更高的prepare request(例如, [n=6, v=7])过来时,所有的acceptor都会响应它之前已经选中的提议(n=4,v=8).这会要求proposer C在后续的acceptor request中也只能发送[n=6, v=8]的提议, 即只能确认一遍已经选中的这个值. 再后面, 如果有少量的acceptor还没选中一个值的话, 这个流程会保证最终所有的节点都会一致地选中同一个值. 译文结束 提案号的唯一性的保证不是Paxos算法的内容 ↩︎ 这个也可能不会发送, 但是这个算法中也是有可能的 ↩︎ 注意这个是它从prepare response中收到的最高的提案号. 在这个例子中, proposer B的提案号(n=4)是比proposer A的提案号(n=2)大. 但是在它的prepare request的响应中, 它只收到了proposer A的提议([n=2, v=8]). 如果它在prepare response中没有收到其他的提案的话, 它就会发送自己的提案([n=4,v=5]) ↩︎ 参考资料 NEAT ALGORITHMS - PAXOS(小动画可以辅助读懂): http://harry.me/blog/2014/12/27/neat-algorithms-paxos/ paxos-by-example(通过一个例子理解paxos算法): https://juejin.im/post/5d159590f265da1b86089a89 Paxos Made Live: an amazing paper from Google describing the challenges of their Paxos implementation in Chubby: http://static.googleusercontent.com/media/research.google.com/en//archive/paxos_made_live.pdf A Quora thread explaining Paxos in a few different ways: https://www.quora.com/Distributed-Systems/What-is-a-simple-explanation-of-the-Paxos-algorithm Raft - An Understandable Consensus Algorithm. Raft is another conensus algorithm designed for humans to understand, which if you can tell from the above wall of text might be a problem with Paxos. https://ramcloud.stanford.edu/raft.pdf 左耳听风 - 推荐阅读：分布式数据调度相关论文: http://10-02.com/180118-32%20_%20%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87.html]]></content>
      <categories>
        <category>分布式一致性</category>
        <category>paxos算法</category>
      </categories>
      <tags>
        <tag>paxos</tag>
        <tag>分布式一致性</tag>
      </tags>
  </entry>
</search>
