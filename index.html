<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="码农|理工男|文青">
<meta property="og:type" content="website">
<meta property="og:title" content="窦小固的小木屋">
<meta property="og:url" content="http://www.sainpo.top/index.html">
<meta property="og:site_name" content="窦小固的小木屋">
<meta property="og:description" content="码农|理工男|文青">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="窦小固的小木屋">
<meta name="twitter:description" content="码农|理工男|文青">
  <link rel="canonical" href="http://www.sainpo.top/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>窦小固的小木屋</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">窦小固的小木屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">西河书生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/11/01/linux-user-group-mode-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/01/linux-user-group-mode-management/" class="post-title-link" itemprop="url">Linux之用户、权限管理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-01 14:41:39" itemprop="dateCreated datePublished" datetime="2019-11-01T14:41:39+08:00">2019-11-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-14 14:56:34" itemprop="dateModified" datetime="2019-11-14T14:56:34+08:00">2019-11-14</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux命令/" itemprop="url" rel="index"><span itemprop="name">linux命令</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux命令/Linux用户、权限管理/" itemprop="url" rel="index"><span itemprop="name">Linux用户、权限管理</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">5k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">5 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="用户及用户组"><a href="#用户及用户组" class="headerlink" title="用户及用户组"></a>用户及用户组</h2><h3 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h3><ul>
<li>管理员：UID：0，GID：0</li>
<li>系统用户：UID：1-499  GID：1-499 作用：对守护进程获取资源进行权限分配</li>
<li>普通用户: UID:500-60000  GID:500-6000</li>
</ul>
<h3 id="组账户-组是用户的集合"><a href="#组账户-组是用户的集合" class="headerlink" title="组账户(组是用户的集合)"></a>组账户(组是用户的集合)</h3><ul>
<li>管理员组：root, 0</li>
<li>系统组：1-499, 1-999(centos7)</li>
<li>普通组：500-6000</li>
</ul>
<h4 id="Linux组的分类"><a href="#Linux组的分类" class="headerlink" title="Linux组的分类"></a>Linux组的分类</h4><p>当一个用户同<strong>属于多个组</strong>时，将这些组分为</p>
<ul>
<li>用户的基本组(<strong>主组</strong>)：组名同用户名，且仅包含一个用户：私有组</li>
<li><strong>附加组</strong>：登录后可切换的其他组</li>
</ul>
<p>按照用户组中是否只有自己，可以分为</p>
<ul>
<li>标准组：标准组可以容纳多个用户</li>
<li>私有组：私有组中只有用户自己</li>
</ul>
<h2 id="对应文档的格式说明"><a href="#对应文档的格式说明" class="headerlink" title="对应文档的格式说明"></a>对应文档的格式说明</h2><p>账户的实质上就是用户在系统上的标识，这些标识是用<strong>文件保存</strong>起来的：</p>
<ul>
<li><p>用户名和 UID 被保存在<code>/etc/passwd</code>文件中，文件权限 <code>(-rw-r--r--)</code></p>
</li>
<li><p>组和GID 被保存在 <code>/etc/group</code>文件中，文件权限<code>(-r--------)</code></p>
</li>
<li><p>用户口令(密码)被保存在 <code>/etc/shadow</code>文件中  ，文件权限<code>(-rw-r--r-- )</code></p>
</li>
<li><p>组口令被保存在 <code>/etc/gshadow</code>文件中 ，文件权限 <code>(-r--------)</code></p>
</li>
</ul>
<h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>用户名:密码:UID:GID:用户注释信息:用户家目录:Shell定义</strong></p>
<ol>
<li>用户名: 用户的名称</li>
<li>密码: X表示占位符,也可以是密码</li>
<li>UID: 用户识别代码</li>
<li>GID: 用户所属组的GID(基本组)</li>
<li>用户注释信息:Comment,可以完善用户的基本信息</li>
<li>用户家目录: 系统登录用户后的工作目录</li>
<li>shell: 定义用户登录系统所使用的shell,指定的shell需要在/etc/shells中出现</li>
</ol>
<h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:<span class="variable">$6</span><span class="variable">$YqkEsOcfKPptyhnS</span><span class="variable">$YD0ym4BZ52pzcCnU</span>....:16781:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p><strong>用户名:密码:上一次修改密码的时间:密码最小使用期限:最长使用期限:警告时间:帐户过期时间:保留字段</strong></p>
<ol>
<li>用户名: 用户的名称，对应/etc/passwd文件中</li>
<li>密码: Centos6中使用MD5加密算法，Centos7中使用sha1的算法，第一个$后面加密算法类型，第二个$后面表示salt,第三个$后面表示密码的提取码（参照加密类型）</li>
<li>上一次修改密码的时间: 指用户上次修改密码的时间，计算方法:从Linux元年1970年01月01日0点0分到目录所经过的秒数</li>
<li>密码最小使用期限: 指用户修改密码后，需要到多少天后方可更改密码,0表示禁用</li>
<li>密码最长使用期限: 指用户的密码到多少天后需要修改密码</li>
<li>警告时间: 指用户密码到期前多少天提示用户修改密码，0和空字段表示禁用此功能</li>
<li>帐户过期时间: 批帐户在密码过期后多少天还未修改密码，将被停用</li>
</ol>
<h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure>

<p><strong>组名：密码：GID：User_list</strong></p>
<ol>
<li>组名：组的名称，默认同名用户名</li>
<li>密码: 组的密码占位符，用于用户临时切换至需要的组以获取相应权限，可以使用<code>newgrp - GROUP_NAME</code>切换</li>
<li>GID：组的全局识别号</li>
<li>User_list：隶属此组的用户，多个用户使用”,”隔开</li>
</ol>
<h4 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:<span class="variable">$6</span><span class="variable">$PLRAi</span>/Z/svr<span class="variable">$PRelPtvLuGJqvFG3D8fbjYHDho2RQUe93glO</span>.::</span><br></pre></td></tr></table></figure>

<p><strong>组名：密码：组管理者：User_list</strong></p>
<ol>
<li>组名：组的名称，同步/etc/group文件中</li>
<li>密码：第一个$后面表示加密算法，第二个$后面表示加密的密码</li>
<li>组管理者：可以对此组成员有操作权限，如果有多个，可以用逗号隔开</li>
<li>User_list： 用户的列表，如果有多个，可以使用逗号隔开</li>
</ol>
<p>有了上面的知识点，下面我来简述一下创建用户的时候会发生什么：</p>
<ul>
<li>用户名和 UID 被保存在 <code>/etc/passwd</code> 这个文件中，用户的口令通常用<code>shadow passwords</code>保护</li>
<li>当用户登录时，他们<strong>被分配了一个主目录和一个运行的程序</strong>（通常是 shell）</li>
<li>若没有指定他所属于的组，RHEL/CentOS就建立一个和<strong>该用户同名的私有组</strong>，且用户被分配到这个私有组中</li>
</ul>
<h2 id="用户及用户组管理命令"><a href="#用户及用户组管理命令" class="headerlink" title="用户及用户组管理命令"></a>用户及用户组管理命令</h2><h3 id="用户创建：useradd"><a href="#用户创建：useradd" class="headerlink" title="用户创建：useradd"></a>用户创建：useradd</h3><blockquote>
<p>useradd [options] LOGIN</p>
</blockquote>
<ul>
<li>-c “COMMENT”：用户的注释信息；</li>
<li>-d /PATH/TO/HOME_DIR: 以指定的路径为家目录；</li>
<li>-m 强制建立用户主文件夹，并将/etc/skel/当中的文件复制到用户的根目录下</li>
<li>-p 密码。输入该帐号的密码</li>
<li>-s SHELL: 指明用户的默认shell程序，可用列表在/etc/shells文件中；</li>
<li>-r: 创建系统用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash user1</span><br></pre></td></tr></table></figure>

<h3 id="为普通用户增加管理员权限"><a href="#为普通用户增加管理员权限" class="headerlink" title="为普通用户增加管理员权限"></a>为普通用户增加管理员权限</h3><p>修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">user1   ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>

<p>修改完毕，现在可以用user1帐号登录，然后用命令 su - ，即可获得root权限进行操作。</p>
<h3 id="组创建：groupadd"><a href="#组创建：groupadd" class="headerlink" title="组创建：groupadd"></a>组创建：groupadd</h3><blockquote>
<p>groupadd [OPTION]… group_name</p>
</blockquote>
<ul>
<li>g GID: 指明GID号；[GID_MIN, GID_MAX]</li>
<li>r: 创建系统组</li>
</ul>
<h3 id="用户属性修改：usermod"><a href="#用户属性修改：usermod" class="headerlink" title="用户属性修改：usermod"></a>用户属性修改：usermod</h3><blockquote>
<p>usermod [OPTION] login</p>
</blockquote>
<ul>
<li>-u UID: 新UID</li>
<li>-g GID: 新基本组</li>
<li>-G GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项，表示append；</li>
<li>-s SHELL：新的默认SHELL；</li>
<li>-c ‘COMMENT’：新的注释信息；</li>
<li>-d HOME: 新的家目录；原有家目录中的文件不会同时移动至新的家目录；若要移动，则同时使用-m选项；</li>
<li>-l login_name: 新的名字；</li>
<li>-L: lock指定用户</li>
<li>-U: unlock指定用户</li>
</ul>
<h3 id="给用户添加密码：passwd"><a href="#给用户添加密码：passwd" class="headerlink" title="给用户添加密码：passwd"></a>给用户添加密码：passwd</h3><blockquote>
<p>passwd [OPTIONS] UserName: 修改指定用户的密码，仅root用户权限<br> passwd: 修改自己的密码；</p>
</blockquote>
<ul>
<li>-l: 锁定指定用户</li>
<li>-u: 解锁指定用户</li>
<li>-n mindays: 指定最短使用期限</li>
<li>-x maxdays：最大使用期限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd user1       &lt;--root修改普通用户的密码</span><br><span class="line">passwd		 &lt;--普通用户修改自己的密码</span><br></pre></td></tr></table></figure>

<h3 id="删除用户：userdel"><a href="#删除用户：userdel" class="headerlink" title="删除用户：userdel"></a>删除用户：userdel</h3><blockquote>
<p>userdel [OPTION]… login</p>
</blockquote>
<ul>
<li>-r: 删除用户家目录；</li>
</ul>
<h3 id="组属性修改：groupmod"><a href="#组属性修改：groupmod" class="headerlink" title="组属性修改：groupmod"></a>组属性修改：groupmod</h3><blockquote>
<p>groupmod [OPTION]… group</p>
</blockquote>
<ul>
<li>-n group_name: 新名字</li>
<li>-g GID: 新的GID；</li>
</ul>
<h3 id="组删除：groupdel"><a href="#组删除：groupdel" class="headerlink" title="组删除：groupdel"></a>组删除：groupdel</h3><blockquote>
<p>groupdel GROUP</p>
</blockquote>
<h3 id="组密码：gpasswd"><a href="#组密码：gpasswd" class="headerlink" title="组密码：gpasswd"></a>组密码：gpasswd</h3><blockquote>
<p>gpasswd [OPTION] GROUP</p>
</blockquote>
<ul>
<li>-a user: 将user添加至指定组中；</li>
<li>-d user: 删除用户user的以当前组为组名的附加组</li>
<li>-A user1,user2,…: 设置有管理权限的用户列表</li>
</ul>
<h3 id="修改用户属性：chage"><a href="#修改用户属性：chage" class="headerlink" title="修改用户属性：chage"></a>修改用户属性：chage</h3><blockquote>
<p>chage [OPTION]… LOGIN</p>
</blockquote>
<ul>
<li>-d LAST_DAY</li>
<li>-E, –expiredate EXPIRE_DATE</li>
<li>-I, –inactive INACTIVE</li>
<li>-m, –mindays MIN_DAYS</li>
<li>-M, –maxdays MAX_DAYS</li>
<li>-W, –warndays WARN_DAYS</li>
</ul>
<h3 id="用户切换命令-su-sudo"><a href="#用户切换命令-su-sudo" class="headerlink" title="用户切换命令: su/sudo"></a>用户切换命令: su/sudo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>

<p>直接切换为超级用户，但是需要<strong>root账号的密码</strong>，但是我们的目的只是让普通用户来借用root的权限，而不是把普通账号变为root，因为一旦root密码被别人知道这可是很危险的行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">sudo su &lt;user&gt;      &lt;--与su &lt;user&gt;用法类似，都是用来切换用户的，不过只要输入自己的账号</span><br></pre></td></tr></table></figure>

<p>而sudo 只要输入自己的账号就可以拥有root权限来执行系统管理命令，而无需知道超级用户的口令。当用户执行sudo时，会自动查找<strong>/etc/sudoers</strong>文件判断用户是否有执行sudo命令的权限。</p>
<h3 id="用户相关的命令-id、groups、whoami、w-who"><a href="#用户相关的命令-id、groups、whoami、w-who" class="headerlink" title="用户相关的命令: id、groups、whoami、w/who"></a>用户相关的命令: id、groups、whoami、w/who</h3><ul>
<li><code>id</code>：显示用户当前的uid、gid和用户所属的组列表</li>
<li><code>groups</code>：显示指定用户所属的组列表</li>
<li><code>whoami</code>：显示当前用户的名称</li>
<li><code>w/who</code>：显示登录用户及相关信息</li>
</ul>
<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p><img src="/2019/11/01/linux-user-group-mode-management/20191101163954.jpg" alt="执行ls命令文件权限"></p>
<h2 id="权限类别-u-g-o"><a href="#权限类别-u-g-o" class="headerlink" title="权限类别: u/g/o"></a>权限类别: u/g/o</h2><ul>
<li>owner: 属主, u</li>
<li>group: 属组, g</li>
<li>other: 其他, o</li>
<li>a: 代表以上三项</li>
</ul>
<h2 id="权限标识-r-w-x"><a href="#权限标识-r-w-x" class="headerlink" title="权限标识: r/w/x"></a>权限标识: r/w/x</h2><ul>
<li>r: Readable</li>
<li>w: Writable</li>
<li>x: eXcutable(对于文件指可启动为一个进程；对于目录指可以使用ls -l查看此目录中文件列表，可以cd进入此目录)</li>
</ul>
<p>权限用数字表示，读(r) = 4  写(w) = 2  执行(x) = 1</p>
<h2 id="修改文件权限：chmod"><a href="#修改文件权限：chmod" class="headerlink" title="修改文件权限：chmod"></a>修改文件权限：chmod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sysnopsis: </span><br><span class="line">chmod [OPTION]... MODE[,MODE]... FILE...</span><br><span class="line">chmod [OPTION]... OCTAL-MODE FILE...</span><br><span class="line">chmod [OPTION]... --reference=RFILE FILE...</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">        -r --recursive : 递归修改</span><br><span class="line">        --reference : 参照某文件来修改  </span><br><span class="line">        </span><br><span class="line">Usage: </span><br><span class="line">        1、赋权等值法</span><br><span class="line">            chmod u=rwx,g=rwx,o=rwx FILE</span><br><span class="line">            chmod a=rwx FILE</span><br><span class="line">        2、赋权加减法</span><br><span class="line">            chmod u-rwx,g-rwx,o-rwx FILE</span><br><span class="line">            chmod ugo-x FILE</span><br><span class="line">            chmod u+rwx,go+r FILE</span><br><span class="line">            chmod a+r FILE</span><br><span class="line">        3、十进制赋权法</span><br><span class="line">            chmod 777 FILE</span><br><span class="line">        4、参照赋值法</span><br><span class="line">            chmod --reference/var/<span class="built_in">log</span>/file FILE</span><br></pre></td></tr></table></figure>

<h2 id="修改文件的属主：chown"><a href="#修改文件的属主：chown" class="headerlink" title="修改文件的属主：chown"></a>修改文件的属主：chown</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">synopsis: </span><br><span class="line">		chown [OPTION]... [OWNER][:[GROUP]] FILE...</span><br><span class="line">              chown [OPTION]... --reference=RFILE FILE... </span><br><span class="line">    options:</span><br><span class="line">        -R :  --recursive 递归修改</span><br><span class="line">        --reference : 参照某文件来修改</span><br><span class="line">    Usage:</span><br><span class="line">        chown mariadb FILE : 只修改文件的属主为mariadb</span><br><span class="line">        chown mariadb:mariadb FILE :修改文件的属主、属组为mariadb</span><br><span class="line">        chown mariadb:mariadb FILE : 同上</span><br><span class="line">        chown --reference=/var/<span class="built_in">log</span>/file FILE : 参照/var/<span class="built_in">log</span>/file来修改FILE的属主、属组</span><br></pre></td></tr></table></figure>

<h2 id="修改文件的属组：chgrp"><a href="#修改文件的属组：chgrp" class="headerlink" title="修改文件的属组：chgrp"></a>修改文件的属组：chgrp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synopsis: </span><br><span class="line">		chgrp [OPTION]... GROUP FILE...</span><br><span class="line">    chgrp [OPTION]... --reference=RFILE FILE...</span><br><span class="line">注：由于chgrp只能修改属组，故一般情况都使用chown代替</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/09/12/henan-jun-fa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/henan-jun-fa/" class="post-title-link" itemprop="url">北洋军阀时期，为什么河南没被大军阀长期割据？</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 21:16:11 / 修改时间：21:25:19" itemprop="dateCreated datePublished" datetime="2019-09-12T21:16:11+08:00">2019-09-12</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/历史-地理/" itemprop="url" rel="index"><span itemprop="name">历史&地理</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/历史-地理/中国历史/" itemprop="url" rel="index"><span itemprop="name">中国历史</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">3.1k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">3 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>北洋军阀时期是中国近代史上纷乱的割据时代，各地军阀依仗自身的军事、经济实力以及各自身后的美日等国支持，划地为政，中央政府名存实亡。但是放眼河南周边地区，山东有吴佩孚、孙传芳，安徽有段祺瑞，湖北有黎元洪，陕西有杨虎城，山西有阎锡山，河北有冯国璋、冯玉祥等等，独独河南一省没有被类似等级的大军阀长期占领，甚至在北洋割据初期，还一度服从于中央政府直接管理，这在北洋军阀史上是一个非常奇特的现象。</p>
<p>有人可能会提到比前几位都要厉害的河南人袁世凯，但他毕竟没有将河南作为自己的割据地，创建个豫系军阀之类的，所以不太能算。</p>
<p><img src="/2019/09/12/henan-jun-fa/BFA87023CBB1C4CE1CB97CC30300E0B0.png" alt="北洋军阀割据初期形势图，从图中可以发现：军阀割据初期，河南省已被各系军阀的势力范围所包围，但却直属中央，未被划入某一军阀的势力范围之内"></p>
<p>那么，河南为什么没有被大军阀长期割据？</p>
<p>其实，并非是河南没有军阀，而是大军阀们在河南没法长期待下去。</p>
<h2 id="上古遗风，只尊正统"><a href="#上古遗风，只尊正统" class="headerlink" title="上古遗风，只尊正统"></a>上古遗风，只尊正统</h2><p>在古代中国，传统的“正统”评判标准有三，其中就包括是否据中原，宋代叶适的《兵部尚书蔡公墓志铭》记载：“若夫不别夷夏，不分正闰，恬其仇我，俛焉并立，甚至以为戎狄之德，黎民怀之，若天眷命而然，则尤公师友之所讳也。”</p>
<p>简言之，就是只有中原之人才是天下正统之所在。由此可见，正统观在中国人的心目中占有极重的地位。</p>
<p>而千百年来，“尊主”一直是位居中原腹地的河南民众的共识。民国时期，在河南省安阳市侯家庄内，有近89%的人对中央有强烈的归属感，“尊尊”“亲亲”的思想以及对正统的归属感依然在民众和政治上层中有很大的影响，且对正统的认同程度有增无减。</p>
<p>在军阀割据的初期，正统显而易见就是与各派割据势力名称相异的中央政府。因而，深厚的封建中原文化遗存，是使河南在军阀割据之初不为各派军阀所占的原因之一。</p>
<p>当然，随着军阀混战规模的不断扩大，河南在之后曾陆续归附不同的大军阀势力之下，只是时间都不长久。</p>
<h2 id="黄河泛滥，环境不稳"><a href="#黄河泛滥，环境不稳" class="headerlink" title="黄河泛滥，环境不稳"></a>黄河泛滥，环境不稳</h2><p>黄河重灾区是军阀们不得不放弃河南的另一个重要原因</p>
<p>在历史上，河南一度是中国的政治经济文化中心。所谓“得中原者得天下”，这是各路志在天下的豪杰枭雄们的共识。由于土壤肥沃，气候温和，河南成为中国冬小麦的主要产地，其中河南北部的冬小产量居全国第一。得到了中原大地上的出产的粮食，得到了中原男儿做兵源，就有了夺取天下的本钱。于是“群雄逐鹿”时都要“逐鹿中原”，河南就成为兵家必争之地。</p>
<p>但是国历君之前曾讲过，河南地区一直面临着黄河带来的水患。自周定王（公元前602年）至1938年国民党花园口扒开河水淹没日军，这2540年中，黄河决溢次数多达1590多次，黄河26次大的变道中就有20余次发生在河南地界上，真的是“中国之水非一，而黄河为大，其源远而高，其流大而疾，其质浑而浊，其为患于中国也，视诸水为甚焉”。</p>
<p>在兵荒马乱、缺乏对黄河进行有效管理的民国时代，黄河水患带来的影响更为严重。1921年、1931年、1935年、1938年，河南共计发生四次大规模的水灾发生，其沿河各县，河水纷纷漫灌，河水退却之后，村落尽数被毁，土地大量荒芜，有的地方被水浸泡长达3个月之久，每一次水灾带来的都是大量的田地被淹没、房屋被摧毁以及大量人口的锐减，几乎整个河南的地块都曾遭受过黄河的肆虐，给河南人民带来了深重的灾难。</p>
<p>因此，饱受黄河肆虐的河南已经不适合作为长期驻兵屯粮的首选根据地，自然没有大军阀长期占领。</p>
<h2 id="四通八达，四战之地"><a href="#四通八达，四战之地" class="headerlink" title="四通八达，四战之地"></a>四通八达，四战之地</h2><p>河南位居中原腹地，地理位置四通八达，这在和平年代是优势，但在战争年代，就是严重的“缺陷”。</p>
<p><img src="/2019/09/12/henan-jun-fa/sanshengjiaojie.jpeg" alt="三省交界，兵家必争之地"></p>
<p>翻看地图，河南正是处在中原的中心位置，属于交通要道。战争时期，地处中心的河南，常会陷入四面受敌、无回旋余地的境界。</p>
<p>河南自古以来就被称为“四战之地”，因其特殊的军事价值一直是兵家必争之地，只要中原有战争，河南必定是主战场之一。春秋战国有围魏救赵，秦末有陈胜吴广起义。隋末农民军荥阳大海寺一役，使隋朝残兵败将“尽夜号哭，数日不止，河南郡县为之丧气。”（《旧唐书》卷五三《李密传》）。唐末王仙芝又在河南长垣发动起义。到了近代，义和团运动在山东、河南等地兴起。我们从成语“逐鹿中原”和“问鼎中原”，就能体会到古代河南地理位置的独特性。</p>
<p>而由于四通八达的平坦地形，使得河南一旦被占领，就有可能面临腹背受敌的困境。北宋最终将都城定在开封，也不得不解决其地理上的防御弱点，必须在都城驻屯重兵加以弥补。而军阀混战的年代，还没有哪一个军阀能势力强大到用重兵占领河南。</p>
<p><img src="/2019/09/12/henan-jun-fa/2769637208.jpeg" alt="围棋示意图"></p>
<p>围棋术语中，有句话叫“金角银边草肚皮”，所谓四个角部，因为有两边支撑，易守难攻，容易活棋，所以称“金”；四条边线，虽有一定风险，但至少左右相通，所以称“银”；唯有中央，无所依凭，一马平川，就如茫茫大野，难攻难守，所以它是“草”。而河南，就处于“草肚皮”的位置。</p>
<p>北伐战争前夕，河南被吴佩孚控制，属直系军阀势力范围。到了北伐战争中，随着吴佩孚、孙传芳的溃败，奉系张作霖就进军河南省，企图阻止国民革命军北伐。最后，从武汉北上的北伐军与冯玉祥部队会师河南郑州，奉军也因腹背受敌，被迫撤退。</p>
<h2 id="饱经蹂躏，经济承载力弱"><a href="#饱经蹂躏，经济承载力弱" class="headerlink" title="饱经蹂躏，经济承载力弱"></a>饱经蹂躏，经济承载力弱</h2><p>军阀混战使得河南饱经蹂躏，已是千疮百孔。据不完全统计，1919-1922年，中国大约每两个月要发生3次较大规模的内战，战火几乎遍及全国。而这期间，河南本地小军阀的胡作非为无疑是雪上加霜。</p>
<p><img src="/2019/09/12/henan-jun-fa/3586987169.jpeg" alt="赵倜"></p>
<p>河南曾有一个军阀叫赵倜，曾奉袁世凯之命率部进入河南，后又追剿白朗起义军，因功授河南护军使，1914年督理河南军务。但是，赵倜的主要精力都用在巩固自己的地盘，对发展经济毫无兴趣。赵倜在河南统治8年，对地方无所建树，还以种种手段谋取私利，加之他的军队纪律非常败坏，河南百姓因此特别恨他。</p>
<p>据记载，赵倜在河南谋私有三个主要方法：一是欠饷自肥，军队经常欠饷数月，年终则马虎了事；二是把持河南省铜元局，买铜自造，从中取利；三是不通过省长公署和财政机关，直接向豫西产鸦片县份摊派鸦片捐款，尽入私囊。</p>
<p>1916年袁世凯死后，北洋军阀分裂为皖、直、奉三大派系，各派军阀纷纷划分势力范围，从东北到两广几乎已被各系军阀分瓜殆尽。</p>
<p>这时，任河南督军兼省长的赵倜，先依附段祺瑞，后因为与段产生矛盾，在1920年直皖战争时期，拥直反皖。战争结束后，本以为能享受功劳的赵倜却被吴佩孚排挤，地位降低。1922年，第一次直奉战争爆发，赵倜又响应奉系在河南反对吴佩孚，结果被冯玉祥击败，并被免除河南督军。他不得不出关投靠张作霖，任高等顾问。1933年，赵倜在北京病逝。</p>
<p>除了赵倜，河南还有一支军阀部队——镇嵩军。但这支军队势力明显要小很多，如果不是《白鹿原》的热播，估计很少有人知道历史上还有过这么一支部队。镇嵩军的长官刘镇华除了围困西安外，好像也没折腾起什么大事来。</p>
<p><img src="/2019/09/12/henan-jun-fa/3453494757.jpeg" alt="刘镇华"></p>
<p>民国最大的一场军阀混战，就是以河南为主战场的中原大战。1930年，蒋介石大战冯玉祥、阎锡山、桂系李宗仁、白崇禧等联军。这时，河南小军阀们只能选其中一方投靠。河南最大的军阀势力镇嵩军就是在这场战争中，从冯玉祥麾下转投了蒋介石，从此四分五裂，几乎消失。从赵倜、刘镇华的经历不难看出，河南当地的小军阀并不打算以河南为根据地，长期经营自己的势力，而是努力将河南一地依附在周边的大军阀势力下，牟取私利。</p>
<p>另外，庞大的军费开支，几乎榨干了整个河南。1926年，北伐前夕，北方军阀（包括所属地方军阀）在河南省驻军三十万，每月支付军费164万1千元，而河南省全年收入不过2千万元。可见河南省已被军阀蹂躏得面目全非、鲜血淋漓。</p>
<p>总的来讲，河南虽说是四通八达的中心，人口也众多，土地也平整可耕，可是由于黄河水患的影响、无险可守的特殊地理环境以及军阀混战导致的社会经济衰退，使得军阀们对河南都只是暂时性的占据，无力维持长久的统治，就更别说长期的割据了。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/09/11/qi-lian-shan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/11/qi-lian-shan/" class="post-title-link" itemprop="url">幕后英雄祁连山</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-11 10:33:19" itemprop="dateCreated datePublished" datetime="2019-09-11T10:33:19+08:00">2019-09-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-12 11:58:10" itemprop="dateModified" datetime="2019-09-12T11:58:10+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/历史-地理/" itemprop="url" rel="index"><span itemprop="name">历史&地理</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/历史-地理/中国地理/" itemprop="url" rel="index"><span itemprop="name">中国地理</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">17k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">16 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <blockquote>
<p>祁连山是一个对中国举足轻重的山。许多人知道东西方文明交流的大通道——丝绸之路，知道大名鼎鼎的河西走廊，但是人们却不知道祁连山对河西走廊和丝绸之路的贡献，不知道祁连山是幕后的英雄。本文作者深入祁连山中，并且环绕着祁连山走了一圈，他将给我们讲述祁连山的故事，以及祁连山对青海、甘肃乃至中国的意义。</p>
</blockquote>
<p><img src="/2019/09/11/qi-lian-shan/11eb4b0f35a24dbda32aaabd96714283_th.png" alt="青海祁连县：牛心山下，黑河河畔"></p>
<p><font color="red" size="2">这是青海省祁连县县城北边的牛心山，这里已是祁连山的深处。秋天的牛心山上已是白雪皑皑，阳光照射在收割后的田野上，一片金色的秋景。山前的河流，就是最终流到了内蒙古巴丹吉林沙漠的黑河的支流——八宝河。黑河发源于走廊南山的南坡，在托来山和走廊南山之间一直向东流淌，在祁连县与八宝河汇合后，突然折向北流，在走廊南山和冷龙岭之间切开一道险峻的峡谷——黑河大峡谷，流向河西走廊，然后流向内蒙古的沙漠深处。从图中还可以看出，尽管这里已是祁连山的中段，但还有森林分布，田野里收获着麦子，这与它南面的青海湖周边显然不同，那里是游牧者的天下。摄影/马福江</font></p>
<h2 id="我们被地图洗了脑"><a href="#我们被地图洗了脑" class="headerlink" title="我们被地图洗了脑"></a>我们被地图洗了脑</h2><p>中国人一般都知道祁连山，不过不是从地理书中知道的，而是从历史书中知道的。中国的历史书讲到汉代、汉王朝与匈奴的战争，都会提到祁连山。匈奴有一首歌唱道：“失我祁连山，使我六畜不蕃息；失我焉支山，使我嫁妇无颜色。”祁连山是与匈奴联系在一起的。这是许多人对祁连山的印象。</p>
<p><img src="/2019/09/11/qi-lian-shan/c6909a6f8f2c49258282a004d2da1c63.png" alt="青海门源：山南山北油菜花"></p>
<p><font color="red" size="2">在祁连山的东端,由于季风的影响,其南面和北面,差异并不是很大,尤其是顺着大通河与湟水河谷,东南季风能吹送到祁连山的深处,因此大通河畔的门源县降水足以让油菜花开得一片灿烂,门源县的油菜花不仅是这里的主要经济作物,而且成了一种美景资源,给人们以美的享受。摄影/郑云峰</font></p>
<p>除了历史书中对祁连山的描绘，我们许多人对祁连山的印象还来自于地图。我们平时所见的全国地图，大多是行政区划图，很少是地势图；再就是比例尺都很小，比如是1比400万或比这比例尺还小的地图。比如我面前的一本大16开的中国地图册，一张跨页全国地图的比例尺是1比1600万的，图中的一厘米代表的是160公里，在这样的图上，祁连山只能是一条线。在这种没有地势只有地名、小比例尺的全国地图上，不仅是祁连山，许多雄伟壮丽的庞大的山脉或山系都成了一条线，譬如秦岭等。由于总是看这种小比例尺没地势地形的地图（大比例尺有地势地形的地图在中国属保密范围，至今仍未解禁），许多人就像那些地图一样把一些庞大的山脉或山系，想象成长长的一条线。可以说长期以来，我们已经被这种小比例尺没地势的地图洗了脑，我们已经对祖国的许多山川形成了错误的认识，这种错误的认识只有当你亲自走到那些山川面前，才能得到纠正。我的一位朋友是摄影师，他告诉过我他第一次到祁连山时给他带来的震撼。他说他一直以为祁连山就是一道长长的山岭，翻过山岭，那边就应是平地，祁连山就没了。可是那年他从河西走廊的张掖出发，经山丹军马场北面的著名古隘口——扁都口翻越了祁连山的山脊线，当他一登上隘口，站在制高点上向南望去，眼前的景象让他惊呆了，祁连山根本就不是他原来想象的那样是一条孤立的单薄山岭，而是山连山、岭连岭，展现在他面前的是千山万岭山的海洋。</p>
<p><img src="/2019/09/11/qi-lian-shan/4efd0af70cc1496bbe6a9c13d2726ef9_th.png" alt="甘肃肃南：这里的油菜花更鲜艳"></p>
<p><font color="red" size="2">好像是为了与山南边门源县的油菜花比美，在甘肃省肃南县，也种植了大面积的油菜花，这里的油菜花海把大地装扮得好像一幅色彩斑斓的大地毯。从上面两幅照片中，我们还可以了解到，祁连山的东段，山南和山北景观的差异不大，也可以说，祁连山的主山脊虽然高大，但是并没有起到分界作用，没有在山的两边造成很大的差异。摄影/王金</font></p>
<p>其实这千山万岭正是祁连山的真实形象。因为祁连山根本不是一条单独的山岭，而是一组大致平行的呈西北—东南走向的山脉群。这组山脉群长达1000多公里，宽达300多公里，当我那位摄影师的朋友登上扁都口向南张望时，展现在他面前的是300多公里宽的山脉群，怎能不让他惊讶，怎能不彻底颠覆他头脑中关于祁连山的概念。</p>
<h2 id="青海湖原来属于祁连山"><a href="#青海湖原来属于祁连山" class="headerlink" title="青海湖原来属于祁连山"></a>青海湖原来属于祁连山</h2><p>虽然我知道祁连山是一个庞大的山系，但我对祁连山的认识也有一个不断深入的过程。</p>
<p>2005年底，我来到了青海湖东边的海晏县。在那里，我才知道原来青海湖也在祁连山的范围内，甚至青海湖南边的青海南山也是祁连山系的一条山脉。在一张卫星三维地图上这一点看得很清楚。青海湖是一个近似椭圆形的湖，它的长轴方向与祁连山诸山脉的走向完全相同，它南边的青海南山不仅走向相同，而且与祁连山中的党河南山、哈尔科山相连，逶迤绵延，青海湖是祁连山的一颗耀眼的明珠。当我们想到祁连山时，如果能想到美丽浩瀚的中国第一大湖青海湖时，我们对祁连山才算有了基本的认识。</p>
<p><img src="/2019/09/11/qi-lian-shan/2066b021cdea48c3aa1038d6a41a937e_th.png" alt="青海省青海湖：这是中国最美的湖泊"></p>
<p><font color="red" size="2">青海湖是属于祁连山的。她是祁连山群山拱卫的一颗明珠。青海湖是中国水面最大的湖泊，也是中国最美的湖泊，她浩瀚如海，水碧如天，环绕她的是繁花似锦的草原。摄影/马培华</font></p>
<p>青海湖是祁连山的精华和亮点。我曾经沿着布哈河谷地向青海湖走去，那时正值隆冬。原以为此时此地定是大地蒙雪、百草凋零，但我眼前宽阔的布哈河谷却是一片耀眼的金黄草地。有一家牧人骑着马儿在草地上牧羊，还有几头黑色的牦牛在河里饮水。许多人都认为看草原一定要在春夏之交，那时候草原上繁花似锦、灿若云霞。然而冬天的青海湖边的草原自有一种风致，其实湖边的草原就是留做冬季牧场的，夏季，牧民们把牛羊赶到了山上的牧场。湖边草原上的牧草经过一个夏天的疯长，又经过秋天风霜的洗礼，此时灿若黄金，在阳光下熠熠生辉。大地仿佛铺上了金色的地毯，一直伸向远方的地平线。我曾经坐在金黄的草地上，看着远方的羊群，久久不愿离去。</p>
<p><img src="/2019/09/11/qi-lian-shan/1669e460044e4a2aaa39f7981befcf32_th.png" alt="甘肃山丹：这里有中国最美的草原"></p>
<p><font color="red" size="2">山丹军马场，这里的草原不仅以美丽闻名，而且这里在历史上是为朝廷饲养军马的地方，中原汉王朝一向离不开这里提供的战马，北宋王朝失败后，有人竟把原因归结为北宋王朝很早就失去了对这里的控制，因此缺乏这里提供的优良的战马。可见这里的草原价值不凡。摄影/王金</font></p>
<p>青海湖东边海晏县的北面有一片草原，叫做金银滩草原，从它的名字就可知它的美丽和富饶。在这金银滩草原，西部歌王王洛宾创作了歌曲《在那遥远的地方》，是一位美丽的藏族牧羊姑娘轻轻地抽了他一鞭子，这一鞭触发了王洛宾的灵感，使他写出这首世界闻名的歌曲。</p>
<p>祁连山的美丽草原不仅仅在青海湖的周边，在祁连山还有许许多多美丽的草原。当我从海晏出发，奔向祁连县时，我发现公路两旁处处是美丽的草原，虽然已是12月，远处的山脊上已是白雪皑皑，但是山坡上、河谷里，扑入视野的还是草原的景象。以至我兴奋地将我们走的这条从海晏县到祁连县的公路称之为：草原大道。</p>
<p>据说更美的草原还在山的那边，在甘肃省山丹县的大马营和山丹军马场那一带，那里的草原草深花艳，每当6、7月份，那里是一片无边无际的花海。这片草原历史上一直被用来牧养军马，最多时这里有军马40多万匹。</p>
<h2 id="祁连山的景观不以山脊来划分"><a href="#祁连山的景观不以山脊来划分" class="headerlink" title="祁连山的景观不以山脊来划分"></a>祁连山的景观不以山脊来划分</h2><p>我说了许多草原，因为草原是祁连山很重要的景观。祁连山的奇特在于它的自然区划，不是以山的主脊线来划分，因为祁连山的山脊并没有给山两边带来不同的景观。祁连山景色的不同，取决于从太平洋吹来的东南季风向西吹到的位置和极限。因此可以将祁连山从东向西分为三段。</p>
<p>东祁连山在祁连山的东部西宁那一带，由于东部季风能吹到这里，所以这里降雨丰富，因此祁连山的东部生长着茂密的森林，分布有许多国家森林公园，如仙米国家森林公园、互助北山国家森林公园、群加国家森林公园、坎布拉国家森林公园等。从这些森林公园就能看出祁连山的东部森林之蓊郁。</p>
<p><img src="/2019/09/11/qi-lian-shan/99f33d5b02fe4c1f93bf6d42e18f75ac_th.png" alt="茶卡盐湖一片洁白的结晶盐 摄影/单之蔷"></p>
<p><img src="/2019/09/11/qi-lian-shan/5cbe60d97eae458baaba73e44ac0dc49_th.png" alt="察尔汗盐湖的盐池"></p>
<p><font color="red" size="2">祁连山南盐湖多 祁连山南面是柴达木盆地，这里降水稀少，呈现出典型的荒漠景观，但是这里却多湖泊，不过这里的湖泊多是盐湖。盐湖不仅有可观的经济价值，能产食盐、化肥和各种稀有金属，盐湖更是一种可供观赏的景观。谁能说图中的盐湖不是一种罕见的美景呢？摄影/单之蔷</font></p>
<p>季风继续向西吹送，力量却是越来越弱，所带的水汽越来越少，因此祁连山的中段（哈拉湖以东，青海湖以西）降雨减弱，森林稀少，草原发育，到处可见。</p>
<p>哈拉湖以西为西祁连山，包含有几列大山，从北向南有党河南山、赛什鄂博图岭、土尔根达坂山、柴达木山等。由于东部季风吹到这里已成强弩之末，这一带降雨稀少，呈现一片荒漠景象。但由于祁连山属于高山和极高山的世界，有许多高大的山峰截住了高空中的气流和云团，在高山发育了众多的雪山和冰川，冰川融水形成了一些河流，因此即使在祁连山干旱的西部，也有河流从雪峰流下，河谷中也会出现草地和植被，也有野牦牛、野驴、藏羚羊等。</p>
<p><img src="/2019/09/11/qi-lian-shan/c438a362c993423abae4916e2ff5d1ad_th.png" alt="盐湖地貌：稀缺的美景"></p>
<p><font color="red" size="2">从祁连山上流下来的河流携带了各种盐和矿物质,这些河流都是内流河,流到柴达木盆地后,或者受阻成湖,或者蒸发下渗消失在荒漠中,由于水没有循环,水被蒸发了,盐却流下了,因此在祁连山南面的山麓下,流下了许多盐湖。上图是大柴旦湖,图中的一处处圆或其他形状的坑洼,是一种奇特的盐湖地貌,它形成的原理是,此处原来是干盐滩,地下有结晶的各种盐类,当地下水或其他补充水出现,融解了干盐滩中结晶的盐类,晶体消失,就会出现这种水溶洞地貌。摄影/李洋</font></p>
<p><img src="/2019/09/11/qi-lian-shan/16018641846f4cebb1ef21f72bbec365_th.png" alt></p>
<p><font color="red" size="2">小柴达木湖（也叫巴戛柴达木湖），小柴达木湖的景观非常美丽，湖边是一片片如银似玉、晶莹洁白的盐滩。这种白白的食盐，在这里只是作为一种景观而存在，人们并不看重食盐的经济价值。这小柴达木湖最早受到人们的关注是因为它的湖水里含有稀有而价昂的硼砂。摄影/陈生贵</font></p>
<p>祁连山的三段各有不同的景观，即森林、草原、荒漠。这三种景观基本上是由气候（主要是由降雨）决定的。然而这仅仅是指祁连山地区的水平地带性分布，也就是说这基本上说的是祁连山麓基带的情况，即最下面第一自然带的景观特点。实际上祁连山的景观分布复杂得很，因为祁连山是雪峰林立的高山带，海拔4000米以上的山地面积占整个山区的三分之一，因此祁连山的景观分布还强烈地受到垂直地带性的控制。在水平地带性和垂直地带性的双重控制下，祁连山的景观呈现出千姿百态的变化。譬如即使是在季风吹不到的西祁连山，由于山高，也会在某一海拔高度形成一个降雨带，在这一降雨带内则形成了森林。在西祁连山的南面或北面你都会看到这种奇异的景观：在一片光秃秃的大山的半山腰上好像玉带缠腰一样分布着一条森林带，那森林带中的树木主要是四季常青的祁连圆柏。尤其是在冬季，当山坡上铺满了白雪，那半山腰上的林带却墨玉般地深绿，在一片白色中跃入你的眼帘，让你觉得神奇。你不禁会好奇地发问：为什么在那个高度上出现了一条森林带？</p>
<h2 id="祁连山对中国的意义"><a href="#祁连山对中国的意义" class="headerlink" title="祁连山对中国的意义"></a>祁连山对中国的意义</h2><p>在这里我必须说明，尽管祁连山分布在青海和甘肃两省之内，但我所谈到的祁连山，是冲破行政区划的，是在谈自然意义上完整的祁连山。因为如果我们按照行政区划来谈论祁连山，只能谈论半个祁连山，这样我们将无法理解祁连山。只有将祁连山作为一个整体来谈论，我们才能真正认识祁连山。</p>
<p>在一张全国地图上，如果你仔细观察，你会发现祁连山的一个重要的特点。它的三面被沙漠包围，它的北面是巴丹吉林沙漠、西面是库姆塔格沙漠和塔克拉玛干大沙漠、南面是柴达木荒漠。它是伸向沙漠中的一座湿岛，这是祁连山最重要的一个特征。全国只有一座山与他相似，那就是新疆的天山，天山也是伸向沙漠中的一座湿岛。</p>
<p><img src="/2019/09/11/qi-lian-shan/c6bfbcb466e542848eb094b6a1a1d6df_th.png" alt="消失在柴达木盆地的河流"></p>
<p><font color="red" size="2">一条条河流从祁连山上流下来，它们是季节性的河流,夏季才是属于它们的季节。在柴达木的荒漠中,它们留下了一条条痕迹，就消失了。</font></p>
<p>天山与祁连山好像一对兄弟，他们在浩瀚的沙漠中遥相呼应，像两只伸出去要握住的手，就差那么一点点，他们就握在一起了。</p>
<p>我在想，祁连山和天山在沙海中的这种遥相呼应，他们伸进沙漠的半岛姿态有何意义？</p>
<p>由天山和祁连山，我想到了沙漠，想到了绿洲，想到了丝绸之路。</p>
<p>当想到丝绸之路时，我的思路豁然开朗了，好像重新认识了祁连山。</p>
<p>说到丝绸之路，人们首先想到的是河西走廊。我们知道黄河流到了兰州后，忽然掉头北上，钻进茫茫沙漠之中。北上的黄河，成了一个地理的界限，人们将这里黄河以西的大片区域称之为河西。河西一带本应该是浩瀚的沙海，只是因为有了祁连山，才沿着祁连山的北麓，形成了由一个个绿洲连缀而成的一个条形的狭长地带，这个地带被称之为河西走廊。现今这一地带属于甘肃省。</p>
<p><img src="/2019/09/11/qi-lian-shan/d34e7f13480e45959989bd3c142dc5bc_th.png" alt="河西走廊的绿洲"></p>
<p><font color="red" size="2">如果没有祁连山,这里将是一片沙漠。祁连山的高大山体截留了水汽,形成了降水。是祁连山中的冰川融水和祁连山中发育的河流在河西走廊中造就了一个个绿洲,虽然已是冬天,但在图中,我们还是能看到远处的祁连山像卧龙一样绵延在远方,祁连山的奇特之处在于,虽然它沿着西北—东南方向延伸达1000多公里,但是它的山体高度变化并不剧烈,平均高度从东到西都在4500米以上,好像一列长长的火车,这就决定了祁连山的冰川发育从东到西很均衡,河流发育也很均衡,即每隔一段距离,大约是100公里左右,就有一条河流出现,这种均衡出现的河流,十分有利于古代的交通,这也是为什么祁连山北麓,形成了古代著名的丝绸之路的原因。</font></p>
<p>我甚至认为甘肃省是专为河西走廊设置的，这从甘肃的名称能看出来。因为甘肃两个字就取之于河西走廊两个重镇古地名的第一个字，古时的张掖称甘州，酒泉称肃州，两者的首字合起来为甘肃，由此看来甘肃省的省名来自于河西走廊。</p>
<p>为什么人们称这一带为“河西走廊”？尽管这一带良田万顷，稻谷飘香，但是人们看重的并不是这些，而是看重这一带的沟通和交流作用，看重的是这一带的通过能力。因此它才被称之为“走廊”。</p>
<p>河西走廊对古代中国的意义非同寻常。在航海技术不发达的古代，东西方的交流和贸易主要通过陆路来进行。丝绸之路就是欧亚大陆东西方之间最重要的贸易和文化交流通道，而河西走廊是丝绸之路最重要的一段。</p>
<p><img src="/2019/09/11/qi-lian-shan/a01283b4b180443b9ec46fa1847276f4_th.png" alt="东部祁连山与西部的鲜明对比"></p>
<p><font color="red" size="2">东部的祁连山，在来自太平洋季风的吹拂下，是伸进西北干旱区的一座湿岛，没有祁连山，内蒙古的沙漠就会和柴达木盆地的荒漠连成一片，沙漠也许会大大向兰州方向推进。正是有了祁连山，有了极高山上的冰川和山区降雨才发育了一条条河流，才养育了河西走廊，才有了丝绸之路。然而祁连山的意义还不仅于此。作为青海和甘肃的界山，就面积而言，祁连山在青海境内要多一些，但就知名度而言，似乎甘肃的祁连山要高。摄影/马培华</font></p>
<p>丝绸之路对于中国人之所以重要，是因为丝绸之路不仅仅是贸易之路，更重要的是文化之路，其中最重要的是佛教和伊斯兰教的传播就是沿着丝绸之路进行的，因此丝绸之路完全可以称之为宗教之路。</p>
<p>今年1、2月，我从兰州出发沿着河西走廊一直走到新疆的和田，这一路正是古代丝绸之路。沿途我看到了一个有意思的现象：这里处处可见伊斯兰教的影响，但是古迹和文物却是佛教的多。</p>
<p><img src="/2019/09/11/qi-lian-shan/014fc1eb6ec043238fae3e5d006d4e03_th.png" alt="横空出世的林带"></p>
<p><font color="red" size="2">是在祁连山中部拍摄的图片，在图中可以看到一种奇特的现象，就是在山的中部出现了一个横向的林带，这是在干旱区的大山上才有的一种植被分布现象。因为这里气候干旱，降水稀少，但是随着海拔的升高，降水量会逐渐增加，但到达某一高度后，又会逐渐减少，在山中那个降水量最大的海拔高度带，就会有植被或森林出现。在雪后，这种半山腰中的森林带，在白茫茫的大山上横空出世，非常具有美感。摄影/单之蔷</font></p>
<p>在于田县克里雅河的大河沿乡，这里已经深入到了塔克拉玛干沙漠的深处。夜晚我们住在一户维吾尔族的老乡家中。他们家紧邻克里雅河，周围是浩瀚的沙漠，没有第二户人家。即使在这沙漠的深处，宗教也是这里人们生活的重要内容。他们对伊斯兰教的虔诚给我留下了深刻的印象。傍晚我们围着火炉正在聊天，一会儿主人就终止了谈话，在炕上铺上一个毯子，主人和陪同我们的向导一起跪在上面，面对西方（麦加的方向）开始了祷告。晚上我们已经钻入了睡袋，但对面的屋中又传来了连续不断的声音，原来那是又一次祷告开始了。第二天早晨，我一醒来，就听到了主人祷告的声音。</p>
<p><img src="/2019/09/11/qi-lian-shan/89aad75809484df791ea9f358e185a6f_th.png" alt="祁连山南：雅丹地貌真壮观"></p>
<p><font color="red" size="2">在西祁连山山麓下的冷湖一带，有着荒漠地区独有的一种地貌：雅丹。雅丹地貌是一种被风吹出的地貌，在刮大风的荒漠地区，地表没有植被，并且是软硬适度的河湖相的松散沉积物。大风开始不断地吹走地面物质，由于地面有的地方硬一些，有的地方软一些，风把软处的物质吹走，留下沟槽；把硬的地方留下，形成高垄。长此以往，就在大地上留下了这种顺着风向一个个垄槽相间的地貌形态，如果风向复杂多变，又会使高垄的形态随之变化多端。柴达木盆地是一个雅丹的分布区，冷湖一带的雅丹极具观赏价值。摄影/单之蔷</font></p>
<p>然而古代这里的人们信奉的却是佛教。从这里向西大约90公里的沙漠中，就埋藏着英国人斯坦因挖掘的古代遗址——丹丹乌里克古城废墟，那里出土了大量珍贵的佛教文物。</p>
<p>在和田，我去了还没有正式开放的博物馆，我看到博物馆的造型是典型的伊斯兰式风格，但博物馆中的文物，却多是佛教的。在这里我还看到一个出土的唐代彩棺，制作极其考究，绘画非常精美，但棺木四面绘画的图案却是汉文化的题材：青龙、白虎、朱雀、玄武。可见这一带文化交流多么的频繁和充分。</p>
<p><img src="/2019/09/11/qi-lian-shan/5b053b6601374b9f944be0c271d09cd4_th.png" alt="祁连山北：丹霞地貌现五彩"></p>
<p><font color="red" size="2">在河西走廊的肃南裕固族自治县南面，祁连山中发育了大面积的丹霞地貌。丹霞地貌是我国科学家最先发现并命名的一种地貌类型，这种地貌极具美感和观赏价值。但是肃南的丹霞地貌与其他地方的丹霞地貌有很大的不同，而且不符合丹霞地貌的定义和基本特征。如丹霞地貌被定义为：以赤壁丹崖为特征的红色陆相碎屑岩地貌，或者说丹霞地貌的景观具有顶平（或顶斜）、身陡、麓缓的形态特征。我们看到肃南的丹霞地貌，既不顶平、身陡，也不麓缓，但它色彩美丽，不仅有红色的砂岩，还有黄色、绿色等色彩，五彩缤纷，灿若云霞，也许就是因为它的色彩，它才被归为丹霞地貌吧。摄影/王金</font></p>
<p>佛教正是沿着丝绸之路向东向中原传播的，只是到了10世纪，在现今喀什地区的喀喇汗王朝全面信奉伊斯兰教，并且灭掉了信奉佛教的古于阗国，使得这一地区开始了伊斯兰化的过程，伊斯兰教沿着丝绸之路代替佛教开始了东进历程。</p>
<p>无论是佛教还是伊斯兰教，都是沿着丝绸之路传播的，尤其是佛教，沿着丝绸之路我们能清楚地看到佛教传播的轨迹和演变，譬如从佛教的石窟分布，就可以寻出佛教传播的轨迹，从河西走廊开始，我们可以看到佛教的石窟沿着丝绸之路一直分布到中原。我们从河西走廊的西端开始列举，最西边的就是举世闻名的敦煌莫高窟，接下来是榆林石窟、昌马石窟、张掖市的文殊山石窟、马蹄寺石窟，再往东是武威市的天梯山石窟，越过黄河佛教的石窟继续延伸一直到天水的麦积山石窟。甚至可以说，山西大同的云冈石窟、河南洛阳的龙门石窟都是沿丝绸之路传播的佛教石窟的继续和延伸。</p>
<p><img src="/2019/09/11/qi-lian-shan/af71d6520431487f998e85f09fc040fa_th.png" alt="祁连山系所含山脉示意图"></p>
<p><img src="/2019/09/11/qi-lian-shan/7ca90181aa9641bba60a8ff2f131fd53_th.png" alt="冰川养育的哈拉湖"></p>
<p><font color="red" size="2">祁连山中部的哈拉湖，是祁连山区除了青海湖外，第二大的湖泊。哈拉湖的水源来自于周围的雪山。在图中可以看出冰川的融水形成了美丽的高山湖泊——哈拉湖。</font></p>
<p><img src="/2019/09/11/qi-lian-shan/c39c7f156aee470eb9d7a23e79380b4e_th.png" alt="祁连山大雪山地区冰川的卫星影像图"></p>
<p><font color="red" size="2">这是祁连山大雪山的冰川分布图，大雪山位于祁连山西部，极端干旱，但大雪山上却发育了很好的冰川，在一片赤裸裸的黄褐色的大山中，冰川像圣洁的雪莲花开放在山顶。其中老虎沟12号冰川是祁连山中最大的山谷冰川。</font></p>
<p>丝绸之路不仅仅是运送丝绸的，也不仅仅是传播宗教的。丝绸之路还有一个很重要的作用以前很少有人提及，那就是丝绸之路还是运送玉石的。著名的和田玉就是通过丝绸之路运往中原的。在我沿着丝绸之路考察时，我的同伴是中国社会科学院考古所新疆考古队的队长巫新华博士，他通过对古代玉矿的考古工作，证明先于丝绸，这条路运送的是玉石。在河南安阳商代殷墟遗址出土的玉器，经分析证明就是来自新疆的和田。</p>
<p>丝绸之路是如此的重要，然而人们看到的只是像河西走廊这样的路，至于这条路是怎样维系的，这条路为什么能存在？很少有人去深究。其实河西走廊之所以能存在，全赖祁连山，没有祁连山上的雪山和冰川融水，就没有流向河西走廊的河流，也就没有了河西走廊的绿洲，没有了绿洲，没有了河流，就没有了河西走廊，所以祁连山是丝绸之路的幕后英雄。</p>
<h2 id="失衡的祁连山"><a href="#失衡的祁连山" class="headerlink" title="失衡的祁连山"></a>失衡的祁连山</h2><p>当我从兰州出发，准备环祁连山绕行一周前，特意到兰州大学，拜访了兰州大学古籍研究所的所长吴景山教授。他在兰大历史系读书时，曾有过惊人的壮举，就是骑自行车走完了中国境内的丝绸之路。他对河西走廊既十分了解，又有着深厚的情感。我邀请吴教授同行，他爽快地答应了。</p>
<p>如果不是亲自到河西走廊来，你很难想象河西走廊的富庶和繁荣。路上吴先生随口说出许多古时描述河西走廊富庶的诗词来：</p>
<p>“弱水西流接汉边，绿杨荫里系渔船”，这是写弱水河畔的；</p>
<p>“不望祁连山顶雪，错把甘州当江南”，这是写张掖的，张掖古称甘州；</p>
<p>“两行高柳沙淀暗，一派平湖水稻香。紫燕衔泥穿曲巷，白鸥冲雨过横塘。”这是说高台的；</p>
<p>而诗句：“稻花风里稻花香，妾去采花郎插秧”则透露了这里曾种植过双季稻的信息。</p>
<p>听了这些诗句，感到这里好像是江南水乡一样，可是这里向北不出几十公里，就是茫茫的腾格里沙漠。</p>
<p>车到了武威市，很远我就看到了“马踏飞燕”那个著名的雕塑耸立在一个巨大的拱形门上。这个得到郭沫若激赏，后来成为国家旅游局标志的汉代铜奔马，原件就是在武威出土的。吴教授告诉我，这种“马踏飞燕”的雕塑在武威已经出土了几十件，这说明武威是“天马”的故乡。</p>
<p>确实武威与马有着密切的关系，当我们离开武威向西行进，很快就到了山丹军马场，这一带历史上就是为朝廷养战马的地方。吴教授为我这个季节来，不能看到山丹马场那堪称中国最美的草原而遗憾，但我却为看到的汉代古长城遗迹而兴奋不已。我曾经在宁夏看到过汉代的古长城，但山丹的古长城不知比宁夏保留的好多少倍，这里的古长城高大、完整，长达几公里。天刚刚下过一场雪，大地洁白，黄色的夯土而成的长城在祁连山下绵延起伏。</p>
<p><img src="/2019/09/11/qi-lian-shan/cf03c122ccec485482d737fa07578d22_th.png" alt="没有祁连山，就不可能有敦煌"></p>
<p><font color="red" size="2">敦煌是一颗世界级的文化明珠，人们为敦煌雕塑和壁画的精美所震撼，每天都有来自世界各地的人来敦煌朝圣。为研究敦煌藏经洞出土的文物，诞生了一门世界性的学问：敦煌学。但是来到敦煌的人们，首先会问的一个问题是，为什么在一片沙漠之中会出现敦煌莫高窟这样一块宗教和艺术的高峰地带？从上图中可以俯瞰敦煌莫高窟，我们看到敦煌的莫高窟显然是沙漠中的一块绿洲，是莫高窟前的一条河流——党河，养育了莫高窟的文化和艺术。</font></p>
<p>山丹的长城之美，吸引了我们的一位摄影师朋友，他竟在这里买了一处房子，接待摄影界的朋友来此拍长城及其周围的古迹和自然景观。我们找到了他的房子，想让他给我们带路，去看长城，但门锁着，人不在，我们只好自己前往。</p>
<p>离开山丹向西就是河西走廊中最大的城市张掖。在张掖，吴教授带我们去看了他曾经考察过的黑水国古城。遗憾的是张掖还有一些非常值得拜访的古迹由于时间关系不能前往，譬如大佛寺的大佛。这大佛据说是全国最大的卧佛，由于供奉在大佛寺的大殿里，大殿空间有限，没有摄影师能拍到这大佛完整的图片，因此这大佛除了到过大佛寺的人，很少有人知道张掖这里还有如此大的卧佛。</p>
<p><img src="/2019/09/11/qi-lian-shan/1640260632f74b8fb697583fbccf4f83_th.png" alt></p>
<p><font color="red" size="2">敦煌的月牙泉，月牙泉的一汪碧水，也与从祁连山上流下来的党河密切相关，如果没有党河流入沙漠，沙漠中的地下水就不会这样浅。</font></p>
<p>第二天，天还没亮，我们就离开了张掖，出城不远，我们遇到了一条河。太阳就要升起了，在蒙蒙的晨光中，可以看到河水并没有封冻，水面上弥漫着雾气，我意识到这就是大名鼎鼎的黑水河。这条从祁连山深处流出的，由冰川融水汇流而成的黑水河古时候一直流到了现今的内蒙古的额济纳旗，在那里曾经形成了一个浩大的湖泊——居延海，并养育了一个古城——黑城子。那里曾经出土几万枚汉代的木简，轰动了考古界。如今由于冰川的退缩，水量的减少，居延海已经消失了。但那里由黑河水养育的额济纳沙漠中的胡杨林，还在沙漠中顽强地生存着，那里的胡杨林，被称为“最美的胡杨林”。</p>
<p>由黑河我想到了河西走廊的河流，是祁连山北坡流下来的一条条河流，养育了河西走廊的一个个绿洲和城市，而且是一条河流对应一座城市。从河西走廊的东面算起，石羊河对应着武威，金昌市对应着大西河，张掖市对应着黑河，酒泉市和嘉峪关市对应着北大河，玉门市对应着昌马河，敦煌市对应着党河。甚至是河流水量的大小而不是所辖的土地面积，决定了城市的规模。譬如因为黑河在这些河中水量最大，因此张掖也就成了河西走廊最大的城市。</p>
<p><img src="/2019/09/11/qi-lian-shan/80139f5702074c42978055b1af794ddf_th.png" alt="敦煌的母亲河——以祁连山冰川融水作为水源的党河。"></p>
<p>在嘉峪关市，甘肃著名的摄影师王金先生带我们去看长城博物馆，这里是明代长城的最西端，嘉峪关之所以建在这里，因为这里有从祁连山上流下来的北大河。明代是一个在国土和疆域上最萎缩的朝代，汉唐时的长城远远地修到了敦煌的西边，其中玉门关和阳关向西伸进了沙漠之中，然而这两个名关，也没有离开从祁连山上流下来的河流，玉门关紧邻着疏勒河（由于上游截水，今天疏勒河已经流不到玉门关了），阳关像敦煌一样靠的是党河。</p>
<p>当我们在敦煌看完了莫高窟，奔向鸣沙山和月牙泉时，已经是下午5点多钟了。虽然这里比北京太阳落下得晚，但是月牙泉风景区的工作人员已经下班了，是我们的朋友敦煌研究院摄影部的主任吴健先生找到景区的负责人，我们才如愿以偿看到了月牙泉和鸣沙山。许多人对月牙泉的泉水出现在高大的沙丘之间，并且永不枯竭感到神奇。其实很好解释，是祁连山的雪山冰川的融水渗入到了地下，抬高了地下水位，使这一带的沙丘下面就是水。在阳关我们看到了一个名为南湖的湖泊，这个湖泊的出现同月牙泉是一个道理。而且在阳关附近，有一个叫葡萄沟的小村庄，村庄里有一道道水渠，用来灌溉葡萄，这个村庄在一个沙丘围成的凹处，地下水自动涌出来，这和月牙泉一样。</p>
<p><img src="/2019/09/11/qi-lian-shan/e2c84a400f1c4d5d93c8d2303cf9b480_th.png" alt="敦煌的另一面：市井生活"></p>
<p><font color="red" size="2">敦煌以莫高窟中的宗教艺术举世闻名，但莫高窟中的那些色彩艳丽、造型生动准确的雕塑，还有那些画在墙上的场面宏大、想象丰富、人物逼真的举世无双的壁画，并不是艺术家的个人创作，那都是一些世俗之人为了佛教信仰或某种心愿，请工匠在洞中雕塑或绘画的，那些雕塑和壁画都有在俗世的供养人，没有古代敦煌（西汉设敦煌县属酒泉郡、隋唐时称瓜州、沙州、敦煌郡）市井社会的繁荣，就不会有辉煌的敦煌艺术。要想象一下当年的敦煌居民，就看一下这张今天拍摄的敦煌的集市。摄影/孙志军</font></p>
<p>敦煌紧靠中国最干旱的地方——罗布泊，敦煌周围都是沙漠，敦煌之所以能存在全赖党河，党河能存在是因为祁连山西端的极高山上有冰川。</p>
<p>站在阳关的古遗址边，耳边响起王维那著名的诗句：劝君更尽一杯酒，西出阳关无故人。</p>
<p>这时我才意识到沿着河西走廊这一路走来，我们遇到了多少朋友，得到了多少朋友的帮助。</p>
<p>但是想想下面的行程，竟然想不到还会碰到什么朋友，真的是“西出阳关无故人”了，虽然我不是向西，而是掉头向东回返兰州，但是我要走的是祁连山的南面，要从甘肃进入青海了。其实这和西出阳关差不多，虽然是向东，但是要进入柴达木盆地了，进入少数民族的区域了。</p>
<p><img src="/2019/09/11/qi-lian-shan/73d66372976c495e9efb72aaf80fdb5c_th.png" alt="img"></p>
<p><font color="red" size="2">在夕阳和皑皑白雪的映照下，祁连山下的嘉峪关更显得雄浑和苍凉。如今的嘉峪关城楼是明代修建的，高大雄伟的城楼恰恰反映了明王朝对远方的威慑力不够，不得不靠长城的坚固来弥补。在明代，中央王朝的势力和疆域范围大大地萎缩，已经完全不能和汉唐时代相比。汉代的长城早已修到了敦煌以西的玉门关和阳关，那里才是万里长城的最西端。到了清代，清王朝的极盛期，气吞万里如虎，根本就不屑于建长城，而是把王朝的统治推到了中亚地区，当时的新疆首府建在了今日边境地区的伊犁。清王朝的伊犁将军坐镇那里管理那一带现今已经不属于中国的地区。摄影/王金</font></p>
<p>党金山口是祁连山与阿尔金山的连接处，这里应该算作祁连山的最西端了。车开始爬坡，党金山口在我的心目中一直很神圣，因为它是两座雄伟大山祁连山和阿尔金山相遇的地方。2004年冬天我在柴达木的东台吉乃尔盐湖，曾经想翻越它去敦煌，但正逢大雪，人们说路难走，没有成行，今天却是从甘肃方向来翻越它，进入青海，不知会有什么样的感受。车的左面就是祁连山的西端，这里极端的干旱，降水稀少，一年只有几十毫米。扑入眼帘的是寸草不生的裸山，山峦起伏，基岩裸露，一片赭黄色，有些山麓下堆满了沙丘。右面的阿尔金山完全一样，看不出它们二者有何区别。</p>
<p>车终于爬上了垭口，我们停车下来活动，在野外，我们开车翻越大的山脉，一般爬上垭口，都会停车下来，这仿佛有点仪式的味道，就像藏民翻越垭口时，抛洒龙达（一种画有宗教图案的硬卡片），口中呼喊“雅拉索……”一样。</p>
<p><img src="/2019/09/11/qi-lian-shan/c4246899c15e4506b539a170b59dde47_th.png" alt="丝绸之路：依稀驼铃声"></p>
<p><font color="red" size="2">河西走廊是丝绸之路最重要的部分，当年商旅络绎不绝，如今已经很难看到丝绸之路的遗迹。河西走廊的城市与其他地方的城市已经看不出有何区别，在嘉峪关市的大街上，我们看到路边的骆驼雕塑，似乎唤起了我们关于这个城市历史的记忆。摄影/单之蔷</font></p>
<p>看到路牌上写着党金山口的海拔高度是3648米，这比我估计的要低，而且翻越党金山口也比我想象的要轻松些。翻过山口，我以为接着就是陡峭的下山路，然而不是，展现在我面前的是一片辽阔的冲积平原，只不过有些倾斜。其实这就是柴达木盆地，我们已经进入了柴达木盆地。柴达木盆地是一个高原盆地，平均海拔2700米—3500米。如果说祁连山的北面是河西走廊的话，那么它的南面就是柴达木盆地。</p>
<p>眼前是一望无际的戈壁滩,没有一个人影,也看不见任何动物。我们想去寻找风蚀地貌——雅丹，听说冷湖一带有亚洲面积最大的雅丹群，这是很有诱惑力的。我们把车开向冷湖，这个当年石油开发的重镇，如今人员已经转移，房屋拆除，只剩下一片残垣断壁在中午的阳光下沉默。我们在冷湖加满了油，然后离开冷湖向西开去，沿途看到了一些雅丹，但都不如我们想象的那样壮观。当我们决定返回时，面临着两种选择：一是顺原路返回，重新回到党金山口，然后沿215国道，向鱼卡方向前进，目标是大柴旦镇。这除了走回头路外，还要多走近百公里的路，但这条路，全是柏油路，好走、安全；还有一种走法是沿着一条石油勘探时开辟的土路向南一直开去，在最新出版的青海省地图上可以清楚地看到这条路会与青海到新疆的315国道会合，这样走从地图上看，会少走路，但是这条路，没人走过，不安全。但是走这条路，很可能看到我们想看到的雅丹群。</p>
<p><img src="/2019/09/11/qi-lian-shan/a7727ffe3f504a21925e423ca5a5b757_th.png" alt="长城与祁连相伴而行"></p>
<p><font color="red" size="2">在河西走廊，长城与祁连山好像是形影相伴、结伴而行。祁连山在南，长城在北，河西走廊与丝绸之路在中。在河西走廊的张掖山丹一带，长城遗迹保存得还好，还有长长的汉长城蜿蜒在茫茫荒原上。摄影/单之蔷</font></p>
<p>正是这一点吸引着我，最后我们决定走那条土路。当我们沿着那条土路一直向南开去，真的看到了壮观的雅丹群，雅丹高大、年轻、千姿百态，有时像千万条鲸鱼跃出沙海；有时像一个消失了的古老帝国，留下了一座座王陵；有时则像是一座废弃的城池，城墙、宫殿、屋宇鳞次栉比……，我们的车在雅丹群中迂回前进。</p>
<p>当我们走出雅丹群，天已经黑了，这时我才发现一个问题，就是我们没有碰到一辆车从对面开来，但是我们想这条路毕竟是石油勘探修的路，没有车正常，只要能与315国道会合就行了。我们终于把车开到了315国道上，但是我们还是碰不到车，这就不正常了，315国道，怎么能没有车呢？道路的状况也不对，在车灯的照射下，我们看到道路不仅坑坑洼洼，还经常被沙子掩埋，时常能看到流沙在道路上流窜。有时由于看不清道路，不得不下车查看。</p>
<p><img src="/2019/09/11/qi-lian-shan/5a52d5f976cb498b8a7cb792c52135ec_th.png" alt="祁连山有一个冰雪圈"></p>
<p><font color="red" size="2">祁连山属于高山和极高山的世界，海拔4000米以上的山地面积占整个山区面积的三分之一以上，因此气温较低，海拔2000-3000米以上的山上年均气温低于0℃，祁连山区平均雪线高度是4700米，在4700米以上的山峰上，普遍发育着冰川。这些冰川在夏季的融水是河西走廊和柴达木盆地各个河流的主要补充水源，因此祁连山的冰川关系到河西走廊和柴达木盆地各个绿洲的命运。随着全球变暖趋势的加剧，祁连山的冰川已经出现了普遍退缩的现象，如果这一趋势继续下去，祁连山中的一些小型冰川将消失。而祁连山冰川分布的特征之一就是小型冰川多，分布状态分散，这种小型冰川在全球变暖的趋势下，比较容易融化消失，这将对河西走廊和柴达木盆地的生态发生影响，这种现象科学家们正在密切关注。图为祁连山中部山脉山脊上的冰川，可以看到这里是一片白皑皑的冰雪世界。</font></p>
<p>更糟糕的是，油箱里的油越来越少了，路两旁一片黑暗，不见一丝光亮，显然没有任何加油的地方，手机也没有任何信号。</p>
<p>在忐忑不安的心情中,我们顺着时隐时现的路一直向东开去,好在我们的车是四轮驱动的越野车,再坏的路都能应付,只是油没有了怎么办？</p>
<p>当我们的油只够跑40多公里时，前面终于看到了灯光，原来我们到了一个叫南八仙的地方。后来才知道这个地方之所以叫南八仙，是因为当年有8个来自南方的女地质队员在这里勘探石油，遭遇沙尘暴迷路在雅丹群里，最后全部死在这个地方。为了纪念这八位女地质队员，人们把这个地方命名为“南八仙”。</p>
<p><img src="/2019/09/11/qi-lian-shan/fd45c92dec504b9e84ea73c8cdedc414_th.png" alt></p>
<p><font color="red" size="2">祁连山中段北大河流域内的“七一”冰川，它是祁连山区的冰川中被考察研究最早的一条冰川。</font></p>
<p>我们看到了许多车聚集在这里，车全部是那种车轮有一人多高的奔驰公司产的沙漠越野车——尤尼莫克。他们显然是石油部门的，但我们不知他们在这里做什么，我们问他们：这条315国道为什么没有车？他们告诉我们，这条道早已经废弃了，315国道已经改走另一条路了。看来地图不仅给我们洗了脑，这种不能及时更新的地图还可能让人迷失在公路已经废弃、没有人烟的地方。</p>
<p>这就是我们在祁连山南面，在柴达木盆地遭遇的一段小插曲。总之，在祁连山南面的道路上行进，不仅“故人”很难遇到，就是城市也很难碰到了。整个祁连山的南缘，只有两座大一点的城市，一是德令哈市，还有一座大城市就是青海的省会西宁了。这与祁连山北面的河西走廊的情况完全不同。祁连山北面一个城市接着一个城市，而且北面的城市随便哪一个都比德令哈市大、人口多。德令哈市人口6万，但河西走廊最小的市敦煌，人口也是13万多。不仅是城市、人口，就是绿洲的面积和农业规模，北面河西走廊也比南面大得多。</p>
<p><img src="/2019/09/11/qi-lian-shan/41e60d3351644729aa9360d25be9ca44_th.png" alt="位于土尔根达坂山塔塔棱河流域的敦德平顶冰川，又称敦德冰帽。它的面积57平方公里，厚度约75米，是整个祁连山区面积最大的冰川。"></p>
<p>由此我发现祁连山是一个两边人文现象极不平衡的山。山北是河西走廊，山南是柴达木盆地，从历史上看，祁连山北，也就是河西走廊早在汉代就在现今的武威、张掖、酒泉、敦煌设立了河西四郡，而且玉门关和阳关已经向西超过了祁连山的最西端，但是在祁连山南，情况就大不一样了。汉代王莽在青海湖边设置了西海郡，西海郡后来很快就废弃了，后来即使中原汉王朝恢复了对青海湖地区的统治，也总是时断时续。可以说，就文化而言，在祁连山北面的河西走廊，汉文化一直延伸到了祁连山的最西边，但在祁连山的南边，汉文化则徘徊在祁连山的东部西宁一带。</p>
<p>虽然祁连山北的河西走廊人文胜于祁连山南，但是上帝似乎是公平的，他把更多的自然美景给予了祁连山南面，其实仅仅给一个青海湖就足矣，但这还不够，祁连山南面有更多的湖泊发育。在祁连山主脊线的一部分——南疏勒南山的南面有一个高山咸水湖——哈拉湖，周围雪峰巍峨，冰川磅礴，她的北面有整个祁连山系的最高峰5808米的团结峰（岗则吾结），她的西南有祁连山中面积最大的冰川敦德大冰帽，这里应是祁连山系中除了青海湖地区外，又一个美景集中的地带。</p>
<p><img src="/2019/09/11/qi-lian-shan/5fdafad70dcd4169946a89a6700dc275_th.png" alt="祁连山中断地形剖面图（酒泉市——柴达木山），从这个图中可以看出祁连山北面低南面高的地势特点。图中山峰虚线以上的白色部分是终年积雪的部分。"></p>
<p>除了哈拉湖，就在德令哈市的西南有一对神奇的姊妹般的湖泊，一个叫可鲁克湖，一个叫托素湖，两湖紧邻，中间有河相连，从西宁到格尔木去的铁路正好从中间穿过，这两个湖的神奇在于：可鲁克湖是淡水湖，而托素湖却是咸水湖。这两个湖完全可以作为我国东部外流区的淡水湖与西部内流区的咸水湖的代表，它们可以形象地说明为什么一个湖是淡水湖而相距咫尺的另一个湖却是咸水湖，这其中的奥秘都在于连接这两个湖的那段短短的小河上，这段小河决定了流进可鲁克湖的水有进有出，带进湖中的盐又流走了，但是流走的带有盐的水却流进了托素湖，托素湖没有出口，是靠湖面的蒸发来维持湖水量的平衡，但是蒸发的是水，盐却留下了，所以托素湖是咸的。有趣的是，我们到这里时，虽是冬季12月，但是在可鲁克湖中，却有来自江苏的人在这里养大闸蟹。我问他们，托素湖能养大闸蟹吗？他们直摇头说：“不能。”冬天了，他们把螃蟹从湖中捞出来，养在湖边的池子里，我们买了一些螃蟹，在德令哈市的一个餐馆里，我们把这些螃蟹吃了，味道很不错。</p>
<p>祁连山南，还有一些湖，但都是咸水湖了，从西向东有大苏干湖、宗马海湖、依克柴达木湖、巴戛柴达木湖、尕海、希里沟湖、茶卡盐湖等，如果把柴达木盆地中心地带的盐湖都算上的话，那祁连山南的湖泊就更多了。可以说祁连山南面湖泊众多，是祁连山南北差异中的重要一点。</p>
<p>祁连山南面，自然景观给人的美感要优于山北河西走廊，这是我的观点。且不说那些湖泊，仅是冷湖一带的雅丹地貌也足以让人震撼了。</p>
<p>祁连山南面，不仅富有风景，更富有资源，柴达木盆地的石油和天然气、盐湖中的盐和稀有金属正在使这片人烟稀少的地方，日益繁盛起来。</p>
<p>人文不足，自然补之；地上不足，地下补之。这就是上帝之道。</p>
<h2 id="为何祁连山中叫某某南山的多？"><a href="#为何祁连山中叫某某南山的多？" class="headerlink" title="为何祁连山中叫某某南山的多？"></a>为何祁连山中叫某某南山的多？</h2><p>我还发现一个有趣的现象，祁连山两边的失衡，从祁连山系的一个个山名中也表现出来，譬如，祁连山系中的诸多山，以南山命名的很多，却没有一个以北山命名的大山。如从东面有青海南山、走廊南山、托来南山、疏勒南山、野马南山、党河南山等。这些山为什么都叫某某南山，而不叫某某北山，原因何在？</p>
<p>其实原因就在于人们看祁连山系中的一列列近似平行的大山，基本上都是站在山的北边向南看，因此看到的山都是南山，同样一座山，如果是站在南边向北看，就成了北山。祁连山中的只有南山无北山，说明早期人类进入祁连山中，最先是从北面进入的。因此他们看到的山总是在南面，因此他们把这些山一一命名为某某南山。</p>
<p>实际上也是如此，因为祁连山系中的一列列大山，总的趋势是北低南高。从北面进入要比从南面进入容易，如以中部为例，覆雪山峰的平均高度，从北向南，最北面的走廊南山为4937米，向南托来南山为5046米，疏勒南山5373米，最南的柴达木山则高达5483米。很明显最早进入祁连山中的人，一定是北面的人，更重要的是北面是河西走廊，海拔低，绿洲一个接着一个，很适合人类生存，但是祁连山的南面，则是海拔高达2700—3500米的高原盆地柴达木，干燥、寒冷，河流稀少，绿洲匮乏。因此人文不如河西走廊繁盛发达。正是这自然和人文的双重原因决定了人们是站在河西走廊的立场和角度来看祁连山，给祁连山命名的，而不是站在柴达木的立场和角度。有一个例外，就是在祁连山南面的西宁，它的北面有一条祁连山的分支山脉，叫做互助北山，这是祁连山诸多山中少有的叫某某北山的山，看来好像是一个例外，其实道理并不例外，就是山哪一面的人文鼎盛，就会被人从这种角度去命名。即山南人文盛，山被叫北山；山北人文盛，山被叫南山；东西走向的山是如此，南北走向的山，也不例外，只不过由把南山北山改为东山西山而已。</p>
<h2 id="为何祁连山人文景观如此失衡？因为玫瑰花向北开放"><a href="#为何祁连山人文景观如此失衡？因为玫瑰花向北开放" class="headerlink" title="为何祁连山人文景观如此失衡？因为玫瑰花向北开放"></a>为何祁连山人文景观如此失衡？因为玫瑰花向北开放</h2><p>前面我们已经说过了祁连山的南北人文景象的失衡。有一组数字：祁连山北面的河西走廊，有440多万人口、生畜750多万、耕地70多万顷、可耕荒地120万顷、上千个工矿企业；而祁连山南面的柴达木盆地和青海湖地区，人烟稀少，大部分地方人口密度仅是每平方公里1－10人左右，只有极少的耕地。</p>
<p>为什么祁连山会出现这种两边极不平衡的现象?</p>
<p><img src="/2019/09/11/qi-lian-shan/3610d4a372cd469ca0fce07e20c7ae91_th.png" alt></p>
<p>我们如果面对一张祁连山的地图，就可以看出一些门道。你会发现从祁连山北坡流向河西走廊的河流比从祁连山南坡流向柴达木的河流数量要多得多，河西走廊号称有5大水系：从东向西为石羊河水系、黑河水系、北大河水系、疏勒河水系、党河水系。而祁连山南坡的柴达木盆地的几条河哈尔腾河、鱼卡河、塔塔棱河、巴音郭勒河都是流量小、长度短的小河，无法与河西走廊的河流相比。</p>
<p>我们知道无论是河西走廊还是柴达木盆地，都是绿洲型的经济，是河流养育了绿洲。据一位专家对祁连山地区降水的研究，结论是：山区的降水比平原多得多。比如黑河地区，平原地区年降水仅80—200毫米，这样的降水量，在平原几乎不能形成径流，可是黑河流域在山区的降水量却达到200—600毫米，降水随海拔高程的增加，每100米大约增加10—25毫米。其他河流也与黑河类似。是祁连山拦截了云团水汽，迫使它们冷凝降水，又是祁连山汇集了径流，形成了河流，养育了绿洲。</p>
<p><img src="/2019/09/11/qi-lian-shan/093dad3c48894aa792f7fdf5bfd374ae_th.png" alt="祁连山区各山脉冰川统计"></p>
<p>如果你仔细地看地图，你还会注意到一个有意思的现象，就是河西走廊的河流分布得很均衡，彼此的距离大致相等，这一点在古代社会是很重要，因为在以人或畜为运输工具的古代，如果河流或绿洲相距很远，人畜很难到达，那么绿洲间的交通路线将不可能维系。如果那样河西走廊的走廊作用将丧失。</p>
<p>河西走廊河流分布的均衡，其实是冰川分布的均衡，因为河西走廊中五大河流的源头都是冰川，而且冰川对这些河流水量的补给占到1/4—3/5，越向西，冰川对河流的补给作用越大，西边的党河，几乎一半的水量来自冰川，党河是敦煌的母亲河，可以说是冰川养育了敦煌。</p>
<p><img src="/2019/09/11/qi-lian-shan/67fa8e7c530441c9a2e663b55b7c0b97_th.png" alt="玫瑰花向北开放"></p>
<p><font color="red" size="2">从下面这个玫瑰图，可以看出玫瑰花向北方开放，就是说祁连山中的冰川无论是条数还是面积都是北多南少。看了它，我们也应该明白了为什么河西走廊城市相连，人文鼎盛，而柴达木盆地却人烟稀少，一片荒漠。这个图的画法是，把祁连山总的冰川条数和总面积分成100份，把其中的4份作为一个长度和面积单位按东、西、南、北、东北、西北、东南、西南共8个方向来画图。</font></p>
<p>祁连山北坡的冰川东西方向均衡分布，造就了大致均衡的河西走廊的五大河流，这五大河流造就了五大绿洲，五大绿洲连缀成了河西走廊，河西走廊维系了一条伟大的丝绸之路。这是祁连山的伟大功勋。</p>
<p>但是祁连山北面东西方向的冰川分布均衡，南北向的冰川分布却很不均衡，就是山北面的冰川数量和冰储量远远大于山南面，这正是山北和山南人文景观不均衡重要的自然方面的原因。据专家统计，河西走廊五条河流的流域内共有冰川2166条，冰川面积1308平方公里，冰储量60立方公里；而柴达木盆地的4条河流与青海湖和哈拉湖水系共有冰川541条，冰川面积582平方公里，冰储量32立方公里。由此可以看出冰川的南北分布是多么不均衡啊。</p>
<p><img src="/2019/09/11/qi-lian-shan/21371d31d2584f29828c7c638f263c31_th.png" alt="阳关之外山万重"></p>
<p><font color="red" size="2">阳关在敦煌的西面，深入沙漠之中。祁连山在这里已经结束了，祁连山与长城结伴而行的旅程也结束了，但是阳关和玉门关就像长城伸出的触角，极力要向西挺进，前方已是浩瀚的罗布泊荒原和塔克拉玛干大沙漠，但是天山已经在西北方向出现，阿尔金山和昆仑山在西已开始迎接祁连山，因此丝绸之路在此分成南北两道继续前行，祁连山已经完成了它的使命。它把中华引向了西部，引向了天山和帕米尔高原。摄影/孙志军</font></p>
<p>冰川学中有一个很形象也很浪漫的表示冰川分布的方向、条数、面积的方法，并且十分形象十分浪漫地称之为“玫瑰结”或“玫瑰图”，看一眼祁连山区冰川分布的“玫瑰图”，我们就会对祁连山冰川南北分布的不均衡有一个十分清晰的印象了，在这个“玫瑰图”上，我们会一目了然地看到：玫瑰花是向着北方开放。这正是祁连山两边人文景观失衡的原因。</p>
<p>就要结束本文时，我想起了前面我说过：祁连山是一个伸向沙漠中的湿岛，全国只有一座山与他相像，那就是新疆的天山，而且我说他们像一对兄弟，在沙海中遥相呼应，并且我问：他们在沙海中相望和呼唤的形象有何意义？</p>
<p>现在我可以回答这个问题了。祁连山对中国最大的贡献，不仅仅是河西走廊，不仅仅是丝绸之路，不仅仅是引来了宗教、送来了玉石，更重要的是祁连山通过它造就和养育的冰川、河流与绿洲做垫脚石和桥梁，让中国的政治和文化渡过了中国西北浩瀚的沙漠，与新疆的天山握手相接了，中国人在祁连山的护卫下走向了天山和帕米尔高原。据说张掖之名是取“断匈奴之臂，张中国之掖（腋：手臂与身体相接处）”之意。河西走廊就是中国之臂，它为中国拽回了一个新疆。没有祁连山，就没有河西走廊；没有河西走廊，就没有了新疆。这就是祁连山的意义。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.dili360.com/cng/article/p5350c3d6d0e5e42.htm" target="_blank" rel="noopener">幕后英雄祁连山</a> 文章出自：中国国家地理 2006年第03期 作者： 单之蔷</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/09/05/java8-new-feature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/05/java8-new-feature/" class="post-title-link" itemprop="url">Java8新特性</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-05 10:55:01" itemprop="dateCreated datePublished" datetime="2019-09-05T10:55:01+08:00">2019-09-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-17 10:02:43" itemprop="dateModified" datetime="2019-09-17T10:02:43+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/Java8新特性/" itemprop="url" rel="index"><span itemprop="name">Java8新特性</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">15k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">14 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h1><p>在Java8之前，接口中<strong>只能</strong>包含抽象方法。那么这有什么样弊端呢？比如，想再Collection接口中添加一个spliterator抽象方法，那么也就意味着之前所有实现Collection接口的实现类，都要重新实现spliterator这个方法才行。而接口的默认方法就是<strong>为了解决接口的修改与接口实现类不兼容的问题，作为代码向前兼容的一个方法</strong>。</p>
<p>那么如何在接口中定义一个默认方法呢？来看下JDK中Collection中如何定义spliterator方法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到定义接口的默认方法是通过<strong>default</strong>关键字。因此，在Java8中接口能够包含抽象方法外还能够包含若干个默认方法（即有完整逻辑的实例方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"breath!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMethodTest defaultMethod = <span class="keyword">new</span> DefaultMethodTest();</span><br><span class="line">        defaultMethod.breath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果为：breath!</span><br></pre></td></tr></table></figure>

<p>可以看出<strong>IAnimal</strong>接口中有由default定义的默认方法后，那么其实现类DefaultMethodTest也同样能够拥有实例方法<strong>breath</strong>。但是如果一个类继承多个接口，多个接口中有相同的方法就会产生冲突该如何解决？实际上默认方法的改进，使得java类能够拥有类似多继承的能力，即一个对象实例，将拥有多个接口的实例方法，自然而然也会存在方法重复冲突的问题。</p>
<p>下面来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDonkey</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"IDonkey run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHorse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Horse run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> <span class="keyword">implements</span> <span class="title">IDonkey</span>,<span class="title">IHorse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMethodTest defaultMethod = <span class="keyword">new</span> DefaultMethodTest();</span><br><span class="line">        defaultMethod.breath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个接口：IDonkey和IHorse，这两个接口中都有相同的run方法。DefaultMethodTest实现了这两个接口，由于这两个接口有相同的方法，因此就会产生冲突，不知道以哪个接口中的run方法为准，编译会出错：<code>inherits unrelated defaults for run.....</code></p>
<blockquote>
<p>解决方法</p>
</blockquote>
<p>针对由默认方法引起的方法冲突问题，<strong>只有通过重写冲突方法，并方法绑定的方式，指定以哪个接口中的默认方法为准</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> <span class="keyword">implements</span> <span class="title">IAnimal</span>,<span class="title">IDonkey</span>,<span class="title">IHorse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultMethodTest defaultMethod = <span class="keyword">new</span> DefaultMethodTest();</span><br><span class="line">        defaultMethod.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IHorse.<span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultMethodTest重写了run方法，并通过 <code>IHorse.super.run();</code>指定以IHorse中的run方法为准。</p>
<p><strong>静态方法</strong></p>
<p>在Java8中还有一个特性就是，接口中还可以声明静态方法，如下例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"breath!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数式接口FunctionInterface与lambda表达式"><a href="#函数式接口FunctionInterface与lambda表达式" class="headerlink" title="函数式接口FunctionInterface与lambda表达式"></a>函数式接口FunctionInterface与lambda表达式</h1><p>参见: <a href="https://sainpo.top/2019/09/03/java8-lambda/" target="_blank" rel="noopener">https://sainpo.top/2019/09/03/java8-lambda/</a></p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用是为了进一步简化lambda表达式，通过类<strong>名或者实例名与方法名的组合来直接访问到类或者实例已经存在的方法或者构造方法</strong>。方法引用使用<strong>::</strong>来定义，<strong>::</strong>的前半部分表示类名或者实例名，后半部分表示方法名，如果是构造方法就使用<code>NEW</code>来表示。</p>
<p>方法引用在Java8中使用方式相当灵活，总的来说，一共有以下几种形式：</p>
<ul>
<li>静态方法引用：ClassName::methodName;</li>
<li>实例上的实例方法引用：instanceName::methodName;</li>
<li>超类上的实例方法引用：supper::methodName;</li>
<li>类的实例方法引用：ClassName:methodName;</li>
<li>构造方法引用Class:new;</li>
<li>数组构造方法引用::TypeName[]::new</li>
</ul>
<p>下面来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Car car = Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">            cars.add(car);</span><br><span class="line">        &#125;</span><br><span class="line">        cars.forEach(Car::showCar);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">(Factory&lt;Car&gt; factory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> factory.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">learn.MethodReferenceTest$Car@<span class="number">769</span>c9116</span><br><span class="line">learn.MethodReferenceTest$Car@<span class="number">6</span>aceb1a5</span><br><span class="line">learn.MethodReferenceTest$Car@<span class="number">2</span>d6d8735</span><br><span class="line">learn.MethodReferenceTest$Car<span class="meta">@ba</span>4d54</span><br><span class="line">learn.MethodReferenceTest$Car@<span class="number">12</span>bc6874</span><br></pre></td></tr></table></figure>

<p>在上面的例子中使用了<code>Car::new</code>，即通过构造方法的方法引用的方式进一步简化了lambda的表达式，<code>Car::showCar</code>，即表示实例方法引用。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Java8中有一种新的数据处理方式，那就是流Stream，结合lambda表达式能够更加简洁高效的处理数据。Stream使用一种类似于SQL语句从数据库查询数据的直观方式，对数据进行如筛选、排序以及聚合等多种操作。</p>
<h2 id="什么是流Stream"><a href="#什么是流Stream" class="headerlink" title="什么是流Stream"></a>什么是流Stream</h2><p>Stream是一个来自数据源的元素队列并支持聚合操作，更像是一个更高版本的Iterator,原始版本的Iterator，只能一个个遍历元素并完成相应操作。而使用Stream，只需要指定什么操作，如“过滤长度大于10的字符串”等操作，Stream会内部遍历并完成指定操作。</p>
<p>Stream中的元素在管道中经过中间操作（intermediate operation）的处理后，最后由最终操作（terminal operation）得到最终的结果。</p>
<ul>
<li>数据源：是Stream的来源，可以是集合、数组、I/O channel等转换而成的Stream；</li>
<li>基本操作：类似于SQL语句一样的操作，比如filter,map,reduce,find,match,sort等操作。</li>
</ul>
<p>当我们操作一个流时，实际上会包含这样的执行过程：</p>
<p><strong>获取数据源–&gt;转换成Stream–&gt;执行操作，返回一个新的Stream–&gt;再以新的Stream继续执行操作—&gt;直至最后操作输出最终结果</strong>。</p>
<h2 id="生成Stream的方式"><a href="#生成Stream的方式" class="headerlink" title="生成Stream的方式"></a>生成Stream的方式</h2><p>生成Stream的方式主要有这样几种：</p>
<ol>
<li>从接口Collection中和Arrays：<ul>
<li>Collection.stream();</li>
<li>Collection.parallelStream(); //相较于串行流，并行流能够大大提升执行效率</li>
<li>Arrays.stream(T array);</li>
</ul>
</li>
<li>Stream中的静态方法：<ul>
<li>Stream.of()；</li>
<li>generate(Supplier s);</li>
<li>iterate(T seed, UnaryOperator f);</li>
<li>empty();</li>
</ul>
</li>
<li>其他方法<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
<li>BufferedReader.lines()</li>
</ul>
</li>
</ol>
<p>下面对前面常见的两种方式给出示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用Collection中的方法和Arrays</span></span><br><span class="line">        String[] strArr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(strArr);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(strArr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 使用Stream中提供的静态方法</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(strArr);</span><br><span class="line">        Stream&lt;Double&gt; stream3 = Stream.generate(Math::random);</span><br><span class="line">        Stream&lt;Object&gt; stream4 = Stream.empty();</span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i++);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream的操作"><a href="#Stream的操作" class="headerlink" title="Stream的操作"></a>Stream的操作</h2><p>常见的Stream操作有这样几种：</p>
<ol>
<li>Intermediate（中间操作）:中间操作是指对流中数据元素做出相应转换或操作后依然返回为一个流Stream，仍然可以供下一次流操作使用。常用的有：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip。</li>
<li>Termial（结束操作）：是指最终对Stream做出聚合操作，输出结果。</li>
</ol>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a><strong>中间操作</strong></h3><h4 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter(过滤)"></a>Filter(过滤)</h4><p>Filter接收一个判断用来过滤流中的所有元素. 这个操作是中间操作，它能够使我们对结果进行另一个流操作(<code>forEach</code>) . ForEach接受一个consumer操作对每一个过滤的流元素中. ForEach是一个终端操作. 它返回值void,所以我们不能调用另一个函数操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure>

<h4 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map(映射)"></a>Map(映射)</h4><p>对Stream中元素按照指定规则映射成另一个元素，将每一个元素都添加字符串“_map”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.map(str -&gt; str + <span class="string">"_map"</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>map方法是一对一的关系，将stream中的每一个元素按照映射规则成另外一个元素，而如果是一对多的关系的话就需要使用flatmap方法。</p>
<h4 id="concat-对流进行合并操作"><a href="#concat-对流进行合并操作" class="headerlink" title="concat(对流进行合并操作)"></a>concat(对流进行合并操作)</h4><p>concat方法将两个Stream连接在一起，合成一个Stream。若两个输入的Stream都时排序的，则新Stream也是排序的；若输入的Stream中任何一个是并行的，则新的Stream也是并行的；若关闭新的Stream时，原两个输入的Stream都将执行关闭处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)).</span><br><span class="line">	forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="distinct-对流进行去重操作"><a href="#distinct-对流进行去重操作" class="headerlink" title="distinct(对流进行去重操作)"></a>distinct(对流进行去重操作)</h4><p>去除流中重复的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<h4 id="limit：限制流中元素的个数"><a href="#limit：限制流中元素的个数" class="headerlink" title="limit：限制流中元素的个数"></a>limit：限制流中元素的个数</h4><p>截取流中前两个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h4 id="skip：跳过流中前几个元素"><a href="#skip：跳过流中前几个元素" class="headerlink" title="skip：跳过流中前几个元素"></a>skip：跳过流中前几个元素</h4><p>丢掉流中前两个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">输出结果：</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<h4 id="peek：对流中每一个元素依次进行操作，类似于forEach操作"><a href="#peek：对流中每一个元素依次进行操作，类似于forEach操作" class="headerlink" title="peek：对流中每一个元素依次进行操作，类似于forEach操作"></a>peek：对流中每一个元素依次进行操作，类似于forEach操作</h4><p>JDK中给出的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">            .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">输出结果：</span><br><span class="line">Filtered value: three</span><br><span class="line">Mapped value: THREE</span><br><span class="line">Filtered value: four</span><br><span class="line">Mapped value: FOUR</span><br></pre></td></tr></table></figure>

<h4 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted(排序)"></a>Sorted(排序)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        stream.sorted(Integer::compareTo).forEach(System.out::println);</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>sorted</code> 仅仅是创建一个排序后的视图操作，并没有操作排序返回的集合. 排序的 <code>stringCollection</code>并没有受到影响。</p>
<h4 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match(匹配)"></a>Match(匹配)</h4><p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true；</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true；</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true。</li>
</ul>
<p>如检查Stream中每个元素是否都大于5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> match = stream.allMatch(integer -&gt; integer &gt; <span class="number">5</span>);</span><br><span class="line">System.out.println(match);</span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a><strong>结束操作</strong></h3><h4 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h4><p>参见: <a href="https://www.jianshu.com/p/c0d5c3094324" target="_blank" rel="noopener">【译】java8之collector</a></p>
<h4 id="Count-统计"><a href="#Count-统计" class="headerlink" title="Count(统计)"></a>Count(统计)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = stream.filter(str -&gt; str.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h4 id="max-min-找出流中最大或者最小的元素"><a href="#max-min-找出流中最大或者最小的元素" class="headerlink" title="max/min(找出流中最大或者最小的元素)"></a>max/min(找出流中最大或者最小的元素)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(stream.max(Integer::compareTo).get());</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach(遍历)"></a>forEach(遍历)</h4><p>forEach方法前面已经用了好多次，其用于遍历Stream中的所元素，避免了使用for循环，让代码更简洁，逻辑更清晰。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="comment">// 1，2，3,4,5</span></span><br></pre></td></tr></table></figure>

<h4 id="Reduce-合并"><a href="#Reduce-合并" class="headerlink" title="Reduce(合并)"></a>Reduce(合并)</h4><p>这个终端操作完成一个流中元素合并操作通过给定的函数.返回的结果通过 <code>Optional来保存值</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure>

<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>为了解决空指针异常，在Java8之前需要使用if-else这样的语句去防止空指针异常，而在Java8就可以使用Optional来解决。Optional可以理解成一个数据容器，甚至可以封装null，并且如果值存在调用isPresent()方法会返回true。为了能够理解Optional。先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUserName</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，getUserName方法对输入参数并没有进行判断是否为null，因此，该方法是不安全的。如果在Java8之前，要避免可能存在的空指针异常的话就需要使用<code>if-else</code>进行逻辑处理，getUserName会改变如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getUserName</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是十分繁琐的一段代码。而如果使用Optional则会要精简很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getUserName</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Optional&lt;User&gt; userOptional = Optional.ofNullable(user);</span><br><span class="line">    <span class="keyword">return</span> userOptional.map(User::getUserName).orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java8之前的if-else的逻辑判断，这是一种命令式编程的方式，而使用Optional更像是一种函数式编程，关注于最后的结果，而中间的处理过程交给JDK内部实现。</p>
<h2 id="Optional-of-或者Optional-ofNullable"><a href="#Optional-of-或者Optional-ofNullable" class="headerlink" title="Optional.of()或者Optional.ofNullable()"></a>Optional.of()或者Optional.ofNullable()</h2><p>创建Optional对象，差别在于of不允许参数是null，而ofNullable则无限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数不能是null</span></span><br><span class="line">Optional&lt;Integer&gt; optional1 = Optional.of(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数可以是null</span></span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数可以是非null</span></span><br><span class="line">Optional&lt;Integer&gt; optional3 = Optional.ofNullable(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Optional-empty-：所有null包装成的Optional对象："><a href="#Optional-empty-：所有null包装成的Optional对象：" class="headerlink" title="Optional.empty()：所有null包装成的Optional对象："></a>Optional.empty()：所有null包装成的Optional对象：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(optional1 == optional2);<span class="comment">// true</span></span><br><span class="line">System.out.println(optional1 == Optional.&lt;Integer&gt;empty());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Object o1 = Optional.&lt;Integer&gt;empty();</span><br><span class="line">Object o2 = Optional.&lt;String&gt;empty();</span><br><span class="line">System.out.println(o1 == o2);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="isPresent-：判断值是否存在"><a href="#isPresent-：判断值是否存在" class="headerlink" title="isPresent()：判断值是否存在"></a>isPresent()：判断值是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// isPresent判断值是否存在</span></span><br><span class="line">System.out.println(optional1.isPresent() == <span class="keyword">true</span>);</span><br><span class="line">System.out.println(optional2.isPresent() == <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ifPresent-Consumer-consumer"><a href="#ifPresent-Consumer-consumer" class="headerlink" title="ifPresent(Consumer consumer)"></a>ifPresent(Consumer consumer)</h2><p>如果option对象保存的值不是null，则调用consumer对象，否则不调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是null,调用Consumer</span></span><br><span class="line">optional1.ifPresent(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"value is "</span> + t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// null,不调用Consumer</span></span><br><span class="line">optional2.ifPresent(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"value is "</span> + t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="orElse-value"><a href="#orElse-value" class="headerlink" title="orElse(value)"></a>orElse(value)</h2><p>如果optional对象保存的值不是null，则返回原来的值，否则返回value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// orElse</span></span><br><span class="line">System.out.println(optional1.orElse(<span class="number">1000</span>) == <span class="number">1</span>);<span class="comment">// true</span></span><br><span class="line">System.out.println(optional2.orElse(<span class="number">1000</span>) == <span class="number">1000</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="orElseGet-Supplier-supplier"><a href="#orElseGet-Supplier-supplier" class="headerlink" title="orElseGet(Supplier supplier)"></a>orElseGet(Supplier supplier)</h2><p>功能与orElse一样，只不过orElseGet参数是一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(optional1.orElseGet(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;) == <span class="number">1</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(optional2.orElseGet(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;) == <span class="number">1000</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow()"></a>orElseThrow()</h2><p>值不存在则抛出异常，存在则什么不做，有点类似Guava的Precoditions</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">optional1.orElseThrow(()-&gt;&#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 抛出异常</span></span><br><span class="line">	optional2.orElseThrow(()-&gt;&#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IllegalStateException e )</span><br><span class="line">&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="filter-Predicate"><a href="#filter-Predicate" class="headerlink" title="filter(Predicate)"></a>filter(Predicate)</h2><p>判断Optional对象中保存的值是否满足Predicate，并返回新的Optional。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; filter1 = optional1.filter((a) -&gt; a == <span class="keyword">null</span>);</span><br><span class="line">Optional&lt;Integer&gt; filter2 = optional1.filter((a) -&gt; a == <span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; filter3 = optional2.filter((a) -&gt; a == <span class="keyword">null</span>);</span><br><span class="line">System.out.println(filter1.isPresent());<span class="comment">// false</span></span><br><span class="line">System.out.println(filter2.isPresent());<span class="comment">// true</span></span><br><span class="line">System.out.println(filter2.get().intValue() == <span class="number">1</span>);<span class="comment">// true</span></span><br><span class="line">System.out.println(filter3.isPresent());<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="map-Function"><a href="#map-Function" class="headerlink" title="map(Function)"></a>map(Function)</h2><p>对Optional中保存的值进行函数运算，并返回新的Optional(可以是任何类型)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; str1Optional = optional1.map((a) -&gt; <span class="string">"key"</span> + a);</span><br><span class="line">Optional&lt;String&gt; str2Optional = optional2.map((a) -&gt; <span class="string">"key"</span> + a);</span><br><span class="line"></span><br><span class="line">System.out.println(str1Optional.get());<span class="comment">// key1</span></span><br><span class="line">System.out.println(str2Optional.isPresent());<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h2><p>功能与map()相似，差别请看如下代码。flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;Optional&lt;String&gt;&gt; str1Optional = optional1.map((a) -&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.&lt;String&gt;of(<span class="string">"key"</span> + a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; str2Optional = optional1.flatMap((a) -&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.&lt;String&gt;of(<span class="string">"key"</span> + a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(str1Optional.get().get());<span class="comment">// key1</span></span><br><span class="line">System.out.println(str2Optional.get());<span class="comment">// key1</span></span><br></pre></td></tr></table></figure>

<h1 id="Date-time-API的改进"><a href="#Date-time-API的改进" class="headerlink" title="Date/time API的改进"></a>Date/time API的改进</h1><p>在Java8之前的版本中，日期时间API存在很多的问题，比如：</p>
<ul>
<li>线程安全问题：java.util.Date是非线程安全的，所有的日期类都是可变的；</li>
<li>设计很差：在java.util和java.sql的包中都有日期类，此外，用于格式化和解析的类在java.text包中也有定义。而每个包将其合并在一起，也是不合理的；</li>
<li>时区处理麻烦：日期类不提供国际化，没有时区支持，因此Java中引入了java.util.Calendar和Java.util.TimeZone类；</li>
</ul>
<p>针对这些问题，Java8重新设计了日期时间相关的API，Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。在java.util.time包中常用的几个类有：</p>
<ul>
<li>它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()</li>
<li>Instant:一个instant对象表示时间轴上的一个时间点，Instant.now()方法会返回当前的瞬时点（格林威治时间）；</li>
<li>Duration:用于表示两个瞬时点相差的时间量；</li>
<li>LocalDate:一个带有年份，月份和天数的日期，可以使用静态方法now或者of方法进行创建；</li>
<li>LocalTime:表示一天中的某个时间，同样可以使用now和of进行创建；</li>
<li>LocalDateTime：兼有日期和时间；</li>
<li>ZonedDateTime：通过设置时间的id来创建一个带时区的时间；</li>
<li>DateTimeFormatter：日期格式化类，提供了多种预定义的标准格式；</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clock clock = Clock.systemUTC();</span><br><span class="line">        Instant instant = clock.instant();</span><br><span class="line">        System.out.println(instant.toString());</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        System.out.println(localDate.toString());</span><br><span class="line"></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        System.out.println(localTime.toString());</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(localDateTime.toString());</span><br><span class="line"></span><br><span class="line">        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        System.out.println(zonedDateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">14</span>T12:<span class="number">50</span>:<span class="number">27.437</span>Z</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">14</span></span><br><span class="line"><span class="number">20</span>:<span class="number">50</span>:<span class="number">27.646</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">14</span>T20:<span class="number">50</span>:<span class="number">27.646</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">14</span>T20:<span class="number">50</span>:<span class="number">27.647</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<h1 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h1><p>Java8还在其他细节上也做出了改变，归纳如下：</p>
<ol>
<li>之前的版本，注解在同一个位置只能声明一次，而Java8版本中提供@Repeatable注解，来实现可重复注解；</li>
<li>String类中提供了join方法来完成字符串的拼接；</li>
<li>在Arrays上提供了并行化处理数组的方式，比如利用Arrays类中的parallelSort可完成并行排序；</li>
<li>在Java8中在并发应用层面上也是下足了功夫：（1）提供功能更强大的Future：CompletableFuture；（2）StampedLock可用来替代ReadWriteLock；（3）性能更优的原子类：：LongAdder,LongAccumulator以及DoubleAdder和DoubleAccumulator；</li>
<li>编译器新增一些特性以及提供一些新的Java工具</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Stream的参考资料：</p>
<p><a href="https://www.jianshu.com/p/c0d5c3094324" target="_blank" rel="noopener">【译】java8之collector</a></p>
<p>Optional的参考资料：</p>
<p><a href="https://blog.csdn.net/aitangyong/article/details/54564100" target="_blank" rel="noopener">JDK8新特性：使用Optional避免null导致的NullPointerException</a></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/09/03/java8-lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/03/java8-lambda/" class="post-title-link" itemprop="url">深入浅出 Java 8 Lambda 表达式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-03 21:10:40" itemprop="dateCreated datePublished" datetime="2019-09-03T21:10:40+08:00">2019-09-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-05 15:13:46" itemprop="dateModified" datetime="2019-09-05T15:13:46+08:00">2019-09-05</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/lambda表达式/" itemprop="url" rel="index"><span itemprop="name">lambda表达式</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">11k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">10 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>Java 是一流的面向对象语言，除了部分简单数据类型，Java 中的一切都是对象，即使数组也是一种对象，每个类创建的实例也是对象。在 Java 中定义的函数或方法不可能完全独立，也不能将方法作为参数或返回一个方法给实例。</p>
<p>从 Swing 开始，我们总是通过匿名类给方法传递函数功能，以下是旧版的事件监听代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">someObject.addMouseListener(<span class="keyword">new</span> MouseAdapter() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Event listener implementation goes here...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子里，为了给 Mouse 监听器添加自定义代码，我们定义了一个匿名内部类 MouseAdapter 并创建了它的对象，通过这种方式，我们将一些函数功能传给 addMouseListener 方法。</p>
<p>简而言之，在 Java 里将普通的方法或函数像参数一样传值并不简单，为此，Java 8 增加了一个语言级的新特性，名为 <strong>Lambda 表达式</strong>。</p>
<h2 id="为什么-Java-需要-Lambda-表达式？"><a href="#为什么-Java-需要-Lambda-表达式？" class="headerlink" title="为什么 Java 需要 Lambda 表达式？"></a>为什么 Java 需要 Lambda 表达式？</h2><p>如果忽视注解(Annotations)、泛型(Generics)等特性，自 Java 语言诞生时起，它的变化并不大。Java 一直都致力维护其对象至上的特征，在使用过 JavaScript 之类的函数式语言之后，Java 如何强调其面向对象的本质，以及源码层的数据类型如何严格变得更加清晰可感。其实，函数对 Java 而言并不重要，在 Java 的世界里，函数无法独立存在。</p>
<p><img src="/2019/09/03/java8-lambda/xkcd-functional-1.png" alt="深入浅出 Java 8 Lambda 表达式 技术分享"></p>
<p>在函数式编程语言中，函数是一等公民，它们可以独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。JavaScript 是最典型的函数式编程语言。点击<a href="http://eloquentjavascript.net/chapter6.html" target="_blank" rel="noopener">此处</a>以及<a href="http://www.ibm.com/developerworks/library/wa-javascript/index.html" target="_blank" rel="noopener">此处</a>可以清楚了解 JavaScript 这种函数式语言的好处。函数式语言提供了一种强大的功能——闭包，相比于传统的编程方法有很多优势，闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。Java 现在提供的最接近闭包的概念便是 Lambda 表达式，虽然闭包与 Lambda 表达式之间存在显著差别，但至少 Lambda 表达式是闭包很好的替代者。</p>
<p>在 Steve Yegge 辛辣又幽默的<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="noopener">博客文章</a>里，描绘了 Java 世界是如何严格地以名词为中心的，如果你还没看过，赶紧去读吧，写得非常风趣幽默，而且恰如其分地解释了为什么 Java 要引进 Lambda 表达式。</p>
<p>Lambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。尽管不完全正确，我们很快就会见识到 Lambda 与闭包的不同之处，但是又无限地接近闭包。在支持一类函数的语言中，Lambda 表达式的类型将是函数。但是，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。我们会在后文详细介绍函数式接口。</p>
<p>Mario Fusco 的这篇思路清晰的<a href="http://java.dzone.com/articles/why-we-need-Lambda-expressions" target="_blank" rel="noopener">文章</a>介绍了为什么 Java 需要 Lambda 表达式。他解释了为什么现代编程语言必须包含闭包这类特性。</p>
<h2 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h2><p>Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p>
<p>你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</p>
<p>Java 中的 Lambda 表达式通常使用 <code>(argument) -&gt; (body)</code> 语法书写，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class="line"></span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>以下是一些 Lambda 表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h2><p>让我们了解一下 Lambda 表达式的结构。</p>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="从-Lambda-表达式到双冒号操作符"><a href="#从-Lambda-表达式到双冒号操作符" class="headerlink" title="从 Lambda 表达式到双冒号操作符"></a>从 Lambda 表达式到双冒号操作符</h3><p>使用 Lambda 表达式，我们已经看到代码可以变得非常简洁。</p>
<p>例如，要创建一个比较器，以下语法就足够了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator c = (Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge());</span><br></pre></td></tr></table></figure>

<p>然后，使用类型推断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator c = (p1, p2) -&gt; p1.getAge().compareTo(p2.getAge());</span><br></pre></td></tr></table></figure>

<p>但是，我们可以使上面的代码更具表现力和可读性吗？我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator c = Comparator.comparing(Person::getAge);</span><br></pre></td></tr></table></figure>

<p>使用 <code>::</code> 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>双冒号（<code>::</code>）操作符是 Java 中的<strong>方法引用</strong>。 当们使用一个方法的引用时，目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用::方法</code>。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::getAge;</span><br></pre></td></tr></table></figure>

<p>在 <code>Person</code> 类中定义的方法 <code>getAge</code> 的方法引用。</p>
<p>然后我们可以使用 <code>Function</code> 对象进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 getAge 方法的 Function 对象</span></span><br><span class="line">Function&lt;Person, Integer&gt; getAge = Person::getAge;</span><br><span class="line"><span class="comment">// 传参数调用 getAge 方法</span></span><br><span class="line">Integer age = getAge.apply(p);</span><br></pre></td></tr></table></figure>

<p>我们引用 <code>getAge</code>，然后将其应用于正确的参数。</p>
<p>目标引用的参数类型是 <code>Function&lt;T,R&gt;</code>，<code>T</code> 表示传入类型，<code>R</code> 表示返回类型。比如，表达式 <code>person -&gt; person.getAge();</code>，传入参数是 <code>person</code>，返回值是 <code>person.getAge()</code>，那么方法引用 <code>Person::getAge</code> 就对应着 <code>Function&lt;Person,Integer&gt;</code> 类型。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，<strong>函数式接口是只包含一个抽象方法声明的接口</strong>。因此经常使用的Runnable，Callable接口就是典型的函数式接口。</p>
<p><code>java.lang.Runnable</code> 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 <code>void run()</code>，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p>
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<p>当不指明函数式接口时，编译器会自动解释这种转化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">   () -&gt; System.out.println(<span class="string">"hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给 Runnable 接口。</p>
<p>以下是一些 Lambda 表达式及其函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt;  c = (<span class="keyword">int</span> x) -&gt; &#123; System.out.println(x) &#125;;</span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + <span class="string">" : "</span> + y);</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == <span class="keyword">null</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><a href="http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="noopener">@FunctionalInterface</a> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<p>以下是一种自定义的函数式接口： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。但是，函数式接口要求只有一个抽象方法却可以拥有若干个默认方法的（实例方法），比如下例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.FunctionalInterface</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口中，除了有抽象方法handle外，还有默认方法（实例方法）run。</p>
<p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面的代码可以通过静态方法应用可以更加简洁:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="Built-in-Functional-Interfaces-内置函数"><a href="#Built-in-Functional-Interfaces-内置函数" class="headerlink" title="Built-in Functional Interfaces(内置函数)"></a>Built-in Functional Interfaces(内置函数)</h3><p>JDK 1.8 API包含了许多内置函数. 它们中很多在老版本中是大家很熟悉的,像 <code>Comparator</code> 和<code>Runnable</code>. 这些接口通过 添加<code>@FunctionalInterface注解来支持</code>Lambda表达式.</p>
<p>但是Java 8 API 也添加了很多新接口使编程变的更加容易 . 这些新的函数很多是借鉴被大家所熟知的 <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">Google Guava</a> 函数库.即使你很熟悉这些函数库,你也需要关注这些方法是怎么在接口中扩展的以及它们怎么使用.</p>
<h4 id="Predicates-判断"><a href="#Predicates-判断" class="headerlink" title="Predicates( 判断)"></a>Predicates( 判断)</h4><p>判断是传递一个参数返回一个布尔值. 这个接口包含各种默认的方法组成复杂的逻辑判断单元 (and, or, negate)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>

<h4 id="Functions-函数"><a href="#Functions-函数" class="headerlink" title="Functions(函数)"></a>Functions(函数)</h4><p>函数接收一个参数返回一个结果. 默认方法能够链式调用 (compose, andThen).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure>

<h4 id="Suppliers-生产者"><a href="#Suppliers-生产者" class="headerlink" title="Suppliers(生产者)"></a>Suppliers(生产者)</h4><p>Suppliers返回一个给定的泛型类型的结果. 不像函数, Suppliers不需要传递参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<h4 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h4><p>Consumers代表在一个输入参数上执行一项操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Comparators-比较"><a href="#Comparators-比较" class="headerlink" title="Comparators(比较)"></a>Comparators(比较)</h4><p>Comparators在老版本中大家都比较熟悉. Java 8 为这个接口增加了几种默认的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>

<h4 id="Optionals-选项"><a href="#Optionals-选项" class="headerlink" title="Optionals(选项)"></a>Optionals(选项)</h4><p>Optionals 并不是一个函数接口, 相反的它的作用就是避免出现空指针异常.它是一个很重要的概念对以一部分,然我们来快速了解它.</p>
<p>Optional是一个简单的容器里面包含有空或者非空的值.想象一下如果有一个方法能够返回一个空或者一个非空的值 . 在Java8中你可以通过返回一个<code>Optional来替代空</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// "bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式举例"><a href="#Lambda-表达式举例" class="headerlink" title="Lambda 表达式举例"></a>Lambda 表达式举例</h2><h3 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h3><p>线程可以通过以下方法初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old way</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// New way</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>事件处理可以使用 Java 8 的 Lambda 表达式解决。下面的代码中，我们将使用新旧两种方式向一个 UI 组件添加 ActionListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//Old way:</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"The button was clicked using old fashion code!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">button.addActionListener( (e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"The button was clicked. From Lambda expressions !"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="遍例输出（方法引用）"><a href="#遍例输出（方法引用）" class="headerlink" title="遍例输出（方法引用）"></a>遍例输出（方法引用）</h3><p>以下代码的作用是打印出给定数组中的所有元素。注意，使用 Lambda 表达式的方法不止一种。在下面的例子中，我们先是用常用的箭头语法创建 Lambda 表达式，之后，使用 Java 8 全新的双冒号(::)操作符将一个常规方法转化为 Lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer n: list) &#123;</span><br><span class="line">   System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8 非lambda</span></span><br><span class="line">integers.forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">    System.out.print(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将 Lambda 表达式赋值给函数接口的局部变量</span></span><br><span class="line">Consumer&lt;Integer&gt; consumer=x -&gt; System.out.println(x);</span><br><span class="line">integers.forEach(consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 -&gt; 的 Lambda 表达式</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">list.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 :: 的 Lambda 表达式</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h3><p>在下面的例子中，我们使用断言(Predicate)函数式接口创建一个测试，并打印所有通过测试的元素，这样，你就可以使用 Lambda 表达式规定一些逻辑，并以此为基础有所作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuxianjiezh.demo.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出所有数字："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"不输出："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出偶数："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出奇数："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出大于 5 的数字："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n &gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(n)) &#123;</span><br><span class="line">                System.out.print(n + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出所有数字：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </span><br><span class="line">不输出：</span><br><span class="line">输出偶数：<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line">输出奇数：<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> </span><br><span class="line">输出大于 <span class="number">5</span> 的数字：<span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="Stream-API-示例"><a href="#Stream-API-示例" class="headerlink" title="Stream API 示例"></a>Stream API 示例</h3><p>下面的例子使用 Lambda 表达式打印数值中每个元素的平方，注意我们使用了 .stream() 方法将常规数组转化为流。Java 8 增加了一些超棒的流 APIs。<a href="http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">java.util.stream.Stream</a> 接口包含许多有用的方法，能结合 Lambda 表达式产生神奇的效果。我们将 Lambda 表达式 <code>x -&gt; x*x</code> 传给 map() 方法，该方法会作用于流中的所有元素。之后，我们使用 forEach 方法打印数据中的所有元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().map((x) -&gt; x*x).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>下面的例子会计算给定数值中每个元素平方后的总和。请注意，Lambda 表达式只用一条语句就能达到此功能，这也是 MapReduce 的一个初级例子。我们使用 map() 给每个元素求平方，再使用 reduce() 将所有元素计入一个数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Old way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    sum = sum + x;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//New way:</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式与匿名类的区别"><a href="#Lambda-表达式与匿名类的区别" class="headerlink" title="Lambda 表达式与匿名类的区别"></a>Lambda 表达式与匿名类的区别</h2><ul>
<li><code>this</code> 关键字。对于匿名类 <code>this</code> 关键字解析为匿名类，而对于 Lambda 表达式，<code>this</code> 关键字解析为包含写入 Lambda 的类。</li>
<li>编译方式。Java 编译器编译 Lambda 表达式时，会将其转换为类的私有方法，再进行动态绑定。</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/28/distributed-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/28/distributed-transaction/" class="post-title-link" itemprop="url">分布式事务</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-28 18:52:59" itemprop="dateCreated datePublished" datetime="2019-08-28T18:52:59+08:00">2019-08-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-09 15:10:26" itemprop="dateModified" datetime="2019-09-09T15:10:26+08:00">2019-09-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/" itemprop="url" rel="index"><span itemprop="name">分布式一致性</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/分布式事务/" itemprop="url" rel="index"><span itemprop="name">分布式事务</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">13k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">12 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p>
<h2 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性 ACID"></a>事务的四大特性 ACID</h2><p>说到事务，就不得不提一下事务著名的四大特性。</p>
<ul>
<li>原子性   原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</li>
<li>一致性   一致性要求，事务在开始前和结束后，数据库的完整性约束没有被破坏。</li>
<li>隔离性   事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</li>
<li>持久性   持久性要求，一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。   注意：事务只能保证数据库的<strong>高可靠性</strong>，即数据库本身发生问题后，事务提交后的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『<strong>高可用性</strong>』的范畴。因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。  </li>
</ul>
<hr>
<h2 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h2><p>到此为止，所介绍的事务都是基于单数据库的本地事务，目前的数据库仅支持单库事务，并不支持跨库事务。而随着微服务架构的普及，一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成。在微服务系统中，这些业务场景是普遍存在的。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的“分布式事务”。</p>
<p>这里举一个分布式事务的典型例子——用户下单过程。   当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p>
<ol>
<li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li>
<li>此时订单系统会生成一条订单</li>
<li>订单创建成功后，支付系统提供支付功能</li>
<li>当支付完成后，由积分系统为该用户增加积分</li>
</ol>
<p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的@Transactional注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲<strong>强一致性</strong>换取<strong>弱一致性</strong>。下面来介绍下BASE理论。</p>
<ul>
<li>BA：Basic Available 基本可用   <ul>
<li>整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是：   <ul>
<li>“一定时间”可以适当延长   当举行大促时，响应时间可以适当延长</li>
<li>给部分用户返回一个降级页面   给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li>
</ul>
</li>
</ul>
</li>
<li>S：Soft State：柔性状态   同一数据的不同副本的状态，可以不需要实时一致。</li>
<li>E：Eventual Consisstency：最终一致性   同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</li>
</ul>
<h2 id="酸碱平衡"><a href="#酸碱平衡" class="headerlink" title="酸碱平衡"></a>酸碱平衡</h2><p>ACID能够保证事务的强一致性，即数据是实时一致的。这在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能，因此分布式系统中遵循BASE理论即可。但分布式系统的不同业务场景对一致性的要求也不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送<a href="https://cloud.tencent.com/product/sms?from=10680" target="_blank" rel="noopener">短信</a>验证码等场景下，并不需要实时一致，因此遵循BASE理论即可。因此要根据具体业务场景，在ACID和BASE之间寻求平衡。</p>
<h2 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h2><h3 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议 2PC"></a>两阶段提交协议 2PC</h3><p>说到2PC就不得不聊数据库分布式事务中的 XA Transactions。</p>
<p><img src="/2019/08/28/distributed-transaction/8aj4iyiwbu.jpeg" alt="img"></p>
<p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：</p>
<ul>
<li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。</li>
<li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<p><strong>1. 第一阶段（投票阶段）：</strong></p>
<ol>
<li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li>
<li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li>
<li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li>
</ol>
<p><strong>2. 第二阶段（提交执行阶段）：</strong></p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：</p>
<ol>
<li>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li>
<li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送”完成”消息。</li>
<li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li>
</ol>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<ol>
<li>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li>
<li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送”回滚完成”消息。</li>
<li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li>
</ol>
<p>不管最后结果如何，第二阶段都会结束当前事务。</p>
<p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</p>
<ol>
<li>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</li>
<li>协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）</li>
<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
</ol>
<p>为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。</p>
<h3 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h3><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<ul>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ul>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p>
<p><strong>1. CanCommit阶段</strong></p>
<p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<ol>
<li>事务询问   协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li>
<li>响应反馈   参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li>
</ol>
<p><strong>2. PreCommit阶段</strong></p>
<p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。   假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</p>
<ol>
<li>发送预提交请求   协调者向参与者发送PreCommit请求，并进入Prepared阶段。</li>
<li>事务预提交   参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</li>
<li>响应反馈   如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li>
</ol>
<p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p>
<ol>
<li>发送中断请求    协调者向所有参与者发送abort请求。</li>
<li>中断事务    参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
<p><strong>3. doCommit阶段</strong>   该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p><strong>3.1 执行提交</strong></p>
<ol>
<li>发送提交请求   协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</li>
<li>事务提交    参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li>
<li>响应反馈    事务提交完之后，向协调者发送Ack响应。</li>
<li>完成事务    协调者接收到所有参与者的ack响应之后，完成事务。</li>
</ol>
<p><strong>3.2 中断事务</strong>   协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<ol>
<li>发送中断请求    协调者向所有参与者发送abort请求</li>
<li>事务回滚    参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li>
<li>反馈结果    参与者完成事务回滚之后，向协调者发送ACK消息</li>
<li>中断事务    协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li>
</ol>
<h2 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h2><p>分布式事务的解决方案有如下几种：</p>
<ul>
<li>全局消息</li>
<li>基于可靠消息服务的分布式事务</li>
<li>TCC</li>
<li>最大努力通知</li>
</ul>
<h3 id="方案1：全局事务（DTP模型）"><a href="#方案1：全局事务（DTP模型）" class="headerlink" title="方案1：全局事务（DTP模型）"></a>方案1：全局事务（DTP模型）</h3><p>全局事务基于DTP模型实现。DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。它规定了要实现分布式事务，需要三种角色： </p>
<ul>
<li>AP：Application 应用系统   它就是我们开发的业务系统，在我们开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。</li>
<li>TM：Transaction Manager 事务管理器  <ul>
<li>分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供我们的业务系统调用。这些接口称为TX接口。</li>
<li>事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来同一调度这些资源管理器，以实现分布式事务。</li>
<li>DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。</li>
</ul>
</li>
<li>RM：Resource Manager 资源管理器  <ul>
<li>能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。</li>
<li>资源管理器能够提供单数据库的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。</li>
<li>XA是DTP模型定义的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。</li>
<li>DTP只是一套实现分布式事务的规范，RM具体的实现是由数据库厂商来完成的。</li>
</ul>
</li>
</ul>
<blockquote>
</blockquote>
<ol>
<li>有没有基于DTP模型的分布式事务中间件？</li>
<li>DTP模型有啥优缺点？</li>
</ol>
<h3 id="方案2：本地消息表"><a href="#方案2：本地消息表" class="headerlink" title="方案2：本地消息表"></a>方案2：本地消息表</h3><p>本地消息表这个方案最初是ebay提出的 ebay的完整方案<a href="https://queue.acm.org/detail.cfm?id=1394128。" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128。</a></p>
<p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或<a href="https://cloud.tencent.com/product/cmq?from=10680" target="_blank" rel="noopener">消息队列</a>，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 </p>
<p><img src="/2019/08/28/distributed-transaction/1628.png" alt="img"></p>
<p>对于本地消息队列来说核心是把大事务转变为小事务。举个简单的例子如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。</p>
<p>1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性)。</p>
<p>2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。</p>
<p>3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。</p>
<p>4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。</p>
<p>本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。</p>
<h3 id="方案3：基于可靠消息服务的分布式事务"><a href="#方案3：基于可靠消息服务的分布式事务" class="headerlink" title="方案3：基于可靠消息服务的分布式事务"></a>方案3：基于可靠消息服务的分布式事务</h3><p>这种实现分布式事务的方式需要通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。下面来介绍基于消息中间件来实现这种分布式事务。</p>
<p>在RocketMQ中实现了分布式事务，实际上其实是对<strong>本地消息表</strong>的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务。</p>
<p><img src="/2019/08/28/distributed-transaction/1620.png" alt="img"></p>
<ul>
<li>在系统A处理任务A前，首先向消息中间件发送一条消息</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li>
<li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li>
<li>系统A收到确认应答后，则可以开始处理任务A；</li>
<li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。   但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li>
<li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li>
<li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li>
</ul>
<blockquote>
<p> 上述过程可以得出如下几个结论：     1. 消息中间件扮演者分布式事务协调者的角色。     2. 系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论。  </p>
</blockquote>
<p>上述过程中，如果任务A处理失败，那么需要进入回滚流程，如下图所示：   </p>
<p><img src="/2019/08/28/distributed-transaction/1621.png" alt="img"></p>
<ul>
<li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li>
<li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li>
</ul>
<blockquote>
<p> 此时系统又处于一致性状态，因为任务A和任务B都没有执行。  </p>
</blockquote>
<p>上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p>
<p><img src="/2019/08/28/distributed-transaction/1622.png" alt="img"></p>
<p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的Commit或Rollback指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p>
<ul>
<li>提交   若获得的状态是“提交”，则将该消息投递给系统B。</li>
<li>回滚   若获得的状态是“回滚”，则直接将条消息丢弃。</li>
<li>处理中   若获得的状态是“处理中”，则继续等待。</li>
</ul>
<blockquote>
<p> 消息中间件的超时询问机制能够防止上游系统因在传输过程中丢失Commit/Rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间，上游系统只要发出Commit/Rollback指令后便可以处理其他任务，无需等待确认应答。而Commit/Rollback指令丢失的情况通过超时询问机制来弥补，这样大大降低上游系统的阻塞时间，提升系统的并发度。  </p>
</blockquote>
<p>下面来说一说消息投递过程的可靠性保证。   当上游系统执行完任务并向消息中间件提交了Commit指令后，便可以处理其他任务了，此时它可以认为事务已经完成，接下来消息中间件<strong>一定会保证消息被下游系统成功消费掉！</strong>那么这是怎么做到的呢？这由消息中间件的投递流程来保证。</p>
<p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p>
<p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。   </p>
<p><img src="/2019/08/28/distributed-transaction/1623.png" alt="img"></p>
<p><img src="/2019/08/28/distributed-transaction/1624.png" alt="img"></p>
<blockquote>
<p> 有的同学可能要问：消息投递失败后为什么不回滚消息，而是不断尝试重新投递？  </p>
</blockquote>
<p>这就涉及到整套分布式事务系统的实现成本问题。   我们知道，当系统A将向消息中间件发送Commit指令后，它便去做别的事情了。如果此时消息投递失败，需要回滚的话，就需要让系统A事先提供回滚接口，这无疑增加了额外的开发成本，业务系统的复杂度也将提高。对于一个业务系统的设计目标是，在保证性能的前提下，最大限度地降低系统复杂度，从而能够降低系统的运维成本。</p>
<blockquote>
<p> 不知大家是否发现，上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，也就是当上游系统提交完消息后便可以去做别的事情，接下来提交、回滚就完全交给消息中间件来完成，并且完全信任消息中间件，认为它一定能正确地完成事务的提交或回滚。然而，消息中间件向下游系统投递消息的过程是同步的。也就是消息中间件将消息投递给下游系统后，它会阻塞等待，等下游系统成功处理完任务返回确认应答后才取消阻塞等待。为什么这两者在设计上是不一致的呢？  </p>
</blockquote>
<p>首先，上游系统和消息中间件之间采用异步通信是为了提高系统并发度。业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</p>
<p>那么，消息中间件和下游系统之间为什么要采用同步通信呢？</p>
<p>异步能提升系统性能，但随之会增加系统复杂度；而同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。   我们知道，消息中间件是一个独立于业务系统的第三方中间件，它不和任何业务系统产生直接的耦合，它也不和用户产生直接的关联，它一般部署在独立的服务器集群上，具有良好的可扩展性，所以不必太过于担心它的性能，如果处理速度无法满足我们的要求，可以增加机器来解决。而且，即使消息中间件处理速度有一定的延迟那也是可以接受的，因为前面所介绍的BASE理论就告诉我们了，我们追求的是最终一致性，而非实时一致性，因此消息中间件产生的时延导致事务短暂的不一致是可以接受的。</p>
<h3 id="方案4：最大努力通知（定期校对）"><a href="#方案4：最大努力通知（定期校对）" class="headerlink" title="方案4：最大努力通知（定期校对）"></a>方案4：最大努力通知（定期校对）</h3><p>最大努力通知也被称为定期校对，其实在方案二中已经包含，这里再单独介绍，主要是为了知识体系的完整性。这种方案也需要消息中间件的参与，其过程如下：</p>
<p><img src="/2019/08/28/distributed-transaction/1625.png" alt="img"></p>
<ul>
<li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li>
<li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li>
<li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li>
</ul>
<p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p>
<ol>
<li>消息中间件向下游系统投递消息失败</li>
<li>上游系统向消息中间件发送消息失败</li>
</ol>
<p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”。</p>
<p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p>
<p>对于第二种情况，需要在上游系统中建立消息重发机制。可以在上游系统建立一张本地消息表，并将 <strong>任务处理过程</strong> 和 <strong>向本地消息表中插入消息</strong> 这两个步骤放在一个本地事务中完成。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。如果这量步都执行成功，那么该本地事务就完成了。接下来会有一个专门的消息发送者不断地发送本地消息表中的消息，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p>
<p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过<strong>重试机制</strong>+<strong>定期校对</strong>实现分布式事务，但相比于第二种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p>
<p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。</p>
<h3 id="方案5：TCC（两阶段型、补偿型）"><a href="#方案5：TCC（两阶段型、补偿型）" class="headerlink" title="方案5：TCC（两阶段型、补偿型）"></a>方案5：TCC（两阶段型、补偿型）</h3><p>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。在实际生产应用中，</p>
<ul>
<li>网易严选自研的分布式事务中间件 DTS就是一种典型的 TCC类型事务(<a href="https://mp.weixin.qq.com/s/syM4ReAWpZ5d4KI87ogpiQ" target="_blank" rel="noopener">从单一架构到分布式交易架构，网易严选的成功实践</a>)。</li>
<li>蚂蚁金服自研的SOFA DTX分布式事务分别基于两种理论实现了两种模式：<strong>基于BASE理论的TCC模式和基于ACID理论的FMT模式</strong>(<a href="https://zhuanlan.zhihu.com/p/37199427" target="_blank" rel="noopener">蚂蚁金服黑科技：SOFA DTX分布式事务，保障亿级资金操作一致性</a>)。</li>
</ul>
<p><img src="/2019/08/28/distributed-transaction/1627.png" alt="img"></p>
<p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p>
<ul>
<li>Try：尝试待执行的业务   <ul>
<li>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源</li>
</ul>
</li>
<li>Confirm：执行业务   <ul>
<li>这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li>
</ul>
</li>
<li>Cancel：取消执行的业务   <ul>
<li>若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</li>
</ul>
</li>
</ul>
<p>下面以一个转账的例子来解释下TCC实现分布式事务的过程。</p>
<blockquote>
<p> 假设用户A用他的账户余额给用户B发一个100元的红包，并且余额系统和红包系统是两个独立的系统。  </p>
</blockquote>
<ul>
<li>Try  <ul>
<li>创建一条转账流水，并将流水的状态设为<strong>交易中</strong></li>
<li>将用户A的账户中扣除100元（预留业务资源）</li>
<li>Try成功之后，便进入Confirm阶段</li>
<li>Try过程发生任何异常，均进入Cancel阶段</li>
</ul>
</li>
<li>Confirm  <ul>
<li>向B用户的红包账户中增加100元</li>
<li>将流水的状态设为<strong>交易已完成</strong></li>
<li>Confirm过程发生任何异常，均进入Cancel阶段</li>
<li>Confirm过程执行成功，则该事务结束</li>
</ul>
</li>
<li>Cancel  <ul>
<li>将用户A的账户增加100元</li>
<li>将流水的状态设为<strong>交易失败</strong></li>
</ul>
</li>
</ul>
<p>在传统事务机制中，业务逻辑的执行和事务的处理，是在不同的阶段由不同的部件来完成的：业务逻辑部分访问资源实现数据存储，其处理是由业务系统负责；事务处理部分通过协调资源管理器以实现事务管理，其处理由事务管理器来负责。二者没有太多交互的地方，所以，传统事务管理器的事务处理逻辑，仅需要着眼于事务完成（commit/rollback）阶段，而不必关注业务执行阶段。</p>
<p>等一等，你有没有想到一个问题？如果有一些意外的情况发生了，比如说订单服务突然挂了，然后再次重启，TCC 分布式事务框架是如何保证之前没执行完的分布式事务继续执行的呢？</p>
<p>所以，TCC 事务框架都是要记录一些分布式事务的活动日志的，可以在磁盘上的日志文件里记录，也可以在数据库里记录。保存下来分布式事务运行的各个阶段和状态。</p>
<p>问题还没完，万一某个服务的 Cancel 或者 Confirm 逻辑执行一直失败怎么办呢？</p>
<p>那也很简单，TCC 事务框架会通过活动日志记录各个服务的状态。举个例子，比如发现某个服务的 Cancel 或者 Confirm 一直没成功，会不停的重试调用它的 Cancel 或者 Confirm 逻辑，务必要它成功！</p>
<h4 id="TCC全局事务必须基于RM本地事务来实现全局事务"><a href="#TCC全局事务必须基于RM本地事务来实现全局事务" class="headerlink" title="TCC全局事务必须基于RM本地事务来实现全局事务"></a>TCC全局事务必须基于RM本地事务来实现全局事务</h4><p>TCC服务是由Try/Confirm/Cancel业务构成的，   其Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。</p>
<p>这一点不难理解，考虑一下如下场景：</p>
<p><img src="/2019/08/28/distributed-transaction/1626.png" alt="img"></p>
<p>假设图中的服务B没有基于RM本地事务（以RDBS为例，可通过设置auto-commit为true来模拟），那么一旦[B:Try]操作中途执行失败，TCC事务框架后续决定回滚全局事务时，该[B:Cancel]则需要判断[B:Try]中哪些操作已经写到DB、哪些操作还没有写到DB：假设[B:Try]业务有5个写库操作，[B:Cancel]业务则需要逐个判断这5个操作是否生效，并将生效的操作执行反向操作。</p>
<p>不幸的是，由于[B:Cancel]业务也有n（0&lt;=n&lt;=5）个反向的写库操作，此时一旦[B:Cancel]也中途出错，则后续的[B:Cancel]执行任务更加繁重。因为，相比第一次[B:Cancel]操作，后续的[B:Cancel]操作还需要判断先前的[B:Cancel]操作的n（0&lt;=n&lt;=5）个写库中哪几个已经执行、哪几个还没有执行，这就涉及到了幂等性问题。而对幂等性的保障，又很可能还需要涉及额外的写库操作，该写库操作又会因为没有RM本地事务的支持而存在类似问题。。。可想而知，如果不基于RM本地事务，TCC事务框架是无法有效的管理TCC全局事务的。</p>
<p>反之，基于RM本地事务的TCC事务，这种情况则会很容易处理：[B:Try]操作中途执行失败，TCC事务框架将其参与RM本地事务直接rollback即可。后续TCC事务框架决定回滚全局事务时，在知道“[B:Try]操作涉及的RM本地事务已经rollback”的情况下，根本无需执行[B:Cancel]操作。</p>
<p>换句话说，基于RM本地事务实现TCC事务框架时，一个TCC型服务的cancel业务要么执行，要么不执行，不需要考虑部分执行的情况。</p>
<h4 id="TCC事务框架应该提供Confirm-Cancel服务的幂等性保障"><a href="#TCC事务框架应该提供Confirm-Cancel服务的幂等性保障" class="headerlink" title="TCC事务框架应该提供Confirm/Cancel服务的幂等性保障"></a>TCC事务框架应该提供Confirm/Cancel服务的幂等性保障</h4><p>一般认为，服务的幂等性，是指针对同一个服务的多次(n&gt;1)请求和对它的单次(n=1)请求，二者具有相同的副作用。</p>
<p>在TCC事务模型中，Confirm/Cancel业务可能会被重复调用，其原因很多。比如，全局事务在提交/回滚时会调用各TCC服务的Confirm/Cancel业务逻辑。执行这些Confirm/Cancel业务时，可能会出现如网络中断的故障而使得全局事务不能完成。因此，故障恢复机制后续仍然会重新提交/回滚这些未完成的全局事务，这样就会再次调用参与该全局事务的各TCC服务的Confirm/Cancel业务逻辑。</p>
<p>既然Confirm/Cancel业务可能会被多次调用，就需要保障其幂等性。   那么，应该由TCC事务框架来提供幂等性保障？还是应该由业务系统自行来保障幂等性呢？   个人认为，应该是由TCC事务框架来提供幂等性保障。如果仅仅只是极个别服务存在这个问题的话，那么由业务系统来负责也是可以的；然而，这是一类公共问题，毫无疑问，所有TCC服务的Confirm/Cancel业务存在幂等性问题。TCC服务的公共问题应该由TCC事务框架来解决；而且，考虑一下由业务系统来负责幂等性需要考虑的问题，就会发现，这无疑增大了业务系统的复杂度。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://cs.brown.edu/courses/cs227/archives/2012/papers/weaker/cidr07p15.pdf" target="_blank" rel="noopener">Life beyond Distributed Transactions: an Apostate’s Opinion</a></li>
<li><a href="http://www.bytesoft.org/tcc-intro/" target="_blank" rel="noopener">关于如何实现一个TCC分布式事务框架的一点思考</a></li>
<li><a href="http://www.enterpriseintegrationpatterns.com/patterns/conversation/TryConfirmCancel.html" target="_blank" rel="noopener">How can a requestor ensure a consistent outcome across multiple, independent providers</a></li>
<li><a href="http://www.hollischuang.com/archives/681#rd?sukey=3997c0719f1515205acb269da14295ad50b0186483fbd0a402a566f45b33525978b375ccc44dba3e85c4d645a320ba47" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a></li>
<li><a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol_ei.cs.vt.edu/~cs5204/fall99/distributedDBMS/sreenu/3pc.html" target="_blank" rel="noopener">Three-phase commit protocol</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37199427" target="_blank" rel="noopener">蚂蚁金服黑科技：SOFA DTX分布式事务，保障亿级资金操作一致性</a></li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/28/distributed-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/28/distributed-lock/" class="post-title-link" itemprop="url">分布式锁</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-28 17:05:17" itemprop="dateCreated datePublished" datetime="2019-08-28T17:05:17+08:00">2019-08-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-12 12:23:47" itemprop="dateModified" datetime="2019-09-12T12:23:47+08:00">2019-09-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发控制/" itemprop="url" rel="index"><span itemprop="name">并发控制</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发控制/分布式锁/" itemprop="url" rel="index"><span itemprop="name">分布式锁</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">13k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">11 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>对于锁大家肯定不会陌生，在Java中synchronized关键字和ReentrantLock可重入锁在我们的代码中是经常见的，一般我们用其在多线程环境中控制对资源的并发访问，但是随着分布式的快速发展，本地的加锁往往不能满足我们的需要，在我们的分布式环境中上面加锁的方法就会失去作用。于是人们为了在分布式环境中也能实现本地锁的效果，也是纷纷各出其招，今天让我们来聊一聊一般分布式锁实现的套路。</p>
<h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2.分布式锁"></a>2.分布式锁</h1><h2 id="2-1为何需要分布式锁"><a href="#2-1为何需要分布式锁" class="headerlink" title="2.1为何需要分布式锁"></a>2.1为何需要分布式锁</h2><p>Martin Kleppmann是英国剑桥大学的分布式系统的研究员，之前和Redis之父Antirez进行过关于RedLock(红锁，后续有讲到)是否安全的激烈讨论。Martin认为一般我们使用分布式锁有两个场景:</p>
<ul>
<li>效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。</li>
<li>正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</li>
</ul>
<h2 id="2-2分布式锁的一些特点"><a href="#2-2分布式锁的一些特点" class="headerlink" title="2.2分布式锁的一些特点"></a>2.2分布式锁的一些特点</h2><p>当我们确定了在不同节点上需要分布式锁，那么我们需要了解分布式锁到底应该有哪些特点:</p>
<ul>
<li>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</li>
<li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li>
<li>锁超时:和本地锁一样支持锁超时，防止死锁。</li>
<li>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li>
<li>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</li>
<li>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li>
</ul>
<h2 id="2-3常见的分布式锁"><a href="#2-3常见的分布式锁" class="headerlink" title="2.3常见的分布式锁"></a>2.3常见的分布式锁</h2><p>我们了解了一些特点之后，我们一般实现分布式锁有以下几个方式:</p>
<ul>
<li>MySql</li>
<li>Zk</li>
<li>Redis</li>
<li>自研分布式锁:如谷歌的Chubby。</li>
</ul>
<p>下面分开介绍一下这些分布式锁的实现原理。</p>
<h1 id="3-Mysql分布式锁"><a href="#3-Mysql分布式锁" class="headerlink" title="3.Mysql分布式锁"></a>3.Mysql分布式锁</h1><p>首先来说一下Mysql分布式锁的实现原理，相对来说这个比较容易理解，毕竟数据库和我们开发人员在平时的开发中息息相关。对于分布式锁我们可以创建一个锁表:</p>
<p><img src="/2019/08/28/distributed-lock/E8469D6D-26BE-4543-A0F4-648FA184DAA4.jpg" alt="img"></p>
<p> 前面我们所说的lock(),trylock(long timeout)，trylock()这几个方法可以用下面的伪代码实现。</p>
<h2 id="3-1-lock"><a href="#3-1-lock" class="headerlink" title="3.1 lock()"></a>3.1 lock()</h2><p>lock一般是阻塞式的获取锁，意思就是不获取到锁誓不罢休，那么我们可以写一个死循环来执行其操作: </p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f372f313636346564316231326430303132663f773d35393426683d33333126663d706e6726733d3431333833.png" alt="img"></p>
<p>mysqlLock.lcok内部是一个sql,为了达到可重入锁的效果那么我们应该先进行查询，如果有值，那么需要比较node_info是否一致，这里的node_info可以用机器IP和线程名字来表示，如果一致那么就加可重入锁count的值，如果不一致那么就返回false。如果没有值那么直接插入一条数据。伪代码如下: </p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f372f313636346564386631366432323737623f773d3132303226683d35343126663d706e6726733d3934353534.png" alt="img"></p>
<p>需要注意的是这一段代码需要加事务，必须要保证这一系列操作的原子性。</p>
<h2 id="3-2-tryLock-和tryLock-long-timeout"><a href="#3-2-tryLock-和tryLock-long-timeout" class="headerlink" title="3.2 tryLock()和tryLock(long timeout)"></a>3.2 tryLock()和tryLock(long timeout)</h2><p>tryLock()是非阻塞获取锁，如果获取不到那么就会马上返回，代码可以如下: </p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f372f313636346564663061383338353962633f773d34343226683d31363826663d706e6726733d3136373934.png" alt="img"></p>
<p> tryLock(long timeout)实现如下: </p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f372f313636346565326630626630613761653f773d39343526683d34393726663d706e6726733d3734303136.png" alt="img"></p>
<p> mysqlLock.lock和上面一样，但是要注意的是select … for update这个是阻塞的获取行锁，如果同一个资源并发量较大还是有可能会退化成阻塞的获取锁。</p>
<h2 id="3-3-unlock"><a href="#3-3-unlock" class="headerlink" title="3.3 unlock()"></a>3.3 unlock()</h2><p>unlock的话如果这里的count为1那么可以删除，如果大于1那么需要减去1。</p>
<p><img src="/2019/08/28/distributed-lock/20190828172401.jpg" alt="img"></p>
<h2 id="3-4-锁超时"><a href="#3-4-锁超时" class="headerlink" title="3.4 锁超时"></a>3.4 锁超时</h2><p>我们有可能会遇到我们的机器节点挂了，那么这个锁就不会得到释放，我们可以启动一个定时任务，通过计算一般我们处理任务的一般的时间，比如是5ms，那么我们可以稍微扩大一点，当这个锁超过20ms没有被释放我们就可以认定是节点挂了然后将其直接释放。</p>
<h2 id="3-5-Mysql小结"><a href="#3-5-Mysql小结" class="headerlink" title="3.5 Mysql小结"></a>3.5 Mysql小结</h2><ul>
<li>适用场景: Mysql分布式锁一般适用于资源不存在数据库，如果数据库存在比如订单，那么可以直接对这条数据加行锁，不需要我们上面多的繁琐的步骤，比如一个订单，那么我们可以用select * from order_table where id = ‘xxx’ for update进行加行锁，那么其他的事务就不能对其进行修改。</li>
<li>优点:理解起来简单，不需要维护额外的第三方中间件(比如Redis,Zk)。</li>
<li>缺点:虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。</li>
</ul>
<h2 id="3-6-乐观锁"><a href="#3-6-乐观锁" class="headerlink" title="3.6 乐观锁"></a>3.6 乐观锁</h2><p>前面我们介绍的都是悲观锁，这里想额外提一下乐观锁，在我们实际项目中也是经常实现乐观锁，因为我们加行锁的性能消耗比较大，通常我们会对于一些竞争不是那么激烈，但是其又需要保证我们并发的顺序执行使用乐观锁进行处理，我们可以对我们的表加一个版本号字段，那么我们查询出来一个版本号之后，update或者delete的时候需要依赖我们查询出来的版本号，判断当前数据库和查询出来的版本号是否相等，如果相等那么就可以执行，如果不等那么就不能执行。这样的一个策略很像我们的CAS(Compare And Swap),比较并交换是一个原子操作。这样我们就能避免加select * for update行锁的开销。</p>
<h1 id="4-ZooKeeper"><a href="#4-ZooKeeper" class="headerlink" title="4. ZooKeeper"></a>4. ZooKeeper</h1><p>ZooKeeper也是我们常见的实现分布式锁方法，相比于数据库如果没了解过ZooKeeper可能上手比较难一些。ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。我们以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，未获取到锁的客户端注册需要注册Watcher到上一个客户端，可以用下图表示。</p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f382f313636353133646466396632626438373f773d3135373426683d37333126663d706e6726733d3733383137.png" alt="img"></p>
<p> /lock是我们用于加锁的目录,/resource_name是我们锁定的资源，其下面的节点按照我们加锁的顺序排列。</p>
<h2 id="4-1-Curator"><a href="#4-1-Curator" class="headerlink" title="4.1 Curator"></a>4.1 Curator</h2><p>Curator封装了Zookeeper底层的Api，使我们更加容易方便的对Zookeeper进行操作，并且它封装了分布式锁的功能，这样我们就不需要再自己实现了。</p>
<p>Curator实现了可重入锁(InterProcessMutex),也实现了不可重入锁(InterProcessSemaphoreMutex)。在可重入锁中还实现了读写锁。</p>
<h2 id="4-2-InterProcessMutex"><a href="#4-2-InterProcessMutex" class="headerlink" title="4.2 InterProcessMutex"></a>4.2 InterProcessMutex</h2><p>InterProcessMutex是Curator实现的可重入锁，我们可以通过下面的一段代码实现我们的可重入锁:</p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f382f313636353134613764623031636134613f773d3131303926683d33353326663d706e6726733d3537353833.png" alt="img"></p>
<p>我们利用acuire进行加锁，release进行解锁。</p>
<p>加锁的流程具体如下:</p>
<ol>
<li>首先进行可重入的判定:这里的可重入锁记录在ConcurrentMap&lt;Thread, LockData&gt; threadData这个Map里面，如果threadData.get(currentThread)是有值的那么就证明是可重入锁，然后记录就会加1。我们之前的Mysql其实也可以通过这种方法去优化，可以不需要count字段的值，将这个维护在本地可以提高性能。</li>
<li>然后在我们的资源目录下创建一个节点:比如这里创建一个/0000000002这个节点，这个节点需要设置为EPHEMERAL_SEQUENTIAL也就是临时节点并且有序。</li>
<li>获取当前目录下所有子节点，判断自己的节点是否位于子节点第一个。</li>
<li>如果是第一个，则获取到锁，那么可以返回。</li>
<li>如果不是第一个，则证明前面已经有人获取到锁了，那么需要获取自己节点的前一个节点。/0000000002的前一个节点是/0000000001，我们获取到这个节点之后，再上面注册Watcher(这里的watcher其实调用的是object.notifyAll(),用来解除阻塞)。</li>
<li>object.wait(timeout)或object.wait():进行阻塞等待这里和我们第5步的watcher相对应。</li>
</ol>
<p>解锁的具体流程:</p>
<ol>
<li>首先进行可重入锁的判定:如果有可重入锁只需要次数减1即可，减1之后加锁次数为0的话继续下面步骤，不为0直接返回。</li>
<li>删除当前节点。</li>
<li>删除threadDataMap里面的可重入锁的数据。</li>
</ol>
<h2 id="4-3-读写锁"><a href="#4-3-读写锁" class="headerlink" title="4.3 读写锁"></a>4.3 读写锁</h2><p>Curator提供了读写锁，其实现类是InterProcessReadWriteLock，这里的每个节点都会加上前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ_LOCK_NAME  = <span class="string">"__READ__"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_LOCK_NAME = <span class="string">"__WRIT__"</span>;</span><br></pre></td></tr></table></figure>

<p>根据不同的前缀区分是读锁还是写锁，对于读锁，如果发现前面有写锁，那么需要将watcher注册到和自己最近的写锁。写锁的逻辑和我们之前4.2分析的依然保持不变。</p>
<h2 id="4-4-锁超时"><a href="#4-4-锁超时" class="headerlink" title="4.4 锁超时"></a>4.4 锁超时</h2><p>Zookeeper不需要配置锁超时，由于我们设置节点是临时节点，我们的每个机器维护着一个ZK的session，通过这个session，ZK可以判断机器是否宕机。如果我们的机器挂掉的话，那么这个临时节点对应的就会被删除，所以我们不需要关心锁超时。</p>
<h2 id="4-5-ZK小结"><a href="#4-5-ZK小结" class="headerlink" title="4.5 ZK小结"></a>4.5 ZK小结</h2><ul>
<li>优点:ZK可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用ZK集群进行保证。</li>
<li>缺点:ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。</li>
</ul>
<h1 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5.Redis"></a>5.Redis</h1><p>大家在网上搜索分布式锁，恐怕最多的实现就是Redis了，Redis因为其性能好，实现起来简单所以让很多人都对其十分青睐。</p>
<h2 id="5-1-Redis分布式锁简单实现"><a href="#5-1-Redis分布式锁简单实现" class="headerlink" title="5.1 Redis分布式锁简单实现"></a>5.1 Redis分布式锁简单实现</h2><p>熟悉Redis的同学那么肯定对setNx(set if not exist)方法不陌生，如果不存在则更新，其可以很好的用来实现我们的分布式锁。对于某个资源加锁我们只需要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNx resourceName value</span><br></pre></td></tr></table></figure>

<p>这里有个问题，加锁了之后如果机器宕机那么这个锁就不会得到释放所以会加入过期时间，加入过期时间需要和setNx同一个原子操作，在Redis2.8之前我们需要使用Lua脚本达到我们的目的，但是redis2.8之后redis支持nx和ex操作是同一原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set resourceName value ex <span class="number">5</span> nx</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Redisson"><a href="#5-2-Redisson" class="headerlink" title="5.2 Redisson"></a>5.2 Redisson</h2><p>Javaer都知道Jedis，Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。Redisson也是Redis的客户端，相比于Jedis功能简单。Jedis简单使用阻塞的I/O和redis交互，Redisson通过Netty支持非阻塞I/O。Jedis最新版本2.9.0是2016年的快3年了没有更新，而Redisson最新版本是2018.10月更新。</p>
<p>Redisson封装了锁的实现，其继承了java.util.concurrent.locks.Lock的接口，让我们像操作我们的本地Lock一样去操作Redisson的Lock，下面介绍一下其如何实现分布式锁。</p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f382f313636353239383938363263653561663f773d3131363026683d34363626663d706e6726733d313131363436.png" alt="img"></p>
<p>Redisson不仅提供了Java自带的一些方法(lock,tryLock)，还提供了异步加锁，对于异步编程更加方便。 由于内部源码较多，就不贴源码了，这里用文字叙述来分析他是如何加锁的，这里分析一下tryLock方法:</p>
<ol>
<li><p>尝试加锁:首先会尝试进行加锁，由于保证操作是原子性，那么就只能使用lua脚本，相关的lua脚本如下： </p>
<p><img src="/2019/08/28/distributed-lock/20190828172849.jpg" alt="img"></p>
<p> 可以看见他并没有使用我们的sexNx来进行操作，而是使用的hash结构，我们的每一个需要锁定的资源都可以看做是一个HashMap，锁定资源的节点信息是Key,锁定次数是value。通过这种方式可以很好的实现可重入的效果，只需要对value进行加1操作，就能进行可重入锁。当然这里也可以用之前我们说的本地计数进行优化: </p>
<ol>
<li>如果通过 <code>exists</code> 命令发现当前 key 不存在，即锁没被占用，则执行 <code>hset</code> 写入 Hash 类型数据 <strong>key:全局锁名称</strong>（例如共享资源ID）, <strong>field:锁实例名称</strong>（Redisson客户端ID:线程ID）, <strong>value:1</strong>，并执行 <code>pexpire</code> 对该 key 设置失效时间，返回空值 <code>nil</code>，至此获取锁成功。</li>
<li>如果通过 <code>hexists</code> 命令发现 Redis 中已经存在当前 key 和 field 的 Hash 数据，说明当前线程之前已经获取到锁，因为这里的锁是<strong>可重入</strong>的，则执行 <code>hincrby</code> 对当前 key field 的值<strong>加一</strong>，并重新设置失效时间，返回空值，至此重入获取锁成功。</li>
<li>最后是锁已被占用的情况，即当前 key 已经存在，但是 Hash 中的 Field 与当前值不同，则执行 <code>pttl</code> 获取锁的剩余存活时间并返回，至此获取锁失败。</li>
</ol>
</li>
<li><p>如果尝试加锁失败，判断是否超时，如果超时则返回false。</p>
</li>
<li><p>如果加锁失败之后，没有超时，那么需要在名字为redisson_lock__channel+lockName的channel上进行订阅，用于订阅解锁消息，然后一直阻塞直到超时，或者有解锁消息。这里的具体实现本文也不深入，只是简单提一下 Redisson 在执行 Redis 命令时提供了<strong>同步</strong>和<strong>异步</strong>的两种实现，但实际上<strong>同步的实现都是基于异步的</strong>，具体做法是使用 Netty 中的异步工具 <em>Future*和 *FutureListener</em> 结合 JDK 中的 <em>CountDownLatch</em> 一起实现。</p>
</li>
<li><p>重试步骤1，2，3，直到最后获取到锁，或者某一步获取锁超时。</p>
</li>
</ol>
<p>对于我们的unlock方法比较简单也是通过lua脚本进行解锁，如果是可重入锁，只是减1。如果是非加锁线程解锁，那么解锁失败: </p>
<p><img src="/2019/08/28/distributed-lock/20190828173014.jpg" alt="img"></p>
<ol>
<li>key 不存在，说明锁已释放，直接执行 <code>publish</code> 命令发布释放锁消息并返回 <code>1</code>。</li>
<li>key 存在，但是 field 在 Hash 中不存在，说明自己不是锁持有者，无权释放锁，返回 <code>nil</code>。</li>
<li>因为锁可重入，所以释放锁时不能把所有已获取的锁全都释放掉，一次只能释放一把锁，因此执行 <code>hincrby</code> 对锁的值<strong>减一</strong>。</li>
<li>释放一把锁后，如果还有剩余的锁，则刷新锁的失效时间并返回 <code>0</code>；如果刚才释放的已经是最后一把锁，则执行 <code>del</code> 命令删除锁的 key，并发布锁释放消息，返回 <code>1</code>。</li>
</ol>
<p>Redisson还有公平锁的实现，对于公平锁其利用了list结构和hashset结构分别用来保存我们排队的节点，和我们节点的过期时间，用这两个数据结构帮助我们实现公平锁，这里就不展开介绍了，有兴趣可以参考源码。</p>
<h3 id="上述-Redis-分布式锁的缺点"><a href="#上述-Redis-分布式锁的缺点" class="headerlink" title="上述 Redis 分布式锁的缺点"></a>上述 Redis 分布式锁的缺点</h3><p>上面那种方案最大的问题，就是如果你对某个 Redis Master 实例，写入了 myLock 这种锁 Key 的 Value，此时会异步复制给对应的 Master Slave 实例。</p>
<p>但是这个过程中一旦发生 Redis Master 宕机，主备切换，Redis Slave 变为了 Redis Master。</p>
<p>接着就会导致，客户端 2 来尝试加锁的时候，在新的 Redis Master 上完成了加锁，而客户端 1 也以为自己成功加了锁。</p>
<p>此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p>
<p>所以这个就是 Redis Cluster，或者是 redis master-slave 架构的主从异步复制导致的 Redis 分布式锁的最大缺陷：在 Redis Master 实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<h2 id="5-3-RedLock"><a href="#5-3-RedLock" class="headerlink" title="5.3 RedLock"></a>5.3 RedLock</h2><p>我们想象一个这样的场景当机器A申请到一把锁之后，如果Redis主宕机了，这个时候从机并没有同步到这一把锁，那么机器B再次申请的时候就会再次申请到这把锁，为了解决这个问题Redis作者提出了RedLock红锁的算法,在Redisson中也对RedLock进行了实现。</p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f382f313636353262643935653131613862333f773d3130363926683d33383026663d706e6726733d3732323731.png" alt="img"></p>
<p>通过上面的代码，我们需要实现多个Redis集群，然后进行红锁的加锁，解锁。具体的步骤如下:</p>
<ol>
<li>首先生成多个Redis集群的Rlock，并将其构造成RedLock。</li>
<li>依次循环对三个集群进行加锁，加锁的过程和5.2里面一致。</li>
<li>如果循环加锁的过程中加锁失败，那么需要判断加锁失败的次数是否超出了最大值，这里的最大值是根据集群的个数，比如三个那么只允许失败一个，五个的话只允许失败两个，要保证多数成功。</li>
<li>加锁的过程中需要判断是否加锁超时，有可能我们设置加锁只能用3ms，第一个集群加锁已经消耗了3ms了。那么也算加锁失败。</li>
<li>3，4步里面加锁失败的话，那么就会进行解锁操作，解锁会对所有的集群在请求一次解锁。</li>
</ol>
<p>可以看见RedLock基本原理是利用多个Redis集群，用多数的集群加锁成功，减少Redis某个集群出故障，造成分布式锁出现问题的概率。</p>
<h2 id="5-4-Redis小结"><a href="#5-4-Redis小结" class="headerlink" title="5.4 Redis小结"></a>5.4 Redis小结</h2><ul>
<li>优点:对于Redis实现简单，性能对比ZK和Mysql较好。如果不需要特别复杂的要求，那么自己就可以利用setNx进行实现，如果自己需要复杂的需求的话那么可以利用或者借鉴Redisson。对于一些要求比较严格的场景来说的话可以使用RedLock。</li>
<li>缺点:需要维护Redis集群，如果要实现RedLock那么需要维护更多的集群。</li>
</ul>
<h1 id="6-分布式锁的安全问题"><a href="#6-分布式锁的安全问题" class="headerlink" title="6.分布式锁的安全问题"></a>6.分布式锁的安全问题</h1><p>上面我们介绍过红锁，但是Martin Kleppmann认为其依然不安全。有关于Martin反驳的几点，我认为其实不仅仅局限于RedLock,前面说的算法基本都有这个问题，下面我们来讨论一下这些问题:</p>
<ul>
<li><p>长时间的GC pause:熟悉Java的同学肯定对GC不陌生，在GC的时候会发生STW(stop-the-world),例如CMS垃圾回收器，他会有两个阶段进行STW防止引用继续进行变化。那么有可能会出现下面图(引用至Martin反驳Redlock的文章)中这个情况： </p>
<p><img src="/2019/08/28/distributed-lock/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f382f313636353334353064343561326139363f773d3131333526683d34323926663d706e6726733d3439303436.png" alt="img"></p>
<p> client1获取了锁并且设置了锁的超时时间，但是client1之后出现了STW，这个STW时间比较长，导致分布式锁进行了释放，client2获取到了锁，这个时候client1恢复了锁，那么就会出现client1，2同时获取到锁，这个时候分布式锁不安全问题就出现了。这个其实不仅仅局限于RedLock,对于我们的ZK,Mysql一样的有同样的问题。</p>
</li>
<li><p>时钟发生跳跃:对于Redis服务器如果其时间发生了向跳跃，那么肯定会影响我们锁的过期时间，那么我们的锁过期时间就不是我们预期的了，也会出现client1和client2获取到同一把锁，那么也会出现不安全，这个对于Mysql也会出现。但是ZK由于没有设置过期时间，那么发生跳跃也不会受影响。</p>
</li>
<li><p>长时间的网络I/O:这个问题和我们的GC的STW很像，也就是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题，这个Mysql也会有，ZK也不会出现这个问题。</p>
</li>
</ul>
<p>对于这三个问题，在网上包括Redis作者在内发起了很多讨论。</p>
<h2 id="6-1-GC的STW"><a href="#6-1-GC的STW" class="headerlink" title="6.1 GC的STW"></a>6.1 GC的STW</h2><p>对于这个问题可以看见基本所有的都会出现问题，Martin给出了一个解法，对于ZK这种他会生成一个自增的序列，那么我们真正进行对资源操作的时候，需要判断当前序列是否是最新，有点类似于我们乐观锁。当然这个解法Redis作者进行了反驳，你既然都能生成一个自增的序列了那么你完全不需要加锁了，也就是可以按照类似于Mysql乐观锁的解法去做。</p>
<p>我自己认为这种解法增加了复杂性，当我们对资源操作的时候需要增加判断序列号是否是最新，无论用什么判断方法都会增加复杂度，后面会介绍谷歌的Chubby提出了一个更好的方案。</p>
<h2 id="6-2-时钟发生跳跃"><a href="#6-2-时钟发生跳跃" class="headerlink" title="6.2 时钟发生跳跃"></a>6.2 时钟发生跳跃</h2><p>Martin觉得RedLock不安全很大的原因也是因为时钟的跳跃，因为锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。Redis作者也给出了解答:对于时间跳跃分为人为调整和NTP自动调整。</p>
<ul>
<li>人为调整:人为调整影响的那么完全可以人为不调整，这个是处于可控的。</li>
<li>NTP自动调整:这个可以通过一定的优化，把跳跃时间控制的可控范围内，虽然会跳跃，但是是完全可以接受的。</li>
</ul>
<h2 id="6-3-长时间的网络I-O"><a href="#6-3-长时间的网络I-O" class="headerlink" title="6.3 长时间的网络I/O"></a>6.3 长时间的网络I/O</h2><p>这一块不是他们讨论的重点，我自己觉得，对于这个问题的优化可以控制网络调用的超时时间，把所有网络调用的超时时间相加，那么我们锁过期时间其实应该大于这个时间，当然也可以通过优化网络调用比如串行改成并行，异步化等。可以参考我的两个文章: <a href="https://juejin.im/post/5b9861d15188255c581a92a0" target="_blank" rel="noopener">并行化-你的高并发大杀器</a>，<a href="https://juejin.im/post/5b4cd263e51d4519846971e0" target="_blank" rel="noopener">异步化-你的高并发大杀器</a></p>
<h1 id="7-Chubby的一些优化"><a href="#7-Chubby的一些优化" class="headerlink" title="7. Chubby的一些优化"></a>7. Chubby的一些优化</h1><p>大家搜索ZK的时候，会发现他们都写了ZK是Chubby的开源实现，Chubby内部工作原理和ZK类似。但是Chubby的定位是分布式锁和ZK有点不同。Chubby也是使用上面自增序列的方案用来解决分布式不安全的问题，但是他提供了多种校验方法:</p>
<ul>
<li>CheckSequencer()：调用Chubby的API检查此时这个序列号是否有效。</li>
<li>访问资源服务器检查，判断当前资源服务器最新的序列号和我们的序列号的大小。</li>
<li>lock-delay:为了防止我们校验的逻辑入侵我们的资源服务器，其提供了一种方法当客户端失联的时候，并不会立即释放锁，而是在一定的时间内(默认1min)阻止其他客户端拿去这个锁，那么也就是给予了一定的buffer等待STW恢复，而我们的GC的STW时间如果比1min还长那么你应该检查你的程序，而不是怀疑你的分布式锁了。</li>
</ul>
<h1 id="8-每秒上千订单场景下的分布式锁高并发优化实践"><a href="#8-每秒上千订单场景下的分布式锁高并发优化实践" class="headerlink" title="8. 每秒上千订单场景下的分布式锁高并发优化实践"></a>8. 每秒上千订单场景下的分布式锁高并发优化实践</h1><p>接着就给大家聊一个有意思的话题：每秒上千订单场景下，如何对分布式锁的并发能力进行优化?</p>
<p>首先，我们一起来看看这个问题的背景?前段时间有个朋友在外面面试，然后有一天找我聊说：有一个国内不错的电商公司，面试官给他出了一个场景题：</p>
<p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景?</p>
<p>他说他当时没答上来，因为没做过没什么思路。其实我当时听到这个面试题心里也觉得有点意思，因为如果是我来面试候选人的话，应该会给的范围更大一些。</p>
<p>比如，让面试的同学聊一聊电商高并发秒杀场景下的库存超卖解决方案，各种方案的优缺点以及实践，进而聊到分布式锁这个话题。</p>
<p>因为库存超卖问题是有很多种技术解决方案的，比如悲观锁，分布式锁，乐观锁，队列串行化，Redis 原子操作，等等吧。</p>
<p>但是既然那个面试官兄弟限定死了用分布式锁来解决库存超卖，我估计就是想问一个点：在高并发场景下如何优化分布式锁的并发性能。</p>
<p>我觉得，面试官提问的角度还是可以接受的，因为在实际落地生产的时候，分布式锁这个东西保证了数据的准确性，但是他天然并发能力有点弱。</p>
<p>刚好我之前在自己项目的其他场景下，确实是做过高并发场景下的分布式锁优化方案，因此正好是借着这个朋友的面试题，把分布式锁的高并发优化思路，给大家来聊一聊。</p>
<h2 id="8-1-库存超卖现象是怎么产生的"><a href="#8-1-库存超卖现象是怎么产生的" class="headerlink" title="8.1 库存超卖现象是怎么产生的?"></a>8.1 库存超卖现象是怎么产生的?</h2><p>先来看看如果不用分布式锁，所谓的电商库存超卖是啥意思?大家看看下面的图：</p>
<p><img src="/2019/08/28/distributed-lock/MRRJ7vq.png" alt="img"></p>
<p>这个图，其实很清晰了，假设订单系统部署在两台机器上，不同的用户都要同时买 10 台 iPhone，分别发了一个请求给订单系统。</p>
<p>接着每个订单系统实例都去数据库里查了一下，当前 iPhone 库存是 12 台。俩大兄弟一看，乐了，12 台库存大于了要买的 10 台数量啊!</p>
<p>于是乎，每个订单系统实例都发送 SQL 到数据库里下单，然后扣减了 10 个库存，其中一个将库存从 12 台扣减为 2 台，另外一个将库存从 2 台扣减为 -8 台。</p>
<p>现在完了，库存出现了负数!泪奔啊，没有 20 台 iPhone 发给两个用户啊!这可如何是好。</p>
<h2 id="8-2-用分布式锁如何解决库存超卖问题"><a href="#8-2-用分布式锁如何解决库存超卖问题" class="headerlink" title="8.2 用分布式锁如何解决库存超卖问题?"></a>8.2 用分布式锁如何解决库存超卖问题?</h2><p>我们用分布式锁如何解决库存超卖问题呢?其实很简单，回忆一下上次我们说的那个分布式锁的实现原理：</p>
<p>同一个锁 Key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p>
<p><img src="/2019/08/28/distributed-lock/6B265385-4A47-47A5-844F-AE2E2170EB8A.png" alt="img"></p>
<p>代码大概就是上面那个样子，现在我们来分析一下，为啥这样做可以避免库存超卖?</p>
<p><img src="/2019/08/28/distributed-lock/jIzuMz2.png" alt="img"></p>
<p>大家可以顺着上面的那个步骤序号看一遍，马上就明白了。</p>
<p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。</p>
<p>释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有 2 台了，库存不足，无法购买，下单失败。不会将库存扣减为 -8 的。</p>
<h2 id="8-3-有没其他方案解决库存超卖问题"><a href="#8-3-有没其他方案解决库存超卖问题" class="headerlink" title="8.3 有没其他方案解决库存超卖问题?"></a>8.3 有没其他方案解决库存超卖问题?</h2><p>当然有啊!比如悲观锁，分布式锁，乐观锁，队列串行化，异步队列分散，Redis 原子操作，等等，很多方案，我们对库存超卖有自己的一整套优化机制。</p>
<p>但是前面说过了，这篇文章就聊一个分布式锁的并发优化，不是聊库存超卖的解决方案，所以库存超卖只是一个业务场景而已。</p>
<h2 id="8-4-分布式锁的方案在高并发场景下"><a href="#8-4-分布式锁的方案在高并发场景下" class="headerlink" title="8.4 分布式锁的方案在高并发场景下"></a>8.4 分布式锁的方案在高并发场景下</h2><p>好，现在我们来看看，分布式锁的方案在高并发场景下有什么问题?</p>
<p>问题很大啊!兄弟，不知道你看出来了没有。分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁 Key 进行加锁。</p>
<p>比如，对 iPhone 这个商品的下单，都必对“iphone_stock”这个锁 Key 来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。</p>
<p>大家再回去对照上面的图反复看一下，应该能想明白这个问题。</p>
<p>假设加锁之后，释放锁之前，查库存→创建订单→扣减库存，这个过程性能很高吧，算他全过程 20 毫秒，这应该不错了。</p>
<p>那么 1 秒是 1000 毫秒，只能容纳 50 个对这个商品的请求依次串行完成处理。</p>
<p>比如一秒钟来 50 个请求，都是对 iPhone 下单的，那么每个请求处理 20 毫秒，一个一个来，最后 1000 毫秒正好处理完 50 个请求。</p>
<p>大家看一眼下面的图，加深一下感觉。</p>
<p><img src="/2019/08/28/distributed-lock/BRjM3aV.png" alt="img"></p>
<p>所以看到这里，大家起码也明白了，简单的使用分布式锁来处理库存超卖问题，存在什么缺陷。</p>
<p>缺陷就是同一个商品多用户同时下单的时候，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。</p>
<p>这种方案，要是应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p>
<p>因为如果并发量很低，每秒就不到 10 个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在 1 秒内瞬间下 1000 个订单，因为小电商系统没那场景。</p>
<h2 id="8-5-如何对分布式锁进行高并发优化"><a href="#8-5-如何对分布式锁进行高并发优化" class="headerlink" title="8.5 如何对分布式锁进行高并发优化?"></a>8.5 如何对分布式锁进行高并发优化?</h2><p>好了，终于引入正题了，那么现在怎么办呢?</p>
<p>面试官说，我现在就卡死，库存超卖就是用分布式锁来解决，而且一秒对一个 iPhone 下上千订单，怎么优化?</p>
<p>现在按照刚才的计算，你 1 秒钟只能处理针对 iPhone 的 50 个订单。其实说出来也很简单，相信很多人看过 Java 里的 ConcurrentHashMap 的源码和底层原理，应该知道里面的核心思路，就是分段加锁!</p>
<p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改 ConcurrentHashMap 中的数据。</p>
<p>另外，Java 8 中新增了一个 LongAdder 类，也是针对 Java 7 以前的 AtomicLong 进行的优化，解决的是 CAS 类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p>
<p>LongAdder 中也是采用了类似的分段 CAS 操作，失败则自动迁移到下一个分段进行 CAS 的思路。</p>
<p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p>
<p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p>
<p>大家看看下面的图：</p>
<p><img src="/2019/08/28/distributed-lock/niAVJvm.png" alt="img"></p>
<p>这就是分段加锁。假如你现在 iPhone 有 1000 个库存，那么你完全可以给拆成 20 个库存段。</p>
<p>要是你愿意，可以在数据库的表里建 20 个库存字段，比如 stock_01，stock_02，类似这样的，也可以在 Redis 之类的地方放 20 个库存 Key。</p>
<p>总之，就是把你的 1000 件库存给他拆开，每个库存段是 50 件库存，比如 stock_01 对应 50 件库存，stock_02 对应 50 件库存。</p>
<p>接着，每秒 1000 个请求过来了，好!此时其实可以是自己写一个简单的随机算法，每个请求都是随机在 20 个分段库存里，选择一个进行加锁。</p>
<p>Bingo!这样就好了，同时可以有最多 20 个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是 Redis 中的那个分段库存进行操作即可，包括查库存→判断库存是否充足→扣减库存。</p>
<p>这相当于什么呢?相当于一个 20 毫秒，可以并发处理掉 20 个下单请求，那么 1 秒，也就可以依次处理掉 20 * 50 = 1000 个对 iPhone 的下单请求了。</p>
<p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：就是如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办?</p>
<p>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现。</p>
<h2 id="8-6-分布式锁并发优化方案有什么不足"><a href="#8-6-分布式锁并发优化方案有什么不足" class="headerlink" title="8.6 分布式锁并发优化方案有什么不足?"></a>8.6 分布式锁并发优化方案有什么不足?</h2><p>不足肯定是有的，最大的不足，很不方便，实现太复杂了：</p>
<ul>
<li>首先，你得对一个数据分段存储，一个库存字段本来好好的，现在要分为 20 个库存字段。</li>
<li>其次，你在每次处理库存的时候，还得自己写随机算法，随机挑选一个分段来处理。</li>
<li>最后，如果某个分段中的数据不足了，你还得自动切换到下一个分段数据去处理。</li>
</ul>
<p>这个过程都是要手动写代码实现的，还是有点工作量，挺麻烦的。</p>
<p>不过我们确实在一些业务场景里，因为用到了分布式锁，然后又必须要进行锁并发的优化，又进一步用到了分段加锁的技术方案，效果当然是很好的了，一下子并发性能可以增长几十倍。</p>
<p>该优化方案的后续改进：以我们本文所说的库存超卖场景为例，你要是这么玩，会把自己搞的很痛苦!再次强调，我们这里的库存超卖场景，仅仅只是作为演示场景而已。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-5" target="_blank" rel="noopener">再有人问你分布式锁，这篇文章扔给他</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962774&idx=1&sn=17e9a5e014651430dea14b460a789207&chksm=bd2d084a8a5a815ced2370f055a8413afdde0988fe0736f85b929d1af229af99be56b2edb933&token=2034999168&lang=zh_CN&scene=25#wechat_redirect" target="_blank" rel="noopener">每秒100W请求，12306秒杀业务，架构如何优化？</a></li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/28/optimistic-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/28/optimistic-lock/" class="post-title-link" itemprop="url">乐观锁</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-28 14:25:23" itemprop="dateCreated datePublished" datetime="2019-08-28T14:25:23+08:00">2019-08-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-08 18:42:01" itemprop="dateModified" datetime="2019-09-08T18:42:01+08:00">2019-09-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发控制/" itemprop="url" rel="index"><span itemprop="name">并发控制</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发控制/乐观锁/" itemprop="url" rel="index"><span itemprop="name">乐观锁</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">4.5k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">4 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>乐观锁通俗的理解就是，数据有一个版本号，第一次读的时候将获取数据的版本号；当需要对数据进行更新时，需要检查数据库中的版本号与第一次获取的版本号是否一致。如果一致则更新数据，否则不更新。也就是说，要保证数据在中间没被修改过。乐观锁一般来说有以下2种方式：</p>
<ol>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li>
<li>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p>Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="牙膏库存"><a href="#牙膏库存" class="headerlink" title="牙膏库存"></a>牙膏库存</h2><p>牙膏库存为 100 件，用户 A （线程 A ）和用户 B （线程 B ）同时购买一件牙膏。</p>
<ol>
<li>线程 A 读取牙膏库存（ 100 件，版本号为 1 ，不加锁），线程 B 读取牙膏库存（ 100 件，版本号为 1 ，不加锁）；</li>
<li>线程 A 将库存减 1 ， 100-1=99 件；线程 B 将库存减 1 ， 100-1=99 件（注意还没更新到牙膏库存）；</li>
<li>因为线程 A 、线程 B 总有一个线程必先执行，假设是线程 A 。线程 A 将库存减 1 后（库存为 100-1=99 件），通过本地版本号与数据库版本号比对（都为 1 ），因为版本号一致，所以更新牙膏库存（牙膏库存变为 99 件，版本号变为 2 ），线程 A 执行完毕；</li>
<li>线程 B 将库存减 1 后（库存为 100-1=99 件），通过本地版本号（为 1 ）与数据库版本号（为 2 ）比对，因为版本号不一致，所以不更新牙膏库存，线程 B 重新读取牙膏库存（库存为 99 ，版本号为 2 ），重复执行。</li>
<li>线程 B 将库存减 1 后（库存为 99-1=98 件），通过本地版本号（为 2 ）与数据库版本号（为 2 ）对比，因为版本号一致，所以更新牙膏库存（牙膏库存变为 98 件，版本号变为 3 ），线程 B 执行完毕。</li>
</ol>
<p><img src="/2019/08/28/optimistic-lock/leguansuo.png" alt="乐观锁(执行顺序为绿色 → 蓝色 → 红色)"></p>
<h2 id="电商下单"><a href="#电商下单" class="headerlink" title="电商下单"></a>电商下单</h2><p>考虑电商系统中的下单流程，商品的库存量是固定的，如何保证商品数量不超卖？ 其实需要保证数据一致性：某个人点击秒杀后系统中查出来的库存量和实际扣减库存时库存量的一致性就可以。</p>
<p>假设，MySQL数据库中商品库存表tb_product_stock 结构定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_product_stock` (</span><br><span class="line">  `id` bigint(<span class="number">20</span>) NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增ID'</span>,</span><br><span class="line">  `product_id` bigint(<span class="number">32</span>) NOT NULL COMMENT <span class="string">'商品ID'</span>,</span><br><span class="line">  `number` INT(<span class="number">8</span>) NOT NULL DEFAULT <span class="number">0</span> COMMENT <span class="string">'库存数量'</span>,</span><br><span class="line">  `create_time` DATETIME NOT NULL COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `modify_time` DATETIME NOT NULL COMMENT <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span><br><span class="line"><span class="function">  UNIQUE KEY `index_pid` <span class="params">(`product_id`)</span></span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8 COMMENT=<span class="string">'商品库存表'</span>;</span><br></pre></td></tr></table></figure>

<p>对应的POJO类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductStock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long productId; <span class="comment">//商品id</span></span><br><span class="line">    <span class="keyword">private</span> Integer number; <span class="comment">//库存量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getProductId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductId</span><span class="params">(Long productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新库存(使用悲观锁)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先锁定商品库存记录</span></span><br><span class="line">        ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125; FOR UPDATE"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">            <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下单减库存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updateCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (updateCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        ProductStock product = query(<span class="string">"SELECT * FROM tb_product_stock WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            updateCnt = update(<span class="string">"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;"</span>, productId, product.getNumber());</span><br><span class="line">            <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//卖完啦</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。</p>
<p><strong>注意</strong>：UPDATE 语句的WHERE 条件字句上需要建索引</p>
<h3 id="乐观锁与悲观锁的区别"><a href="#乐观锁与悲观锁的区别" class="headerlink" title="乐观锁与悲观锁的区别"></a>乐观锁与悲观锁的区别</h3><p>乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。</p>
<p>悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁（SELECT … FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。</p>
<h1 id="CAS：compare-and-swap"><a href="#CAS：compare-and-swap" class="headerlink" title="CAS：compare and swap"></a>CAS：compare and swap</h1><p> CAS的含义是，我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少。<br> 附上java.util.concurrent.atomic.AtomicLong中的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">long</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   LongBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsLong(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>MySQL 乐观锁与悲观锁: <a href="https://www.jianshu.com/p/f5ff017db62a" target="_blank" rel="noopener">https://www.jianshu.com/p/f5ff017db62a</a></li>
<li>并发扣款一致性，幂等性问题，这个话题还没聊完: <a href="https://mp.weixin.qq.com/s/xXju0y64KKUiD06QE0LoeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xXju0y64KKUiD06QE0LoeA</a></li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/27/innodb-consistent-nonlocking-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/27/innodb-consistent-nonlocking-read/" class="post-title-link" itemprop="url">MySQL探秘:InnoDB一致性非锁定读</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-27 15:44:15" itemprop="dateCreated datePublished" datetime="2019-08-27T15:44:15+08:00">2019-08-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 10:55:58" itemprop="dateModified" datetime="2019-08-29T10:55:58+08:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">5.5k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">5 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h1><p>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/853859881-5bf1705c03809.jpeg" alt="一致性非锁定读示意图"></p>
<p>上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="/2019/08/27/innodb-consistent-nonlocking-read/v2-59ea2f0769e4e9ffbcdce938d306fae9_hd.png" alt="事务隔离级别"></p>
<p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据(可能会发生在一个事务内两次读到的数据是不一样的，因此称为是不可重复读)。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>我们下面举个例子来详细说明一下上述的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># session A</span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">mysql&gt; SELECT * FROM test WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p>我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># session B</span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">mysql&gt; UPDATE test SET id = 3 WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p>在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/415780367-5bf17074cec9d_articlex.jpeg" alt="会话A和会话B示意图"></p>
<p>如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果是最新的。<br>对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<p>MySQL采用了gap lock，所以实际上MySQL的REPEATABLE READ隔离级别也解决了幻读的问题，也就是Mysql InnoDB在Read repeatable级别上使用next-key locking 策略来避免幻读现象的产生。详见: <a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">Innodb锁机制：Next-Key Lock 浅谈</a></p>
<p>上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p>
<h1 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h1><p>我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control<br>method commonly used by database management systems to provide<br>concurrent access to the database and in programming languages to<br>implement transactional memory.</p>
</blockquote>
<p>由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/2798176057-5bf1709069954_articlex.jpeg" alt="转账和查询的时序图"></p>
<p>如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/3686032684-5bf170a60d5cd_articlex.jpeg" alt="使用锁机制"></p>
<p>但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/1043733839-5bf170bd67174_articlex.jpeg" alt="使用MVVC机制"></p>
<p>MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)。</p>
<p>通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<ul>
<li>快照读：就是select<ul>
<li>select * from table ….;</li>
</ul>
</li>
<li>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert;</li>
<li>update ;</li>
<li>delete;</li>
</ul>
</li>
</ul>
<h1 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h1><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。</p>
<p>数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。</p>
<p>根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。</p>
<p>update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。</p>
<p>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。</p>
<p>InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/1062683863-5bf170de9dea7_articlex.jpeg" alt="初始状态"></p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/685302939-5bf170f286454_articlex.jpeg" alt="第一次修改"></p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="/2019/08/27/innodb-consistent-nonlocking-read/225442626-5bf1710438a7b_articlex.jpeg" alt="第二次修改"></p>
<p>REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>MySQL探秘(六):InnoDB一致性非锁定读: <a href="https://segmentfault.com/a/1190000017055118" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017055118</a></li>
<li>Innodb锁机制：Next-Key Lock 浅谈: <a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a></li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.sainpo.top/2019/08/25/zookeeper-server-role/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sainpo.yxb">
      <meta itemprop="description" content="码农|理工男|文青">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="窦小固的小木屋">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/25/zookeeper-server-role/" class="post-title-link" itemprop="url">Zookeeper的服务器角色</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-25 21:05:51" itemprop="dateCreated datePublished" datetime="2019-08-25T21:05:51+08:00">2019-08-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-26 20:59:32" itemprop="dateModified" datetime="2019-08-26T20:59:32+08:00">2019-08-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/" itemprop="url" rel="index"><span itemprop="name">分布式一致性</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式一致性/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a></span>

                
                
              
            </span>
          

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.5k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h1><p>Leader服务器是Zookeeper集群工作的核心，其主要工作如下</p>
<ul>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</li>
<li>集群内部各服务器的调度者。</li>
</ul>
<h2 id="请求处理链"><a href="#请求处理链" class="headerlink" title="请求处理链"></a>请求处理链</h2><p>使用责任链来处理每个客户端的请求时Zookeeper的特色，Leader服务器的请求处理链如下</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206203032319-1806823400.png" alt="Leader服务器请求处理链"></p>
<ol>
<li>PrepRequestProcessor。请求预处理器。在Zookeeper中，那些会改变服务器状态的请求称为事务请求（创建节点、更新数据、删除节点、创建会话等），PrepRequestProcessor能够识别出当前客户端请求是否是事务请求。对于事务请求，PrepRequestProcessor处理器会对其进行一系列预处理，如创建请求事务头、事务体、会话检查、ACL检查和版本检查等。</li>
<li>ProposalRequestProcessor。事务投票处理器。Leader服务器事务处理流程的发起者，对于非事务性请求，ProposalRequestProcessor会直接将请求转发到CommitProcessor处理器，不再做任何处理，而对于事务性请求，处理将请求转发到CommitProcessor外，还会根据请求类型创建对应的Proposal提议，并发送给所有的Follower服务器来发起一次集群内的事务投票。同时，ProposalRequestProcessor还会将事务请求交付给SyncRequestProcessor进行事务日志的记录。</li>
<li>SyncRequestProcessor。事务日志记录处理器。用来将事务请求记录到事务日志文件中，同时会触发Zookeeper进行数据快照。</li>
<li>AckRequestProcessor。负责在SyncRequestProcessor完成事务日志记录后，向Proposal的投票收集器发送ACK反馈，以通知投票收集器当前服务器已经完成了对该Proposal的事务日志记录。</li>
<li>CommitProcessor。事务提交处理器。对于非事务请求，该处理器会直接将其交付给下一级处理器处理；对于事务请求，其会等待集群内针对Proposal的投票直到该Proposal可被提交，利用CommitProcessor，每个服务器都可以很好地控制对事务请求的顺序处理。</li>
<li>ToBeCommitProcessor。该处理器有一个toBeApplied队列，用来存储那些已经被CommitProcessor处理过的可被提交的Proposal。其会将这些请求交付给FinalRequestProcessor处理器处理，待其处理完后，再将其从toBeApplied队列中移除。</li>
<li>FinalRequestProcessor。用来进行客户端请求返回之前的操作，包括创建客户端请求的响应，针对事务请求，该处理还会负责将事务应用到内存数据库中去。</li>
</ol>
<h2 id="LearnerHandler"><a href="#LearnerHandler" class="headerlink" title="LearnerHandler"></a>LearnerHandler</h2><p>为了保证整个集群内部的实时通信，同时为了确保可以控制所有的Follower/Observer服务器，Leader服务器会与每个Follower/Observer服务器建立一个TCP长连接。同时也会为每个Follower/Observer服务器创建一个名为LearnerHandler的实体。LearnerHandler是Learner服务器的管理者，主要负责Follower/Observer服务器和Leader服务器之间的一系列网络通信，包括数据同步、请求转发和Proposal提议的投票等。Leader服务器中保存了所有Follower/Observer对应的LearnerHandler。</p>
<h1 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h1><p>Follower是Zookeeper集群的跟随者，其主要工作如下</p>
<ul>
<li>处理客户端非事务性请求（读取数据），转发事务请求给Leader服务器。</li>
<li>参与事务请求Proposal的投票。</li>
<li>参与Leader选举投票。</li>
</ul>
<p>Follower也采用了责任链模式组装的请求处理链来处理每一个客户端请求，由于不需要对事务请求的投票处理，因此Follower的请求处理链会相对简单，其处理链如下</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206205916319-94850171.png" alt="Follower服务器请求处理链"></p>
<ol>
<li>FollowerRequestProcessor。其用作识别当前请求是否是事务请求，若是，那么Follower就会将该请求转发给Leader服务器，Leader服务器是在接收到这个事务请求后，就会将其提交到请求处理链，按照正常事务请求进行处理。</li>
<li>SendAckRequestProcessor。其承担了事务日志记录反馈的角色，在完成事务日志记录后，会向Leader服务器发送ACK消息以表明自身完成了事务日志的记录工作。</li>
</ol>
<h1 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h1><p>Observer充当观察者角色，观察Zookeeper集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给Leader服务器进行处理。Observer不会参与任何形式的投票，包括事务请求Proposal的投票和Leader选举投票。其处理链如下</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206210521179-2100336705.png" alt="Observer服务器请求处理链"></p>
<h1 id="集群间消息通信"><a href="#集群间消息通信" class="headerlink" title="集群间消息通信"></a>集群间消息通信</h1><p>Zookeeper的消息类型大体分为数据同步型、服务器初始化型、请求处理型和会话管理型。</p>
<h2 id="数据同步型"><a href="#数据同步型" class="headerlink" title="数据同步型"></a>数据同步型</h2><p>指在Learner和Leader服务器进行数据同步时，网络通信所用到的消息，通常有DIFF、TRUNC、SNAP、UPTODATE。</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206211659288-380771789.png" alt="Zookeeper集群间数据同步过程中的消息类型"></p>
<h2 id="服务器初始化型"><a href="#服务器初始化型" class="headerlink" title="服务器初始化型"></a>服务器初始化型</h2><p>指在整个集群或是某些新机器初始化时，Leader和Learner之间相互通信所使用的消息类型，常见的有OBSERVERINFO、FOLLOWERINFO、LEADERINFO、ACKEPOCH和NEWLEADER五种。</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206213138194-152453727.png" alt="Zookeeper集群服务器初始化过程中的消息类型"></p>
<h2 id="请求处理型"><a href="#请求处理型" class="headerlink" title="请求处理型"></a>请求处理型</h2><p>指在进行清理时，Leader和Learner服务器之间互相通信所使用的消息，常见的有REQUEST、PROPOSAL、ACK、COMMIT、INFORM和SYNC六种。</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206214318897-1132940651.png" alt="Zookeeper集群请求处理过程中的消息类型"></p>
<h2 id="会话管理型"><a href="#会话管理型" class="headerlink" title="会话管理型"></a>会话管理型</h2><p>指Zookeeper在进行会话管理时和Learner服务器之间互相通信所使用的消息，常见的有PING和REVALIDATE两种。</p>
<p><img src="/2019/08/25/zookeeper-server-role/616953-20161206215016601-1432875769.png" alt="Zookeeper集群会话管理过程中的消息类型"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>【分布式】Zookeeper的服务器角色: <a href="https://www.cnblogs.com/leesf456/p/6139266.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/6139266.html</a></li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sainpo.yxb</p>
  <div class="site-description motion-element" itemprop="description">码农|理工男|文青</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/mewishu" title="GitHub &rarr; https://github.com/mewishu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:xbyan88@163.com" title="E-Mail &rarr; mailto:xbyan88@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sainpo.yxb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">242k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/reading_progress/reading_progress.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.3.0"></script>








<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>





    


</body>
</html>
